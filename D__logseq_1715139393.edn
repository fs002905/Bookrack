{:version 1,
 :blocks
 ({:block/id #uuid "ab2d6e90-a42d-4513-ad24-3b39e9137599",
   :block/page-name "Contents",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "6612a77b-b028-4958-9087-5f641508fc21",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[🏠Home]]"}
    {:block/id #uuid "65f14810-4770-4e2c-9db0-58ba56ff95a0",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[📆TODO]]"}
    {:block/id #uuid "65f14810-db79-4956-80ea-2e65a880d887",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[🗂️Project]]"}
    {:block/id #uuid "65f14810-5b5d-42ad-a7fd-f0a264347576",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[📓Note]]"}
    {:block/id #uuid "65f14810-7967-452f-88d0-5aab64de0d89",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[📚Book]]"}
    {:block/id #uuid "65f14810-0fde-4cb4-a6f9-83b2f09b667e",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[🗃️Archive]]"}
    {:block/id #uuid "65f14810-00c2-463c-b5a3-98086eee0352",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[💡Idea]]"}
    {:block/id #uuid "6602664e-ef79-4d81-8a16-77fff3a9c897",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[☣️Warning]]"}
    {:block/id #uuid "66123c09-e0e5-4902-8e3f-ec74f61f3bab",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[📔TEMP]]"})}
  {:block/id #uuid "6625fcd2-2e59-49ba-a5c1-da1dceb42159",
   :block/page-name "📚Book",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65ea7762-d00c-4abd-b778-22e0c48456a1",
     :block/properties {},
     :block/format :markdown,
     :block/children [],
     :block/content
     "![Springer Handbook of Automation.pdf](../assets/Springer_Handbook_of_Automation_1709865466817_0.pdf) #Automation #Control"}
    {:block/id #uuid "65ea7a20-fcd1-40cf-985e-4bdd029e7761",
     :block/properties {},
     :block/format :markdown,
     :block/children [],
     :block/content
     "![控制之美[卷一].pdf](../assets/控制之美[卷一]_1709865510701_0.pdf) #Automation #Control"}
    {:block/id #uuid "65f14811-3a0a-44b9-864b-71c601d1dc25",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "![Industrial Robotics Control - Mathematical Models, Software Architecture, and Electronics Design.pdf](../assets/Industrial_Robotics_Control_-_Mathematical_Models,_Software_Architecture,_and_Electronics_Design_1710120776667_0.pdf) #Robotics #Control"}
    {:block/id #uuid "65f14811-4f15-4717-ae79-89449a125ea1",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "![PLC工业控制.pdf](../assets/PLC工业控制_1709865655594_0.pdf) #PLC"}
    {:block/id #uuid "65f14811-2996-4761-8bd4-46561158f51a",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "![Modicon Modbus Protocol Reference Guide.pdf](../assets/Modicon_Modbus_Protocol_Reference_Guide_1709865728986_0.pdf) #Bus #Modbus #Communication"}
    {:block/id #uuid "65f14811-46d9-4f27-a1a5-fab8fda5ac68",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "![EtherCAT工业以太网应用技术.pdf](../assets/EtherCAT工业以太网应用技术_1709865790439_0.pdf) #Bus #EtherCAT #Communication"}
    {:block/id #uuid "65ee5ea3-f508-4485-816c-e5b49b724ca3",
     :block/properties {},
     :block/format :markdown,
     :block/children [],
     :block/content
     "![Electric Motors and Drives - Fundamentals, Types and Applications.pdf](../assets/Electric_Motors_and_Drives_-_Fundamentals,_Types_and_Applications_1710120613540_0.pdf) #Motor #Control #Driver"}
    {:block/id #uuid "65f00c9b-99aa-4c1b-a1fd-951e4280a235",
     :block/properties {},
     :block/format :markdown,
     :block/children [],
     :block/content
     "![PRO、MAX系列总线型PLC编程通信指令说明书.pdf](../assets/PRO、MAX系列总线型PLC编程通信指令说明书_1710230683927_0.pdf) #PLC #Manual"}
    {:block/id #uuid "66061aac-f575-4eb5-9f38-611f7061ab93",
     :block/properties {},
     :block/format :markdown,
     :block/children [],
     :block/content
     "![C++ Primer Plus 6th Edition.pdf](../assets/C++_Primer_Plus_6th_Edition_1711676090207_0.pdf) #Coding #C++"}
    {:block/id #uuid "66061acf-5c09-4a98-9266-1d290f487b90",
     :block/properties {},
     :block/format :markdown,
     :block/children [],
     :block/content
     "![C Primer Plus 6th Edition.pdf](../assets/C_Primer_Plus_6th_Edition_1711676115842_0.pdf) #Coding #C"}
    {:block/id #uuid "66061adc-2e43-489b-afaa-e0041b8b670f",
     :block/properties {},
     :block/format :markdown,
     :block/children [],
     :block/content
     "![Pro GIT 2nd Edition.pdf](../assets/Pro_GIT_2nd_Edition_1711676168026_0.pdf) #Coding #Git"}
    {:block/id #uuid "660a59f3-1731-4d09-a46b-cb9f9f930981",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "![C++ Primer 3rd Edition.pdf](../assets/C++_Primer_3rd_Edition_1711954422504_0.pdf) #Coding #C++"}
    {:block/id #uuid "660a5a00-a10a-4856-80cf-ca73a72fe007",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "![C++ Primer 4th Edition.pdf](../assets/C++Primer_4th_Edition_1711954437042_0.pdf) #Coding #C++"}
    {:block/id #uuid "660a5c8e-1b0b-4511-b968-20856e92ee01",
     :block/properties {},
     :block/format :markdown,
     :block/children [],
     :block/content
     "![C++ Primer 5th Edition.pdf](../assets/C++_Primer_5th_Edition_1711955120450_0.pdf) #Coding #C++"}
    {:block/id #uuid "662708fe-4986-498b-8ed4-ec995027ba89",
     :block/properties {},
     :block/format :markdown,
     :block/children [],
     :block/content
     "![H5U&Easy系列可编程逻辑控制器编程与应用手册.PDF](../assets/H5U&Easy系列可编程逻辑控制器编程与应用手册_1713834305243_0.PDF) #Manual #inovance"}
    {:block/id #uuid "663aeb1a-c41c-42ef-8986-f73b608b3270",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "![GNU Make Manual.pdf](../assets/GNU_Make_Manual_1715137311326_0.pdf) #Coding #Linux"})}
  {:block/id #uuid "65f14810-8f7e-4122-8b91-6eb6636b2e7f",
   :block/page-name
   "hls__Industrial_Robotics_Control-Mathematical_Models,_Software_Architecture,_and_Electronics_Design_1709865527436_0",
   :block/properties
   {:file
    "[Industrial_Robotics_Control-Mathematical_Models,_Software_Architecture,_and_Electronics_Design_1709865527436_0.pdf](../assets/Industrial_Robotics_Control-Mathematical_Models,_Software_Architecture,_and_Electronics_Design_1709865527436_0.pdf)",
    :file-path
    "../assets/Industrial_Robotics_Control-Mathematical_Models,_Software_Architecture,_and_Electronics_Design_1709865527436_0.pdf"},
   :block/children
   ({:block/id #uuid "65f14810-5c08-49ba-b4ca-11a69df57822",
     :block/properties
     {:file
      "[Industrial_Robotics_Control-Mathematical_Models,_Software_Architecture,_and_Electronics_Design_1709865527436_0.pdf](../assets/Industrial_Robotics_Control-Mathematical_Models,_Software_Architecture,_and_Electronics_Design_1709865527436_0.pdf)",
      :file-path
      "../assets/Industrial_Robotics_Control-Mathematical_Models,_Software_Architecture,_and_Electronics_Design_1709865527436_0.pdf"},
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "66262385-ac83-4681-8761-accf485dea41",
   :block/page-name "文件I/O 编程",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66279316-eda9-4edf-b5fd-144a84087db3",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### 文件/文件描述符"}
    {:block/id #uuid "6627931c-624a-4bc8-bc31-ce14f4971a41",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### 文件指针/文件流"}
    {:block/id #uuid "66279326-9d33-4c57-adfe-81ba6eff0d65",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### 缓冲"}
    {:block/id #uuid "6627932b-8e9f-4543-8770-73e80c42a01d",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### 流操作"}
    {:block/id #uuid "66279331-a572-4651-b07b-ad75dafe58a5",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### 标准I/O流与操作"}
    {:block/id #uuid "6627933b-3356-4fae-aa8e-725abd5f3d79",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### ((662794a9-ec4c-4b30-8e9c-a7c11cfbc7dc))"}
    {:block/id #uuid "66279343-1244-4fb1-842a-4519baad252c",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### ((662794a0-f242-4d0d-b32c-6ed09e61dd93))"}
    {:block/id #uuid "6627934b-4056-4a1c-b6a3-f283a8c83176",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### 多路复用"})}
  {:block/id #uuid "66261dbf-9ec5-485d-b785-a4cf8658dde4",
   :block/page-name "Linux 操作系统",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66261dc1-b199-46e0-ac69-e89ebc005498",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66261dd7-6316-4ba2-a134-1c563c146c79",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 系统概念和特点"}
      {:block/id #uuid "66261dde-e872-40de-be4e-3e8dc2cd0176",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "Linux 环境安装和搭建"}
      {:block/id #uuid "66261df8-cad0-4fce-9f4a-1fe2a6a220c0",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "目录结构"}
      {:block/id #uuid "66261dfa-5b7e-4ae9-ba3e-044c26bade1c",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "基本命令和常用工具"}
      {:block/id #uuid "66261dfe-fb3a-4db4-b2ae-b7c8b676954f",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "基本网络管理"}
      {:block/id #uuid "66261e00-e754-4a62-b1cf-89eaaacb642c",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "基本系统管理"}
      {:block/id #uuid "66261e02-678c-4151-8baf-efa69c2ebcef",
       :block/properties {},
       :block/format :markdown,
       :block/children [],
       :block/content "基本Shell编程"}],
     :block/content "### Linux 系统基本使用"}
    {:block/id #uuid "66261e0e-0ee3-4d58-887b-f7113a6d0da5",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66261e32-21bb-438e-bdf7-ecde6e93e897",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66261e38-41b4-4f20-9518-b4fc0866e5e4",
         :block/properties {},
         :block/format :markdown,
         :block/children [],
         :block/content "VIM"}
        {:block/id #uuid "66261e3b-bfeb-4446-911d-39e40e86fbb2",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "Emacs"}],
       :block/content "#### 编辑"}
      {:block/id #uuid "66261e43-7564-4612-9972-66dfb2a61bc5",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66261e4f-d8bd-4d80-ac0a-0d150a58cbd8",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "66261e54-ed16-40b6-b180-072cacc72ae9",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "gcc"}],
         :block/content "编译套件"}
        {:block/id #uuid "66261e55-e09b-4643-b9bc-21080531de1d",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "66261e59-6ced-4a97-85a8-abc2ef01b914",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "make"}
          {:block/id #uuid "66261e5b-4168-4e49-832c-d9bbbf0e09dd",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "66387cdc-b704-4e41-ad56-959aff873bf5",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "https://blog.csdn.net/weixin_38391755/article/details/80380786"}],
           :block/content "makefile"}
          {:block/id #uuid "66261e5d-46c6-4069-99c8-4db7964c480e",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "cmake/autotools等"}],
         :block/content "编译工具"}
        {:block/id #uuid "66261e63-3e9b-4ca8-9f1e-20e944bc1257",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "交叉编译工具"}],
       :block/content "#### 编译"}
      {:block/id #uuid "66261e68-21f6-481d-86f4-4ce2b9778a92",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66261e6e-3075-405a-837d-51327ce75842",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "__gdb"}],
       :block/content "#### 调试"}
      {:block/id #uuid "66261e78-7f46-4b52-a26f-e3fd710f9b7a",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 运行"}],
     :block/content "### Linux平台的C/C++开发流程"}
    {:block/id #uuid "66261e93-246d-437a-9b54-d63c1f9763b7",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66262411-ffac-4847-8bbd-157efc23cfcc",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "[[系统控制]]"}
      {:block/id #uuid "66262424-cc0c-4dc4-a30d-72fb5c1e2352",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "[[内存使用和管理]]"}
      {:block/id #uuid "6626242c-bac7-4f91-ab09-c5cea3e04789",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "[[多任务编程]]"}
      {:block/id #uuid "66262436-e4b6-43cf-bf89-8346609ec481",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "[[文件I/O 编程]]"}
      {:block/id #uuid "66262444-17f1-4472-a026-0c30c7a78b25",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "[[网络编程]]"}
      {:block/id #uuid "6626244b-6870-458d-a858-f241445f6233",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "[[图形化界面编程]]"}],
     :block/content "### Linux 系统平台编程"})}
  {:block/id #uuid "66261cf6-1755-4a48-8d48-cc71ecca5f99",
   :block/page-name "计算机网络原理",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66261cf7-83fa-4c3e-9ff7-002d9b424bbe",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### TCP/IP 协议栈和分层"}
    {:block/id #uuid "66261d14-e0d7-4d92-9ecb-c909f021e99b",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### ARP 协议"}
    {:block/id #uuid "66261d1c-a7c3-41a2-bffe-2c147902ccbe",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### IP 协议/ ICMP 协议"}
    {:block/id #uuid "66261d2e-99fc-42bf-ba29-dfa01b15b3d1",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### TCP 协议/ UDP 协议"}
    {:block/id #uuid "66261d38-cff5-40fb-80d9-1ff3eb98cc49",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### DNS 协议/ HTTP 协议/ HTTPS 协议"})}
  {:block/id #uuid "662ef4f9-88a5-439b-9488-64977b685b57",
   :block/page-name "Apr 29th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "662ef4fb-d05a-41ab-b7f1-1cb5593cace9",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "88.4 kg #Weight"}
    {:block/id #uuid "662ef504-e888-45d0-bbbd-d525777e8063",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "6625fcd2-e22f-47a6-8538-8d421d6fc030",
   :block/page-name "📔TEMP",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66162733-8c98-4971-b272-a52a74e12c36",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "常量$\\mathsf{const}$问题 #？"}
    {:block/id #uuid "661658ec-7d54-4794-a9b5-700292df8668",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "常量表达式$\\mathsf{consexpr}$ #？"}
    {:block/id #uuid "66177dc2-4c4a-4b13-aed4-0f6ecc7895ee",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "补码和掩码问题 #？"}
    {:block/id #uuid "662615b0-0f06-4d8f-9850-4878ba8e5e13",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66278807-0f61-4fb3-a420-a93cf0cc4ffe",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66278ec7-4718-4b51-8e8f-532c51d94998",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "[深入浅出：Linux C编程中如何使用动态链接库_linux c 动态链接库方式-CSDN博客](https://blog.csdn.net/song_lee/article/details/104948691)"}
        {:block/id #uuid "6627880c-7d13-4102-a7e7-93bfb984b25e",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "662789b7-90e3-4daf-8b04-c4784e723a25",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content "头文件，主要是函数的一些声明"}
          {:block/id #uuid "662789c5-48fe-41e6-931d-1c123f6e4ada",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content "函数实现代码"}],
         :block/content "动态链接库是一些函数的实现，供第三方调用，从宏观角度来说，需要以下两个文件"}
        {:block/id #uuid "662789ec-b20b-42e7-8bf7-6934bec64dd2",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "66278a09-2871-4968-b02e-c0d97d35a93c",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "66278a4b-be86-4309-b57a-ee6255713153",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "头文件\n```c\n#ifndef _RANDOM_H_\n#define _RANDOM_H_\nint obtain_random(int x);\n\n#endif\n```"}
            {:block/id #uuid "66278a58-2a6b-4238-a4e0-fd8fe8e9f600",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "源文件\n```c\n#include <time.h>\n#include <stdlib.h>\n\nint obtain_random(int max)\n{\n  srand((int)time(0));\n  return rand() % max;\n}\n```"}
            {:block/id #uuid "66278acf-0b02-49c5-aee5-dbad3bebe8b1",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "编译生成动态链接库\n```LINUX\ngcc -shared -fPIC random.c -o librandom.so\n```\n$\\mathsf{shared}$参数：生成动态链接库；\n$\\mathsf{fPIC}$参数：产生与位置无关的代码。"}],
           :block/content "动态链接库的生成：以一个生成随机数的函数为例"}
          {:block/id #uuid "66278b73-ecc6-4855-baca-fd4c19c7376a",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "66278b78-e763-4694-9b26-ac145a385944",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "调用库中函数\n```c\n#include <stdio.h.\n#include \"random.h\"\n\nint main(int argc, char const *argv[])\n{\n  printf(\"%d\\n\", obtain_random(100));\n  return 0;\n}\n```"}
            {:block/id #uuid "66278bd2-e4bf-4eb0-ad1f-65c3650111e4",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "编译和链接\n```LINUX\ngcc test.c -L ./ -l random -o test\n```\n$\\mathsf{L}$参数：库文件路径；\n$\\mathsf{l}$参数：要链接的库，库的名称去头尾"}
            {:block/id #uuid "66278e91-0843-4aee-a55d-4a79747b6ed6",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "运行\n```linux\nLD_LIBRARY_PATH = ./ ./test\n```\n指定动态链接库的路径"}
            {:block/id #uuid "66278c2b-a8e2-4169-abeb-a0d9ca34dade",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content ""}],
           :block/content "使用动态链接库"}],
         :block/content "动态链接库的生成和使用"}],
       :block/content "动态链接库"}
      {:block/id #uuid "66387e8f-f629-4b72-b907-8449dfb91aee",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66387e93-b8fa-460b-a076-6033d44c2776",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "**\n****makefile很重要**\n\n      什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，**会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力**。因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按**类型、功能、模块**分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。\n\n      现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。\n\n    在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。\n\n**0.1 关于程序的编译和链接**\n\n   在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成**中间代码文件**，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做**编译（compile）**。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。   \n     \n       **编译时**，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。 \n       **链接时**，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“**库文件”（Library File)**，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。\n\n      总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的ObjectFile.\n       \n       好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。"}
        {:block/id #uuid "66387e93-55a9-4f8e-a7b9-9cf4ff887015",
         :block/properties {:heading 2},
         :block/format :markdown,
         :block/children [],
         :block/content
         "##  **1 Makefile 介绍**\n\n    make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。\n\n    首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：\n\n       \n          1.如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。\n\n          2.如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。\n\n          3.如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。\n\n    只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。"}
        {:block/id #uuid "66387e93-19f9-4a1d-b6dc-c1220513e6c2",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **1.1 Makefile的规则**\n\n 在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。\n\n       ** target... : prerequisites ...**\n\n**          command**\n\n**          ...**\n\n**          ...\n       -------------------------------------------------------------------------------**\n\n    ** target**也就是一个目标文件，可以是**Object File**，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。\n\n**       prerequisites**就是，要生成那个target所需要的文件或是目标。\n\n**       command**也就是make需要执行的命令。（任意的Shell命令）\n\n     这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。\n\n     说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）\n\n    【注】：在看别人写的Makefile文件时，你可能会碰到以下三个变量：$@，$^，$<代表的意义分别是： \n\n                 他们三个是十分重要的三个变量，所代表的含义分别是：\n\n                 $@--目标文件，$^--所有的依赖文件，$<--第一个依赖文件。"}
        {:block/id #uuid "66387e93-4eac-4a7e-8fba-5bf9763f779e",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **1.2 一个示例**\n\n正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。\n\n edit : main.o kbd.o command.o display.o \\\n\n        insert.o search.o files.o utils.o\n\n         cc -o edit main.o kbd.o command.o display.o \\\n\n                    insert.o search.o files.o utils.o\n\n\n\n main.o : main.c defs.h\n\n         cc -c main.c\n\n kbd.o : kbd.c defs.h command.h\n\n         cc -c kbd.c\n\n command.o : command.c defs.h command.h\n\n         cc -c command.c\n\n display.o : display.c defs.h buffer.h\n\n         cc -c display.c\n\n insert.o : insert.c defs.h buffer.h\n\n         cc -c insert.c\n\n search.o : search.c defs.h buffer.h\n\n         cc -c search.c\n\n files.o : files.c defs.h buffer.h command.h\n\n         cc -c files.c\n\n utils.o : utils.c defs.h\n\n         cc -c utils.c\n\n clean :\n\n         rm edit main.o kbd.o command.o display.o \\\n\n            insert.o search.o files.o utils.o\n\n    **  反斜杠（\\）**是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。\n\n      在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。\n\n      在定义好依赖关系后，后续的那一行定义了如何生成目标文件的**操作系统命令**，一定要以一个**Tab键作为开头**。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。\n\n      这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。"}
        {:block/id #uuid "66387e93-1064-4cac-9cbd-ae0eacd99dbd",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **1.3 make是如何工作的**\n\n在默认的方式下，也就是我们只输入make命令。那么，"}
        {:block/id #uuid "66387e93-6da9-41f8-80b4-3e3d6b894873",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "  make会在当前目录下找名字叫“Makefile”或“makefile”的文件。"}
        {:block/id #uuid "66387e93-78ee-480d-928a-1971ae81b82c",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "  如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。"}
        {:block/id #uuid "66387e93-50b2-4141-b2c7-5d746c9300a3",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "  如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。"}
        {:block/id #uuid "66387e93-2cce-4544-9970-bbe2b9b61aab",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "  如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）"}
        {:block/id #uuid "66387e93-7b61-4659-a2a5-bf9273915d23",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "  当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件声明make的终极任务，也就是执行文件edit了。\n\n```\n这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。\n```\n\n      通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——**“make clean”，以此来清除所有的目标文件，以便重编译**。\n\n    于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。\n\n而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。"}
        {:block/id #uuid "66387e93-9396-4ab5-8ac8-b410e4595e36",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **1.4 makefile中使用变量**\n\n在上面的例子中，先让我们看看edit的规则：\n\n   edit : main.o kbd.o command.o display.o \\\n\n               insert.o search.o files.o utils.o\n\n         cc -o edit main.o kbd.o command.o display.o \\\n\n                    insert.o search.o files.o utils.o\n\n  我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。\n\n比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：\n\n  objects = main.o kbd.o command.o display.o \\\n\n           insert.o search.o files.o utils.o\n\n于是，我们就可以很方便地在我们的makefile中以**“$(objects)”**的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：\n\n```\nobjects = main.o kbd.o command.o display.o \\\n           insert.osearch.o files.o utils.o \n edit : $(objects)\n         cc -o edit $(objects)\n main.o : main.c defs.h\n         cc -c main.c\n kbd.o : kbd.c defs.h command.h\n         cc -c kbd.c\n command.o : command.c defs.h command.h\n         cc -c command.c\n display.o : display.c defs.h buffer.h\n         cc -c display.c\n insert.o : insert.c defs.h buffer.h\n         cc -c insert.c\n search.o : search.c defs.h buffer.h\n         cc -c search.c\n files.o : files.c defs.h buffer.h command.h\n         cc -c files.c\n utils.o : utils.c defs.h\n         cc -c utils.c\n clean :\n         rm edit $(objects)\n```\n\n于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。\n\n关于变量更多的话题，我会在后续给你一一道来。"}
        {:block/id #uuid "66387e93-8538-4f82-99f4-c725e6c334c6",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **1.5 让make自动推导**\n\nGNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。\n\n  只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。\n\n```\nobjects = main.o kbd.o command.o display.o \\\n           insert.o search.o files.o utils.o\n\n edit : $(objects)\n         cc -o edit $(objects)\n\n main.o : defs.h\n kbd.o : defs.h command.h\n command.o : defs.h command.h\n display.o : defs.h buffer.h\n insert.o : defs.h buffer.h\n search.o : defs.h buffer.h\n files.o : defs.h buffer.h command.h\n utils.o : defs.h\n\n .PHONY : clean\n clean :\n         rm edit $(objects)\n```\n\n这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。\n\n关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。"}
        {:block/id #uuid "66387e93-4428-40c3-b3e6-f92dc4e85937",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **1.6 另类风格的makefile**\n\n  即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。\n\n```\nobjects = main.o kbd.o command.o display.o \\\n           insert.o search.o files.o utils.o\n\n edit : $(objects)\n         cc -o edit $(objects)\n\n $(objects) : defs.h\n kbd.o command.o files.o : command.h\n display.o insert.o search.o files.o : buffer.h\n\n .PHONY : clean\n clean :\n         rm edit $(objects)\n```\n\n这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。"}
        {:block/id #uuid "66387e93-abcf-47cd-8bdc-afc2cdc7f213",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **1.7 清空目标文件的规则**\n\n    每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：\n\n     clean:\n\n         rm edit $(objects)\n\n更为稳健的做法是：\n\n     .PHONY : clean\n\n     clean :\n\n             -rm edit $(objects)\n\n前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。\n\n上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。"}
        {:block/id #uuid "66387e93-6688-4022-8d52-b4d0588f8325",
         :block/properties {:heading 2},
         :block/format :markdown,
         :block/children [],
         :block/content "##  **2 Makefile 总述**"}
        {:block/id #uuid "66387e93-d3f8-4003-9147-d4502bf9666a",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **2.1 Makefile里有什么？**\n\nMakefile里主要包含了**五****个东西****：显式规则、隐晦规则、变量定义、文件指示和注释。**\n\n> "}
        {:block/id #uuid "66387e93-619f-49af-b688-7641a0ce8667",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。"}
        {:block/id #uuid "66387e93-b70d-4d1a-a6d1-1c18db52a9e4",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。"}
        {:block/id #uuid "66387e93-7a91-40b3-8aa8-e526f9f16c7a",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。"}
        {:block/id #uuid "66387e93-5211-4b42-a2c4-77f46bdb19c1",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。"}
        {:block/id #uuid "66387e93-f462-4474-92d9-f0fdae0e0ea2",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         " 注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“\\#”。\n\n最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。"}
        {:block/id #uuid "66387e93-7220-40a2-9637-e1447a744e8c",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **2.2Makefile的文件名**\n\n      默认的情况下，make命令会在当前目录下按顺序找寻文件名为**“GNUmakefile”、“makefile”、“Makefile”**的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“**makefile”和“Makefile”**这两种默认文件名。\n\n   当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要**指定特定的Makefile，你可以使用make的“-f”和“--file”参数**，如：make -f Make.Linux或make --file Make.AIX。"}
        {:block/id #uuid "66387e93-3f29-406c-942b-3210f09c21dc",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **2.3 引用其它的Makefile**\n\n  在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：\n\n```\n**  **  include<filename>****filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）\n```\n\n**在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。**举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：\n\n include foo.make *.mk $(bar)\n\n等价于：\n\n include foo.make a.mk b.mk c.mk e.mk f.mk\n\nmake命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：\n\n> \n\n```\n1.如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。\n```\n\n```\n2.如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。\n```\n\n    如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：\n\n-include<filename>\n\n其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。"}
        {:block/id #uuid "66387e93-3a6c-4cb5-a80a-21ec643bf555",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **2.4 环境变量 MAKEFILES**\n\n如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。\n\n但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。"}
        {:block/id #uuid "66387e93-f6de-44bd-9b29-e0e4cfba7a91",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **2.5 make的工作方式**\n\n**GNU的make工作时的执行步骤入下：（想来其它的make也是类似）**\n\n> \n\n1.        读入所有的Makefile。\n\n2.        读入被include的其它Makefile。\n\n3.        初始化文件中的变量。\n\n4.        推导隐晦规则，并分析所有规则。\n\n5.        为所有的目标文件创建依赖关系链。\n\n6.        根据依赖关系，决定哪些目标要重新生成。\n\n7.        执行生成命令。\n\n1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。\n\n当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。"}
        {:block/id #uuid "66387e93-1332-4567-a317-f9d484a1e682",
         :block/properties {:heading 2},
         :block/format :markdown,
         :block/children [],
         :block/content
         "##  **3 Makefile书写规则**\n\n规则包含两个部分，一个是**依赖关系**，一个是**生成目标的方法**。\n\n**在Makefile中，规则的顺序是很重要的**，因为，**Makefile中只应该有一个最终目标**，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。\n\n好了，还是让我们来看一看如何书写规则。"}
        {:block/id #uuid "66387e93-cc63-4a42-84e8-85b07264e3c9",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **3.1 规则举例**\n\nfoo.o: foo.c defs.h       # foo模块\n\n         cc -c -g foo.c\n\n看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令“cc -c -g foo.c”（以Tab键开头）。这个规则告诉我们两件事：\n\n> \n\n1.        文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。\n\n2.        如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）"}
        {:block/id #uuid "66387e93-a827-4b4c-9040-4965842007a4",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **3.2 规则的语法**\n\n   targets : prerequisites\n\n     command\n\n     ...\n\n或是这样：\n\n   targets : prerequisites ; command\n\n         command\n\n         ...\n\ntargets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。\n\ncommand是命令行，如果其不与“target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）\n\nprerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。\n\n如果命令太长，你可以使用反斜框（‘\\’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。\n\n一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。"}
        {:block/id #uuid "66387e93-2d8b-4711-bfe4-3fd1cad3a48a",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **3.3 在规则中使用通配符**\n\n   如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：“*”，“?”和“[...]”。这是和Unix的B-Shell是相同的。\n\n**\"~\"**\n\n波浪号（“~”）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen/test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。\n\n**\"*\"**\n通配符代替了你一系列的文件，如“*.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“*”，那么可以用转义字符“\\”，如“\\*”来表示真实的“*”字符，而不是任意长度的字符串。\n\n好吧，还是先来看几个例子吧：\n\n clean:\n\n      rm -f *.o\n\n上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。\n\n print: *.c\n\n      lpr -p $?\n\n      touch print\n\n上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量，我会在后面给你讲述。\n\n objects = *.o\n\n上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开，不！objects的值就是“*.o”。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：\n\n objects := $(wildcard *.o)\n\n这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。"}
        {:block/id #uuid "66387e93-004f-4444-bb6f-b434132bc08d",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **3.4 文件搜寻**\n\n   在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。\n\nMakefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。\n\n VPATH = src:../headers\n\n上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）\n\n另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：\n\n> \n\n1.        vpath < pattern> < directories>    为符合模式< pattern>的文件指定搜索目录<directories>。\n\n2.        vpath < pattern>                              清除符合模式< pattern>的文件的搜索目录。\n\n3.        vpath                                                 清除所有已被设置好了的文件搜索目录。\n\nvapth使用方法中的< pattern>需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。< pattern>指定了要搜索的文件集，而< directories>则指定了的文件集的搜索的目录。例如：\n\n vpath %.h ../headers\n\n该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）\n\n我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的< pattern>，或是被重复了的< pattern>，那么，make会按照vpath语句的先后顺序来执行搜索。如：\n\n vpath %.c foo\n\n vpath %   blish\n\n vpath %.c bar\n\n其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。\n\n vpath %.c foo:bar\n\n vpath %   blish\n\n而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。"}
        {:block/id #uuid "66387e93-f582-492a-9301-61d78522c5eb",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **3.5 伪目标**\n\n最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，\n\n clean:\n\n         rm *.o temp\n\n正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）\n\n因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。\n\n当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。\n\n .PHONY : clean\n\n只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：\n\n  .PHONY: clean\n\n clean:\n\n         rm *.o temp\n\n伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：\n\n all : prog1 prog2 prog3\n\n .PHONY : all\n\n\n\n prog1 : prog1.o utils.o\n\n         cc -o prog1 prog1.o utils.o\n\n\n\n prog2 : prog2.o\n\n         cc -o prog2 prog2.o\n\n\n\n prog3 : prog3.o sort.o utils.o\n\n         cc -o prog3 prog3.o sort.o utils.o\n\n我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。\n\n随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：\n\n .PHONY: cleanall cleanobj cleandiff\n\n\n\n cleanall : cleanobj cleandiff\n\n         rm program\n\n\n\n cleanobj :\n\n         rm *.o\n\n\n\n cleandiff :\n\n         rm *.diff\n\n“makeclean”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“makecleanall”和“make cleanobj”和“makecleandiff”命令来达到清除不同种类文件的目的"}
        {:block/id #uuid "66387e93-622f-4cc5-9248-7d30f8ddbfc4",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **3.6 多目标**\n\nMakefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。\n\n bigoutput littleoutput : text.g\n\n         generate text.g -$(subst output,,$@) > $@\n\n 上述规则等价于：\n\n\n\n bigoutput : text.g\n\n         generate text.g -big > bigoutput\n\n littleoutput : text.g\n\n         generate text.g -little > littleoutput\n\n其中，-$(subst output,,$@)中的“$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。"}
        {:block/id #uuid "66387e93-84ba-4d60-90f2-fa741cd92adb",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **3.7 静态模式**\n\n静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：\n\n<targets...>: <target-pattern>: <prereq-patterns ...>\n\n　<commands>\n\n...\n\ntargets定义了一系列的目标文件，可以有通配符。是目标的一个集合。\n\ntarget-parrtern是指明了targets的模式，也就是的目标集模式。\n\nprereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。\n\n这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的<target-parrtern>定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，而如果我们的<prereq-parrterns>定义成“%.c”，意思是对<target-parrtern>所形成的目标集进行二次定义，其计算方法是，取<target-parrtern>模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。\n\n所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\\”进行转义，来标明真实的“%”字符。\n\n看一个例子：\n\n objects = foo.o bar.o\n\n\n\n all: $(objects)\n\n\n\n $(objects): %.o: %.c\n\n         $(CC) -c $(CFLAGS) $< -o $@\n\n\n\n上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.cbar.c”。而命令中的“$<”和“$@”则是自动化变量，“$<”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也褪恰癴oo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：\n\n foo.o : foo.c\n\n         $(CC) -c $(CFLAGS) foo.c -o foo.o\n\n bar.o : bar.c\n\n         $(CC) -c $(CFLAGS) bar.c -o bar.o\n\n试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：\n\n\n\n files = foo.elc bar.o lose.o\n\n\n\n $(filter %.o,$(files)): %.o: %.c\n\n         $(CC) -c $(CFLAGS) $< -o $@\n\n $(filter %.elc,$(files)): %.elc: %.el\n\n         emacs -f batch-byte-compile $<\n\n$(filter%.o,$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。"}
        {:block/id #uuid "66387e93-9764-499d-ae94-66b445fb1ec0",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **3.8 自动生成依赖性**\n\n在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include \"defs.h\"”，那么我们的依赖关系应该是：\n\n main.o : main.c defs.h\n\n但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：\n\n cc -M main.c\n\n其输出是：\n\n main.o : main.c defs.h\n\n于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。\n\ngcc-M main.c的输出是：\n\n main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \\\n\n      /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \\\n\n      /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \\\n\n      /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \\\n\n      /usr/include/bits/sched.h /usr/include/libio.h \\\n\n      /usr/include/_G_config.h /usr/include/wchar.h \\\n\n      /usr/include/bits/wchar.h /usr/include/gconv.h \\\n\n      /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \\\n\n      /usr/include/bits/stdio_lim.h\n\n\n\ngcc-MM main.c的输出则是：\n\n main.o: main.c defs.h\n\n那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。\n\n于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。\n\n这里，我们给出了一个模式规则来产生[.d]文件：\n\n %.d: %.c\n\n         @set -e; rm -f $@; \\\n\n          $(CC) -M $(CPPFLAGS) $< > $@.\n\n; \\\n\n          sed 's,\n\n\\.o[ :]*,\\1.o $@ : ,g' < $@.\n\n> $@; \\\n\n          rm -f $@.\n\n这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm-f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$<”，也就是[.c]文件生成依赖文件，“$@”表示模式“%.d”文件，如果有一个C文件是name.c，那么“%”就是“name”，“\n\n”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。\n\n总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：\n\n main.o : main.c defs.h\n\n转成：\n\n main.o main.d : main.c defs.h\n\n于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：\n\n sources = foo.c bar.c\n\n\n\n include $(sources:.c=.d)\n\n上述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标"}
        {:block/id #uuid "66387e93-2702-4f35-9246-532b07cab86d",
         :block/properties {:heading 2},
         :block/format :markdown,
         :block/children [],
         :block/content
         "##  **4 Makefile 书写命令**\n\n    每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。\n\n我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。"}
        {:block/id #uuid "66387e93-9ff2-40f5-afe1-3167952a658a",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **4.1 显示命令**\n\n通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：\n\n @echo 正在编译XXX模块......\n\n当make执行时，会输出“正在编译XXX模块......”字串，但不会输出命令，如果没有“@”，那么，make将输出：\n\n echo 正在编译XXX模块......\n\n 正在编译XXX模块......\n\n如果make执行时，带入make参数“-n”或“--just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。\n\n而make参数“-s”或“--slient”则是全面禁止命令的显示。"}
        {:block/id #uuid "66387e93-08de-4865-8f7e-82c09f7053bd",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **4.2 命令执行**\n\n当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：\n\n 示例一：\n\n     exec:\n\n             cd /home/hchen\n\n             pwd\n\n\n\n 示例二：\n\n     exec:\n\n             cd /home/hchen; pwd\n\n当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。\n\nmake一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。"}
        {:block/id #uuid "66387e93-517f-4ad3-bf7f-d4e27e375c60",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **4.3 命令出错**\n\n    每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。\n\n有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。\n\n为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：\n\nclean:\n\n         -rm -f *.o\n\n还有一个全局的办法是，给make加上“-i”或是“--ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。\n\n还有一个要提一下的make的参数的是“-k”或是“--keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。"}
        {:block/id #uuid "66387e93-179d-40ff-9f3b-5e7a37cc27c0",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **4.4 嵌套执行make**\n\n     在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。\n    例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：\n\n subsystem:\n\n         cd subdir && $(MAKE)\n\n其等价于：\n\n  subsystem:\n\n         $(MAKE) -C subdir\n\n定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。\n\n我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。\n\n如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：\n\nexport<variable ...>\n\n如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：\n\nunexport<variable ...>\n\n如：\n\n    示例一：\n\n      export variable = value\n\n    \n其等价于：\n\n      variable = value\n\n      export variable\n\n\n\n     其等价于：\n\n      export variable := value\n\n      其等价于：\n\n\n\n     variable := value\n\n     export variable\n\n\n\n 示例二：\n\n\n\n     export variable += value\n\n\n\n     其等价于：\n\n\n\n     variable += value\n\n     export variable\n\n   如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。\n\n需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。\n\n但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：\n\n \n\n subsystem:\n\n         cd subdir && $(MAKE) MAKEFLAGS=\n\n如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。\n\n还有一个在“嵌套执行”中比较有用的参数，“-w”或是“--print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：\n\n    make: Entering directory `/home/hchen/gnu/make'.\n\n而在完成下层make后离开目录时，我们会看到：   \n\n make: Leaving directory `/home/hchen/gnu/make'\n\n当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“--slient”）或是“--no-print-directory”，那么，“-w”总是失效的。"}
        {:block/id #uuid "66387e93-1eef-4a89-9fb8-a4e7cf46cef2",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **4.5 定义命令包**\n\n如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：\n\n define run-yacc\n\n yacc $(firstword $^)\n\n mv y.tab.c $@\n\n endef\n\n这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。\n\n foo.c : foo.y\n\n         $(run-yacc)\n\n我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$^”就是“foo.y”，“$@”就是“foo.c”（有关这种以“$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。"}
        {:block/id #uuid "66387e93-377d-4173-8185-0da5ec23e827",
         :block/properties {:heading 2},
         :block/format :markdown,
         :block/children [],
         :block/content
         "##  ** 使用变量**\n————\n\n     在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。有一些变量是很奇怪字串，如“$<”、“$@”等，这些是自动化变量，我会在后面介绍。"}
        {:block/id #uuid "66387e93-9988-4fca-b14e-84167c569929",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  一、变量的基础\n\n  变量在声明时需要给予初值，而在使用时，需要给在变量名前 **加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来**。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。\n\n先看一个例子：\n\nobjects = program.o foo.o utils.o\nprogram : $(objects)\ncc -o program $(objects)\n\n$(objects) : defs.h\n\n变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：\n\nfoo = c\nprog.o : prog.$(foo)\n$(foo)$(foo) -$(foo) prog.$(foo)\n\n展开后得到：\n\nprog.o : prog.c\ncc -c prog.c\n\n当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。"}
        {:block/id #uuid "66387e93-959d-4107-9a06-9bf9760aede6",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **二、变量中的变量**\n\n在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。\n\n先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好\n的值，其也可以使用后面定义的值。如：\n\nfoo = $(bar)\nbar = $(ugh)\nugh = Huh?\n\nall:\necho $(foo)\n\n我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。\n这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：\n\nCFLAGS = $(include_dirs) -O\ninclude_dirs = -Ifoo -Ibar\n\n当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方\n，那就是递归定义，如：\n\nCFLAGS = $(CFLAGS) -O\n\n或：\n\nA = $(B)\nB = $(A)\n\n这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。\n\n为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：\n\nx := foo\ny := $(x) bar\nx := later\n\n其等价于：\n\ny := foo bar\nx := later\n\n值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：\n\ny := $(x) bar\nx := foo\n\n那么，y的值是“bar”，而不是“foo bar”。\n\n上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：\n\nifeq (0,${MAKELEVEL})\ncur-dir := $(shell pwd)\nwhoami := $(shell whoami)\nhost-type := $(shell arch)\nMAKE := ${MAKE} host-type=${host-type} whoami=${whoami}\nendif\n\n关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。\n\n下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：\n\nnullstring :=\nspace := $(nullstring) # end of the line\n\nnullstring 是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：\n\ndir := /foo/bar # directory to put the frobs in\n\ndir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。\n\n还有一个比较有用的操作符是“?=”，先看示例：\n\nFOO ?= bar\n\n其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：\n\nifeq ($(origin FOO), undefined)\nFOO = bar\nendif"}
        {:block/id #uuid "66387e93-7623-4370-a132-db1824cb1d80",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **三、变量高级用法**\n\n这里介绍两种变量的高级使用方法，第一种是变量值的替换。\n\n我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。\n\n还是看一个示例吧：\n\nfoo := a.o b.o c.o\nbar := $(foo:.o=.c)\n\n这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。\n\n另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：\n\nfoo := a.o b.o c.o\nbar := $(foo:%.o=%.c)\n\n这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。\n\n第二种高级用法是——“把变量的值再当成变量”。先看一个例子：\n\nx = y\ny = z\na := $($(x))\n\n在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）\n\n我们还可以使用更多的层次：\n\nx = y\ny = z\nz = u\na := $($($(x)))\n\n这里的$(a)的值是“u”，相关的推导留给读者自己去做吧。\n\n让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：\n\nx = $(y)\ny = z\nz = Hello\na := $($(x))\n\n这里的$($(x))被替换成了$($(y))，因为$(y)值是“z”，所以，最终结果是：a:=$(z)，也就是“Hello”。\n\n再复杂一点，我们再加上函数：\n\nx = variable1\nvariable2 := Hello\ny = $(subst 1,2,$(x))\nz = y\na := $($($(z)))\n\n这个例子中，“$($($(z)))”扩展为“$($(y))”，而其再次被扩展为“$($(subst 1,2,$(x)))”。$(x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值—— “Hello”。（喔，好不容易）\n\n在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：\n\nfirst_second = Hello\na = first\nb = second\nall = $($a_$b)\n\n这里的“$a_$b”组成了“first_second”，于是，$(all)的值就是“Hello”。\n\n再来看看结合第一种技术的例子：\n\na_objects := a.o b.o c.o\n1_objects := 1.o 2.o 3.o\n\nsources := $($(a1)_objects:.o=.c)\n\n这个例子中，如果$(a1)的值是“a”的话，那么，$(sources)的值就是“a.c b.c c.c”；如果$(a1)的值是“1”，那么$(sources)的值是“1.c 2.c 3.c”。\n\n再来看一个这种技术和“函数”与“条件语句”一同使用的例子：\n\nifdef do_sort\nfunc := sort\nelse\nfunc := strip\nendif\n\nbar := a d b g q c\n\nfoo := $($(func) $(bar))\n\n这个示例中，如果定义了“do_sort”，那么：foo := $(sort a d b g q c)，于是$(foo)的值就是“a b c d g q”，而如果没有定义“do_sort”，那么：foo := $(sort a d bg q c)，调用的就是strip函数。\n\n当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边：\n\ndir = foo\n$(dir)_sources := $(wildcard $(dir)/*.c)\ndefine $(dir)_print\nlpr $($(dir)_sources)\nendef\n\n这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。\n\n**\n**###  **四、追加变量值**\n\n我们可以使用“+=”操作符给变量追加值，如：\n\nobjects = main.o foo.o bar.o utils.o\nobjects += another.o\n\n于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）\n\n使用“+=”操作符，可以模拟为下面的这种例子：\n\nobjects = main.o foo.o bar.o utils.o\nobjects := $(objects) another.o\n\n所不同的是，用“+=”更为简洁。\n\n如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：\n\nvariable := value\nvariable += more\n\n等价于：\n\nvariable := value\nvariable := $(variable) more\n\n但如果是这种情况：\n\nvariable = value\nvariable += more\n\n由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。"}
        {:block/id #uuid "66387e93-7933-4b99-8a41-e3de0efc9a1c",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **五、override 指示符**\n\n如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：\n\noverride <variable> = <value>\noverride <variable> := <value>\n\n当然，你还可以追加：\n\noverride <variable> += <more text>\n\n对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：\n\noverride define foo\nbar\nendef"}
        {:block/id #uuid "66387e93-0509-4799-90ad-fb2b360e3ba8",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **六、多行变量**\n\n还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。\n\ndefine 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。\n\n下面的这个示例展示了define的用法：\n\ndefine two-lines\necho foo\necho $(bar)\nendef"}
        {:block/id #uuid "66387e93-3766-4fa7-9efd-25a3656e515a",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **七、环境变量**\n\nmake 运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）\n\n因此，如果我们在环境变量中设置了“CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。     当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层 Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）\n\n 当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。\n\n**\n**###  **八、目标变量**\n\n前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$<”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。\n\n当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。\n\n其语法是：\n\n<target ...> : <variable-assignment>\n\n<target ...> : overide <variable-assignment>\n\n<variable-assignment>可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。\n\n这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：\n\nprog : CFLAGS = -g\nprog : prog.o foo.o bar.o\n$(CC) $(CFLAGS) prog.o foo.o bar.o\n\nprog.o : prog.c\n$(CC) $(CFLAGS) prog.c\n\nfoo.o : foo.c\n$(CC) $(CFLAGS) foo.c\n\nbar.o : bar.c\n$(CC) $(CFLAGS) bar.c\n\n在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g”"}
        {:block/id #uuid "66387e93-662d-4d45-a129-5a5dc1afebaa",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **九、模式变量**\n\n在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。\n\n我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：\n\n%.o : CFLAGS = -O\n\n同样，模式变量的语法和“目标变量”一样：\n\n<pattern ...> : <variable-assignment>\n\n<pattern ...> : override <variable-assignment>\n\noverride同样是针对于系统环境传入的变量，或是make命令行指定的变量。\n\n使用条件判断\n——————\n\n使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。\n\n一、示例\n\n下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。\n\nlibs_for_gcc = -lgnu\nnormal_libs =\n\nfoo: $(objects)\nifeq ($(CC),gcc)\n$(CC) -o foo $(objects) $(libs_for_gcc)\nelse\n$(CC) -o foo $(objects) $(normal_libs)\nendif\n\n可见，在上面示例的这个规则中，目标“foo”可以根据变量“$(CC)”值来选取不同的函数库来编译程序。\n\n我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。\n\n当我们的变量$(CC)值是“gcc”时，目标foo的规则是：\n\nfoo: $(objects)\n$(CC) -o foo $(objects) $(libs_for_gcc)\n\n而当我们的变量$(CC)值不是“gcc”时（比如“cc”），目标foo的规则是：\n\nfoo: $(objects)\n$(CC) -o foo $(objects) $(normal_libs)\n\n当然，我们还可以把上面的那个例子写得更简洁一些：\n\nlibs_for_gcc = -lgnu\nnormal_libs =\n\nifeq ($(CC),gcc)\nlibs=$(libs_for_gcc)\nelse\nlibs=$(normal_libs)\nendif\n\nfoo: $(objects)\n$(CC) -o foo $(objects) $(libs)\n\n二、语法\n\n条件表达式的语法为：\n\n<conditional-directive>\n<text-if-true>\nendif\n\n以及：\n\n<conditional-directive>\n<text-if-true>\nelse\n<text-if-false>\nendif\n\n其中<conditional-directive>表示条件关键字，如“ifeq”。这个关键字有四个。\n\n第一个是我们前面所见过的“ifeq”\n\nifeq (<arg1>, <arg2> )\nifeq '<arg1>' '<arg2>'\nifeq \"<arg1>\" \"<arg2>\"\nifeq \"<arg1>\" '<arg2>'\nifeq '<arg1>' \"<arg2>\"\n\n比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：\n\nifeq ($(strip $(foo)),)\n<text-if-empty>\nendif\n\n这个示例中使用了“strip”函数，如果这个函数的返回值是空（Empty），那么<text-if-empty>就生效。\n\n第二个条件关键字是“ifneq”。语法是：\n\nifneq (<arg1>, <arg2> )\nifneq '<arg1>' '<arg2>'\nifneq \"<arg1>\" \"<arg2>\"\nifneq \"<arg1>\" '<arg2>'\nifneq '<arg1>' \"<arg2>\"\n\n其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。\n\n第三个条件关键字是“ifdef”。语法是：\n\nifdef <variable-name>\n\n如果变量<variable-name>的值非空，那到表达式为真。否则，表达式为假。当然，<variable-name>同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：\n\n示例一：\nbar =\nfoo = $(bar)\nifdef foo\nfrobozz = yes\nelse\nfrobozz = no\nendif\n\n示例二：\nfoo =\nifdef foo\nfrobozz = yes\nelse\nfrobozz = no\nendif\n\n第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。\n\n第四个条件关键字是“ifndef”。其语法是：\n\nifndef <variable-name>\n\n这个我就不多说了，和“ifdef”是相反的意思。\n\n在<conditional-directive>这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也\n一样，只要不是以[Tab]键开始就行了。\n\n特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。\n\n而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。"}
        {:block/id #uuid "66387e93-c63d-43a7-9fff-54b7ce0c2145",
         :block/properties {:heading 2},
         :block/format :markdown,
         :block/children [],
         :block/content
         "##  **使用函数**\n**————**\n\n在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。"}
        {:block/id #uuid "66387e93-2c1e-4fa6-81f9-b7fb8faa5903",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  一、函数的调用语法\n\n函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：\n\n$(<function> <arguments> )\n\n或是\n\n${<function> <arguments>}\n\n这里，<function>就是函数名，make支持的函数不多。<arguments>是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。\n\n还是来看一个示例：\n\ncomma:= ,\nempty:=\nspace:= $(empty) $(empty)\nfoo:= a b c\nbar:= $(subst $(space),$(comma),$(foo))\n\n在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是“a b c”，$(bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是“\na,b,c”。\n**\n**###  **二、字符串处理函数**\n\n$(subst <from>,<to>,<text> )\n\n名称：字符串替换函数——subst。\n功能：把字串<text>中的<from>字符串替换成<to>。\n返回：函数返回被替换过后的字符串。\n\n示例：\n\n$(subst ee,EE,feet on the street)，\n\n把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt\n”。\n\n$(patsubst <pattern>,<replacement>,<text> )\n\n名称：模式字符串替换函数——patsubst。\n功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符“%”，表示任意长度的字串。如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。（可以用“\\”来转义，以“\\%”来表示真实含义的“%”字符）返回：函数返回被替换过后的字符串。\n\n示例：\n\n$(patsubst %.c,%.o,x.c.c bar.c)\n\n把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”\n\n备注：\n\n这和我们前面“变量章节”说过的相关知识有点相似。如：\n\n“$(var:<pattern>=<replacement> )”\n相当于\n“$(patsubst <pattern>,<replacement>,$(var))”，\n\n而“$(var: <suffix>=<replacement> )”\n则相当于\n“$(patsubst %<suffix>,%<replacement>,$(var))”。\n\n例如有：objects = foo.o bar.o baz.o，\n那么，“$(objects:.o=.c)”和“$(patsubst %.o,%.c,$(objects))”是一样的。\n\n$(strip <string> )\n\n名称：去空格函数——strip。\n功能：去掉<string>字串中开头和结尾的空字符。\n返回：返回被去掉空格的字符串值。\n示例：\n\n$(strip a b c )\n\n把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。\n\n$(findstring <find>,<in> )\n\n名称：查找字符串函数——findstring。\n功能：在字串<in>中查找<find>字串。\n返回：如果找到，那么返回<find>，否则返回空字符串。\n示例：\n\n$(findstring a,a b c)\n$(findstring a,b c)\n\n第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）\n\n$(filter <pattern...>,<text> )\n\n名称：过滤函数——filter。\n功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可\n以有多个模式。\n返回：返回符合模式<pattern>的字串。\n示例：\n\nsources := foo.c bar.c baz.s ugh.h\nfoo: $(sources)\ncc $(filter %.c %.s,$(sources)) -o foo\n\n$(filter %.c %.s,$(sources))返回的值是“foo.c bar.c baz.s”。\n\n$(filter-out <pattern...>,<text> )\n\n名称：反过滤函数——filter-out。\n功能：以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可\n以有多个模式。\n返回：返回不符合模式<pattern>的字串。\n示例：\n\nobjects=main1.o foo.o main2.o bar.o\nmains=main1.o main2.o\n\n$(filter-out $(mains),$(objects)) 返回值是“foo.o bar.o”。\n\n$(sort <list> )\n\n名称：排序函数——sort。\n功能：给字符串<list>中的单词排序（升序）。\n返回：返回排序后的字符串。\n示例：$(sort foo bar lose)返回“bar foo lose” 。\n备注：sort函数会去掉<list>中相同的单词。\n\n$(word <n>,<text> )\n\n名称：取单词函数——word。\n功能：取字符串<text>中第<n>个单词。（从一开始）\n返回：返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大，那么返回空\n字符串。\n示例：$(word 2, foo bar baz)返回值是“bar”。\n\n$(wordlist <s>,<e>,<text> )\n\n名称：取单词串函数——wordlist。\n功能：从字符串<text>中取从<s>开始到<e>的单词串。<s>和<e>是一个数字。\n返回：返回字符串<text>中从<s>到<e>的单词字串。如果<s>比<text>中的单词数要大，那\n么返回空字符串。如果<e>大于<text>的单词数，那么返回从<s>开始，到<text>结束的单\n词串。\n示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。\n\n$(words <text> )\n\n名称：单词个数统计函数——words。\n功能：统计<text>中字符串中的单词个数。\n返回：返回<text>中的单词数。\n示例：$(words, foo bar baz)返回值是“3”。\n备注：如果我们要取<text>中最后的一个单词，我们可以这样：$(word $(words <text> \n),<text> )。\n\n$(firstword <text> )\n\n名称：首单词函数——firstword。\n功能：取字符串<text>中的第一个单词。\n返回：返回字符串<text>的第一个单词。\n示例：$(firstword foo bar)返回值是“foo”。\n备注：这个函数可以用word函数来实现：$(word 1,<text> )。\n\n以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，\n举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索\n路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，\n如：\n\noverride CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))\n\n如果我们的“$(VPATH)”值是“src:../headers”，那么“$(patsubst %,-I%,$(subst :\n, ,$(VPATH)))”将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数\n。"}
        {:block/id #uuid "66387e93-3c31-44d2-a89b-702eb63e0e05",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **三、文件名操作函数**\n\n下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是\n一系列的文件名来对待。\n\n$(dir <names...> )\n\n名称：取目录函数——dir。\n功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之\n前的部分。如果没有反斜杠，那么返回“./”。\n返回：返回文件名序列<names>的目录部分。\n示例： $(dir src/foo.c hacks)返回值是“src/ ./”。\n\n$(notdir <names...> )\n\n名称：取文件函数——notdir。\n功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（“/”\n）之后的部分。\n返回：返回文件名序列<names>的非目录部分。\n示例： $(notdir src/foo.c hacks)返回值是“foo.c hacks”。\n\n$(suffix <names...> )\n\n名称：取后缀函数——suffix。\n功能：从文件名序列<names>中取出各个文件名的后缀。\n返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。\n示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。\n\n$(basename <names...> )\n\n名称：取前缀函数——basename。\n功能：从文件名序列<names>中取出各个文件名的前缀部分。\n返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。\n示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar h\nacks”。\n\n$(addsuffix <suffix>,<names...> )\n\n名称：加后缀函数——addsuffix。\n功能：把后缀<suffix>加到<names>中的每个单词后面。\n返回：返回加过后缀的文件名序列。\n示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。\n\n$(addprefix <prefix>,<names...> )\n\n名称：加前缀函数——addprefix。\n功能：把前缀<prefix>加到<names>中的每个单词后面。\n返回：返回加过前缀的文件名序列。\n示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar”。\n\n$(join <list1>,<list2> )\n\n名称：连接函数——join。\n功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比<\nlist2>的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比\n<list1>多，那么，<list2>多出来的单词将被复制到<list2>中。\n返回：返回连接过后的字符串。\n示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。"}
        {:block/id #uuid "66387e93-a54a-4823-b632-92c6e6d33f77",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **四、foreach 函数**\n\nforeach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的\nforeach函数几乎是仿照于Unix标准Shell（/bin /sh）中的for语句，或是C-Shell（/bin\n/csh）中的foreach语句而构建的。它的语法是：\n\n$(foreach <var>,<list>,<text> )\n\n这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。\n\n所以，<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var>\n这个参数来依次枚举<list>中的单词。举个例子：\n\nnames := a b c d\n\nfiles := $(foreach n,$(names),$(n).o)\n\n上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(f\niles)的值是“a.o b.o c.o d.o”。\n\n注意，foreach中的<var>参数是一个临时的局部变量，foreach函数执行完后，参数<var>的变量将不在作用，其作用域只在foreach函数当中。"}
        {:block/id #uuid "66387e93-620a-4d43-8a8b-cbc1addae00a",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **五、if 函数**\n\nif函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：\n\n$(if <condition>,<then-part> )\n\n或是\n\n$(if <condition>,<then-part>,<else-part> )\n\n可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part> 会被计算。\n\n而if函数的返回值是，如果<condition>为真（非空字符串），那个<then- part>会是整个函数的返回值，如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，此时如果<else-part>没有被定义，那么，整个函数返回空字串。\n\n所以，<then-part>和<else-part>只会有一个被计算。"}
        {:block/id #uuid "66387e93-1d9f-4879-b533-5c3be8e331f3",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **六、call函数**\n\ncall函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：\n\n$(call <expression>,<parm1>,<parm2>,<parm3>...)\n\n当 make执行这个函数时，<expression>参数中的变量，如$(1)，$(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而<expression>的返回值就是 call函数的返回值。例如：\n\nreverse = $(1) $(2)\n\nfoo = $(call reverse,a,b)\n\n那么，foo的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：\n\nreverse = $(2) $(1)\nfoo = $(call reverse,a,b)\n\n此时的foo的值就是“b a”。"}
        {:block/id #uuid "66387e93-edc5-4d4f-904a-c1fa788b5d17",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **七、origin函数**\norigin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：\n\n$(origin <variable> )\n\n注意，<variable>是变量的名字，不应该是引用。所以你最好不要在<variable>中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函\n数的返回值:\n\n“undefined”\n\n如果<variable>从来没有定义过，origin函数返回这个值“undefined”。\n\n“default”\n\n如果<variable>是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。\n\n“environment”\n\n如果<variable>是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。\n\n“file”\n\n如果<variable>这个变量被定义在Makefile中。\n\n“command line”\n\n如果<variable>这个变量是被命令行定义的。\n\n“override”\n\n如果<variable>是被override指示符重新定义的。\n\n“automatic”\n\n如果<variable>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。\n\n这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一\n个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是\n，在我们的Makefile中，我们可以这样写：\n\nifdef bletch\n\nifeq \"$(origin bletch)\" \"environment\"\n\nbletch = barf, gag, etc.\n\nendif\n\nendif\n\n当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗\n暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。"}
        {:block/id #uuid "66387e93-c39b-40d1-8bce-b583f62f6894",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **八、shell函数**\n\nshell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数\n返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：\n\ncontents := $(shell cat foo)\n\nfiles := $(shell echo *.c)\n\n注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。"}
        {:block/id #uuid "66387e93-9c21-4251-a27f-cf4f1299a2c4",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **九、控制make的函数**\n\nmake提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。\n\n$(error <text ...> )\n\n产生一个致命的错误，<text ...>是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也\n是可以的。例如：\n\n示例一：\n\nifdef ERROR_001\n\n$(error error is $(ERROR_001))\n\nendif\n\n示例二：\n\nERR = $(error found an error!)\n\n.PHONY: err\n\nerr: ; $(ERR)\n\n示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。\n\n$(warning <text ...> )\n\n这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。\n\n**\n**"}
        {:block/id #uuid "66387e93-a6a6-4041-9db1-ea2f28dbd259",
         :block/properties {:heading 2},
         :block/format :markdown,
         :block/children [],
         :block/content
         "##  **make 的运行**\n——————\n\n一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让 make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。"}
        {:block/id #uuid "66387e93-3fbe-441b-abe6-93396264480f",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **一、make的退出码**\n\nmake命令执行后有三个退出码：\n\n> \n\n0 —— 表示成功执行。\n\n1 —— 如果make运行时出现任何错误，其返回1。\n\n2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。\n\nMake的相关参数我们会在后续章节中讲述。"}
        {:block/id #uuid "66387e93-0ebb-470e-aec1-1e32b5c35d5d",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **二、指定Makefile**\n\n前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就\n开始读取这个文件并执行。\n\n当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“--file”参数（“-- makefile”参数也行）。例如，我们有个mak\nefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：\n\nmake –f hchen.mk\n\n如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。"}
        {:block/id #uuid "66387e93-d872-4682-9dbf-b80b82259076",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **三、指定目标**\n\n一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的 makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）任何在makefile中的目标都可以被指定成终极目标，但是除了以“- ”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。\n\n有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：\n\nsources = foo.c bar.c\nifneq ( $(MAKECMDGOALS),clean)\ninclude $(sources:.c=.d)\nendif\n\n基于上面的这个例子，只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。\n\n使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：\n\n.PHONY: all\nall: prog1 prog2 prog3 prog4\n\n从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”， “prog2”， “prog3”和 “prog4”，我们可以使用“make all”命令来编译所有的目标\n（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make prog2”来单独编译目标“prog2”。\n\n即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件\n发布时，特别是GNU这种开源软件的发布时，其 makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。\n\n> \n\n**“all” **             这个伪目标是所有目标的目标，其功能一般是编译所有的目标。\n\n**“clean”       **这个伪目标功能是删除所有被make创建的文件。\n\n**“install”       **这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。\n\n**“print”         **这个伪目标的功能是例出改变过的源文件。\n\n**“tar”            ** 这个伪目标功能是把源程序打包备份。也就是一个tar文件。\n\n**“dist” **          这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。\n\n**“TAGS” **       这个伪目标功能是更新所有的目标，以备完整地重编译使用。\n\n**“check”和“test”    **这两个伪目标一般用来测试makefile的流程。\n\n     当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。"}
        {:block/id #uuid "66387e93-5b2d-4881-816b-960292aaf9ce",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **四、检查规则**\n\n有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：\n\n“-n”\n“--just-print”\n“--dry-run”\n“--recon”\n不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。\n\n“-t”\n“--touch”\n这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。\n\n“-q”\n“--question”\n这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。\n\n“-W <file>”\n“--what-if=<file>”\n“--assume-new=<file>”\n“--new-file=<file>”\n这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件\n所发生的规则命令。\n\n另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。"}
        {:block/id #uuid "66387e93-199a-4a96-ab68-66216b31adf2",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **五、make的参数**\n\n下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。\n\n“-b”\n“-m”\n这两个参数的作用是忽略和其它版本make的兼容性。\n\n“-B”\n“--always-make”\n认为所有的目标都需要更新（重编译）。\n\n“-C <dir>”\n“--directory=<dir>”\n指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”\n等价于“make –C ~hchen/test/prog”。\n\n“—debug[=<options>]”\n输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<options>的取值：\n\n> \n\na —— 也就是all，输出所有的调试信息。（会非常的多）\n\nb —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。\n\nv —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。\n\ni —— 也就是implicit，输出所以的隐含规则。\n\nj —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。\n\nm —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。\n\n“-d”\n相当于“--debug=a”。\n\n“-e”\n“--environment-overrides”\n指明环境变量的值覆盖makefile中定义的变量的值。\n\n“-f=<file>”\n“--file=<file>”\n“--makefile=<file>”\n指定需要执行的makefile。\n\n“-h”\n“--help”\n显示帮助信息。\n\n“-i”\n“--ignore-errors”\n在执行时忽略所有的错误。\n\n“-I <dir>”\n“--include-dir=<dir>”\n指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。\n\n“-j [<jobsnum>]”\n“--jobs[=<jobsnum>]”\n指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-D\nOS中是无用的）\n\n“-k”\n“--keep-going”\n出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。\n\n“-l <load>”\n“--load-average[=<load]”\n“—max-load[=<load>]”\n指定make运行命令的负载。\n\n“-n”\n“--just-print”\n“--dry-run”\n“--recon”\n仅输出执行过程中的命令序列，但并不执行。\n\n“-o <file>”\n“--old-file=<file>”\n“--assume-old=<file>”\n不重新生成的指定的<file>，即使这个目标的依赖文件新于它。\n\n“-p”\n“--print-data-base”\n输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用“make -q\np”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用\n这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。\n\n“-q”\n“--question”\n不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。\n\n“-r”\n“--no-builtin-rules”\n禁止make使用任何隐含规则。\n\n“-R”\n“--no-builtin-variabes”\n禁止make使用任何作用于变量上的隐含规则。\n\n“-s”\n“--silent”\n“--quiet”\n在命令运行时不输出命令的输出。\n\n“-S”\n“--no-keep-going”\n“--stop”\n取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。\n\n“-t”\n“--touch”\n相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。\n\n“-v”\n“--version”\n输出make程序的版本、版权等关于make的信息。\n\n“-w”\n“--print-directory”\n输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。\n\n“--no-print-directory”\n禁止“-w”选项。\n\n“-W <file>”\n“--what-if=<file>”\n“--new-file=<file>”\n“--assume-file=<file>”\n假定目标<file>需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>的修改时\n间为当前时间。\n\n“--warn-undefined-variables”\n只要make发现有未定义的变量，那么就输出警告信息。"}
        {:block/id #uuid "66387e93-e068-4565-b379-d11eb4382564",
         :block/properties {:heading 2},
         :block/format :markdown,
         :block/children [],
         :block/content
         "##  **隐含规则**\n**————**\n\n在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o] 文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。\n\n“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就\n不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。\n\n“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。\n\n我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保\n证我们Makefile的兼容性。\n我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当\n然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。"}
        {:block/id #uuid "66387e93-6d68-4bfe-a473-000ed66d6020",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **一、使用隐含规则**\n\n如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：\n\nfoo : foo.o bar.o\ncc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)\n\n我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成\n命令。\n\nmake 会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 [.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：\n\nfoo.o : foo.c\ncc –c foo.c $(CFLAGS)\nbar.o : bar.c\ncc –c bar.c $(CFLAGS)\n\n因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。\n\n当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。\n\n还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：\n\nfoo.o : foo.p\n\n依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过 “foo.c”调用C的编译器生成f\noo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的 C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。"}
        {:block/id #uuid "66387e93-0f85-4c02-a33b-5de769893c91",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **二、隐含规则一览**\n\n这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“--no-builtin-rules”选项来取消所有的预设置的隐含规则。\n\n当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表 ”（也就一系统\n定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out,.a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .\nh, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。\n\n还是先来看一看常用的隐含规则吧。\n\n1、编译C程序的隐含规则。\n“<n>.o”的目标的依赖目标会自动推导为“<n>.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)”\n\n2、编译C++程序的隐含规则。\n“<n>.o” 的目标的依赖目标会自动推导为“<n>.cc”或是“<n>.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而\n不是“.C”）\n\n3、编译Pascal程序的隐含规则。\n“<n>.o”的目标的依赖目标会自动推导为“<n>.p”，并且其生成命令是“$(PC) –c $(PFLAGS)”。\n\n4、编译Fortran/Ratfor程序的隐含规则。\n“<n>.o”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”或“<n>.f”，并且其生成命令是:\n“.f” “$(FC) –c $(FFLAGS)”\n“.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)”\n“.f” “$(FC) –c $(FFLAGS) $(RFLAGS)”\n\n5、预处理Fortran/Ratfor程序的隐含规则。\n“<n>.f”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：\n“.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)”\n“.r” “$(FC) –F $(FFLAGS) $(RFLAGS)”\n\n6、编译Modula-2程序的隐含规则。\n“<n>.sym” 的目标的依赖目标会自动推导为“<n>.def”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(DEFFLAGS)”。“<n.o>” 的目标的依赖目标会自动推导为“<n>.mod”，\n并且其生成命令是：“$(M2C) $(M2FLAGS) $(MODFLAGS)”。\n\n7、汇编和汇编预处理的隐含规则。\n“<n>.o” 的目标的依赖目标会自动推导为“<n>.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“<n>.s” 的目标的依赖目标会自动推导为“<n>.S”\n，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。\n\n8、链接Object文件的隐含规则。\n“<n>” 目标依赖于“<n>.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)”。这个规则对\n于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：\n\nx : y.o z.o\n\n并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：\n\ncc -c x.c -o x.o\ncc -c y.c -o y.o\ncc -c z.c -o z.o\ncc x.o y.o z.o -o x\nrm -f x.o\nrm -f y.o\nrm -f z.o\n\n如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。\n\n9、Yacc C程序时的隐含规则。\n\n“<n>.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC) $(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）\n\n10、Lex C程序时的隐含规则。\n“<n>.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。（关于“Lex”的细节请查看相关资料）\n\n11、Lex Ratfor程序时的隐含规则。\n“<n>.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX\n) $(LFALGS)”。\n\n12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。\n“<n>.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于“<n>.y”和“<n>.l”也是同样的规则。"}
        {:block/id #uuid "66387e93-f83d-401c-b405-75f5601ad02a",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **三、隐含规则使用的变量**\n\n在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“--no– builtin-variables”参数来取消你所定义的变量\n对隐含规则的作用。\n\n例如，第一条隐含规则——编译C程序的隐含规则的命令是“$(CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“$(CC)”重定义成“gcc”，把\n变量“$(CFLAGS)”重定义成 “-g”，那么，隐含规则中的命令全部会以“gcc –c -g $(CPPFLAGS)”的样子来执行了。\n\n我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数\n相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：\n\n**1、关于命令的变量。**\n\nAR   函数库打包程序。默认命令是“ar”。\nAS\n汇编语言编译程序。默认命令是“as”。\nCC\nC语言编译程序。默认命令是“cc”。\nCXX\nC++语言编译程序。默认命令是“g++”。\nCO\n从 RCS文件中扩展文件程序。默认命令是“co”。\nCPP\nC程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。\nFC\nFortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。\nGET\n从SCCS文件中扩展文件的程序。默认命令是“get”。\nLEX\nLex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。\nPC\nPascal语言编译程序。默认命令是“pc”。\nYACC\nYacc文法分析器（针对于C程序）。默认命令是“yacc”。\nYACCR\nYacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。\nMAKEINFO\n转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。\nTEX\n从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。\nTEXI2DVI\n从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。\nWEAVE\n转换Web到TeX的程序。默认命令是“weave”。\nCWEAVE\n转换C Web 到 TeX的程序。默认命令是“cweave”。\nTANGLE\n转换Web到Pascal语言的程序。默认命令是“tangle”。\nCTANGLE\n转换C Web 到 C。默认命令是“ctangle”。\nRM\n删除文件命令。默认命令是“rm –f”。\n\n**2、关于命令参数的变量**\n\n下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是\n空。\n\nARFLAGS\n函数库打包程序AR命令的参数。默认值是“rv”。\nASFLAGS\n汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。\nCFLAGS\nC语言编译器参数。\nCXXFLAGS\nC++语言编译器参数。\nCOFLAGS\nRCS命令参数。\nCPPFLAGS\nC预处理器参数。（ C 和 Fortran 编译器也会用到）。\nFFLAGS\nFortran语言编译器参数。\nGFLAGS\nSCCS “get”程序参数。\nLDFLAGS\n链接器参数。（如：“ld”）\nLFLAGS\nLex文法分析器参数。\nPFLAGS\nPascal语言编译器参数。\nRFLAGS\nRatfor 程序的Fortran 编译器参数。\nYFLAGS\nYacc文法分析器参数。"}
        {:block/id #uuid "66387e93-784f-4311-b56e-cc6fe6f4e8ba",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **四、隐含规则链**\n\n有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则\n叫做“隐含规则链”。\n\n在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调\n用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。\n\n我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？\n\n在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。\n\n通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）\n\n你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。\n\n在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。\n\nMake 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc –o foo foo.c），于是优化过的规\n则就不会生成中间文件。\n\n**\n**###  **五、定义模式规则**\n\n你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有\"%\"字符。\"%\"的意思是表示一个或多个任意字符。在依赖目标中同样可以使用\"%\"，只是依赖目标中的\"%\"的取值，取决于其目标。\n\n有一点需要注意的是，\"%\"的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的\"%\"则发生在运行时。\n\n**1、模式规则介绍**\n\n模式规则中，至少在规则的目标定义中要包含\"%\"，否则，就是一般的规则。目标中的\"%\"定义表示对文件名的匹配，\"%\"表示长度任意的非空字符串。例如：\"%.c\"表示以\".c\"结尾的文件名（文件名的长度至少为3），而\"s.%.c\"则表示以\"s.\"开头，\".c\"结尾的文件名（文件名的长度至少为 5）。\n\n如果\"%\"定义在目标中，那么，目标中的\"%\"的值决定了依赖目标中的\"%\"的值，也就是说，目标中的模式的\"%\"决定了依赖目标中\"%\"的样子。例如有一个模式规则如下：\n\n%.o : %.c ; <command ......>\n\n其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是\"a.o b.o\"，那么\"%c\"就是\"a.c b.c\"。\n\n一旦依赖目标中的\"%\"模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。\n\n**2、模式规则示例**\n\n下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.\n\n%.o : %.c\n$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@\n\n其中，\"$@\"表示所有的目标的挨个值，\"$<\"表示了所有依赖目标的挨个值。这些奇怪的变\n量我们叫\"自动化变量\"，后面会详细讲述。\n\n下面的这个例子中有两个目标是模式的：\n\n%.tab.c %.tab.h: %.y\nbison -d $<\n\n这条规则告诉make把所有的[.y]文件都以\"bison -d <n>.y\"执行，然后生成\"<n>.tab.c\"和\"<n>.tab.h\"文件。（其中，\"<n>\" 表示一个任意字符串）。如果我们的执行程序\"foo\"依\n赖于文件\"parse.tab.o\"和\"scan.o\"，并且文件\"scan.o\"依赖于文件\"parse.tab.h\"，如果\"parse.y\"文件被更新了，那么根据上述的规则，\"bison -d parse.y\"就会被执行一次，于\n是，\"parse.tab.o\"和\"scan.o\"的依赖文件就齐了。（假设，\"parse.tab.o\" 由\"parse.tab.c\"生成，和\"scan.o\"由\"scan.c\"生成，而\"foo\"由\"parse.tab.o\"和\"scan.o\"链接生成，\n而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）\n\n**3、自动化变量**\n\n在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。\n\n自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。\n\n下面是所有的自动化变量及其说明：\n\n$@\n表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，\"$@\"就是匹配于目标中模式定义的集合。\n\n$%\n仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是\"foo.a(bar.o)\"，那么，\"$%\"就是\"bar.o\"，\"$@\"就是\"foo.a\"。如果目标不是函数库文件（Unix下是\n[.a]，Windows下是[.lib]），那么，其值为空。\n\n$<\n依赖目标中的第一个目标名字。如果依赖目标是以模式（即\"%\"）定义的，那么\"$<\"将是符合模式的一系列的文件集。注意，其是一个一个取出来的。\n\n$?\n所有比目标新的依赖目标的集合。以空格分隔。\n\n$^\n所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。\n\n$+\n这个变量很像\"$^\"，也是所有依赖目标的集合。只是它不去除重复的依赖目标。\n\n$*\n这个变量表示目标模式中\"%\"及其之前的部分。如果目标是\"dir/a.foo.b\"，并且目标的模式是\"a.%.b\"，那么，\"$*\"的值就是\"dir /a.foo\"。这个变量对于构造有关联的文件名是比\n较有较。如果目标中没有模式的定义，那么\"$*\"也就不能被推导出，但是，如果目标文件的后缀是 make所识别的，那么\"$*\"就是除了后缀的那一部分。例如：如果目标是\"foo.c\"\n，因为\".c\"是make所能识别的后缀名，所以，\"$*\"的值就是\"foo\"。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用\"$*\"，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么\"$*\"就是空值。\n\n当你希望只对更新过的依赖文件进行操作时，\"$?\"在显式规则中很有用，例如，假设有一个函数库文件叫\"lib\"，其由其它几个object文件更新。那么把object文件打包的比较有效\n率的Makefile规则是：\n\nlib : foo.o bar.o lose.o win.o\nar r lib $?\n\n在上述所列出来的自动量变量中。四个变量（$@、$<、$%、$*）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上\"D\"或\"F\"字样。这是GNU make中老版本的特性，在新版本中，我们使用函数\"dir\"或\"notdir\"就可以做到了。\"D\"的含义就是Directory，就是目录，\"F\"的含义就是File，就是文件。\n\n下面是对于上面的七个变量分别加上\"D\"或是\"F\"的含义：\n\n$(@D)\n表示\"$@\"的目录部分（不以斜杠作为结尾），如果\"$@\"值是\"dir/foo.o\"，那么\"$(@D)\"就是\"dir\"，而如果\"$@\"中没有包含斜杠的话，其值就是\".\"（当前目录）。\n\n$(@F)\n表示\"$@\"的文件部分，如果\"$@\"值是\"dir/foo.o\"，那么\"$(@F)\"就是\"foo.o\"，\"$(@F)\"相当于函数\"$(notdir $@)\"。\n\n\"$(*D)\"\n\"$(*F)\"\n和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，\"$(*D)\"返回\"dir\"，而\"$(*F)\"返回\"foo\"\n\n\"$(%D)\"\n\"$(%F)\"\n分别表示了函数包文件成员的目录部分和文件部分。这对于形同\"archive(member)\"形式的目标中的\"member\"中包含了不同的目录很有用。\n\n\"$(<D)\"\n\"$(<F)\"\n分别表示依赖文件的目录部分和文件部分。\n\n\"$(^D)\"\n\"$(^F)\"\n分别表示所有依赖文件的目录部分和文件部分。（无相同的）\n\n\"$(+D)\"\n\"$(+F)\"\n分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）\n\n\"$(?D)\"\n\"$(?F)\"\n\n分别表示被更新的依赖文件的目录部分和文件部分。\n\n最后想提醒一下的是，对于\"$<\"，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，\"$(< )\"就要比\"$<\"要好一些。\n\n还得要注意的是，这些变量只使用在规则的命令中，而且一般都是\"显式规则\"和\"静态模式规则\"（参见前面\"书写规则\"一章）。其在隐含规则中并没有意义。\n\n**4、模式的匹配**\n\n一般来说，一个目标的模式有一个有前缀或是后缀的\"%\"，或是没有前后缀，直接就是一个\"%\"。因为\"%\"代表一个或多个字符，所以在定义好了的模式中，我们把\"%\"所匹配的内容叫做\"茎\"，例如\"%.c\"所匹配的文件\"test.c\"中\"test\"就是\"茎\"。因为在目标和依赖目标中同时有\"%\"时，依赖目标的\"茎\"会传给目标，当做目标中的\"茎\"。\n\n当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行\"茎\"的传递时，我们需要知道这个步骤。例如有一个模式\"e%t\"，文件\"src/eat\" 匹配于该模式，于是\"src/a\"就是其\"茎\"，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式\"c%r\"，那么，目标就是\"src/car\"。（\"茎\"被传递）\n\n**5、重载内建隐含规则**\n\n你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：\n\n%.o : %.c\n$(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)\n\n你可以取消内建的隐含规则，只要不在后面写命令就行。如：\n\n%.o : %.s\n\n同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。"}
        {:block/id #uuid "66387e93-d61e-438b-81d4-e4a39c79ade1",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **六、老式风格的\"后缀规则\"**\n\n后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：\"双后缀\"和\"单后缀\"。\n\n双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如\".c.o\"相当于\"%o : %c\"。单后缀规则只定义一个后缀，也就是源文件的后缀。如\".c\"相当于\"% : %.c\"。\n\n后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：\".c\"和\".o\"都是make所知道。因而，如果你定义了一个规则是\".c.o\"那么其就是双后缀规则，意义就是\".c\" 是源文件的后缀，\".o\"是目标文件的后缀。如下示例：\n\n.c.o:\n$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<\n\n后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：\n\n.c.o: foo.h\n$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<\n\n这个例子，就是说，文件\".c.o\"依赖于文件\"foo.h\"，而不是我们想要的这样：\n\n%.o: %.c foo.h\n$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<\n\n后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。\n\n而要让make知道一些特定的后缀，我们可以使用伪目标\".SUFFIXES\"来定义或是删除，如：\n\n.SUFFIXES: .hack .win\n\n把后缀.hack和.win加入后缀列表中的末尾。\n\n.SUFFIXES: # 删除默认的后缀\n.SUFFIXES: .c .o .h # 定义自己的后缀\n\n先清楚默认后缀，后定义自己的后缀列表。\n\nmake的参数\"-r\"或\"-no-builtin-rules\"也会使用得默认的后缀列表为空。而变量\"SUFFIXE\"被用来定义默认的后缀列表，你可以用\".SUFFIXES\"来改变后缀列表，但请不要改变变量\"SUFFIXE\"的值。"}
        {:block/id #uuid "66387e93-36fe-46b1-8ab0-6781a3c14e96",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **七、隐含规则搜索算法**\n\n比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是\"archive(member)\"的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把\"member\"当作T来搜索。\n\n> \n\n1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是\"src/foo.o\"，那么，D就是\"src/\"，N就是\"foo.o\"）\n\n2、创建所有匹配于T或是N的模式规则列表。\n\n3、如果在模式规则列表中有匹配所有文件的模式，如\"%\"，那么从列表中移除其它的模式。\n\n4、移除列表中没有命令的规则。\n\n5、对于第一个在列表中的模式规则：\n\n> \n\n1）推导其\"茎\"S，S应该是T或是N匹配于模式中\"%\"非空的部分。\n\n> \n\n2）计算依赖文件。把依赖文件中的\"%\"都替换成\"茎\"S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。\n\n> \n\n3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫\"理当存在\"）\n\n> \n\n4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。\n\n6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：\n\n> \n\n1）如果规则是终止规则，那就忽略它，继续下一条模式规则。\n\n> \n\n2）计算依赖文件。（同第5步）\n\n> \n\n3）测试所有的依赖文件是否存在或是理当存在。\n\n> \n\n4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。\n\n> \n\n5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。\n\n7、如果没有隐含规则可以使用，查看\".DEFAULT\"规则，如果有，采用，把\".DEFAULT\"的命令给T使用。\n\n一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。\n\n**\n**"}
        {:block/id #uuid "66387e93-8c43-4d7c-bb69-1ad86bafa857",
         :block/properties {:heading 2},
         :block/format :markdown,
         :block/children [],
         :block/content
         "##  **使用make更新函数库文件**\n**———————————**\n\n函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令\"ar\"来完成打包工作。"}
        {:block/id #uuid "66387e93-62fc-40a6-a6ff-a89a2463d157",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  一、函数库文件的成员\n\n一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：\n\narchive(member)\n\n这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了\"ar\"命令来服务的。如：\n\nfoolib(hack.o) : hack.o\nar cr foolib hack.o\n\n如果要指定多个member，那就以空格分开，如：\n\nfoolib(hack.o kludge.o)\n\n其等价于：\n\nfoolib(hack.o) foolib(kludge.o)\n\n你还可以使用Shell的文件通配符来定义，如：\n\nfoolib(*.o)"}
        {:block/id #uuid "66387e93-3677-4668-aee0-22d7699a910b",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **二、函数库成员的隐含规则**\n\n当 make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是\"a(m)\"形式的，其会把目标变成\"(m)\"。于是，如果我们的成员是\"%.o\" 的模式定义，并且如果我们使用\"make foo.a(bar.o)\"的形式调用Makefile时，隐含规则会去找\"bar.o\"的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：\n\ncc -c bar.c -o bar.o\nar r foo.a bar.o\nrm -f bar.o\n\n还有一个变量要注意的是\"$%\"，这是专属函数库文件的自动化变量，有关其说明请参见\"自动化变量\"一节。"}
        {:block/id #uuid "66387e93-92e6-436a-aef2-6f70a46f78bd",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **三、函数库文件的后缀规则**\n\n你可以使用\"后缀规则\"和\"隐含规则\"来生成函数库打包文件，如：\n\n.c.a:\n$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o\n$(AR) r $@ $*.o\n$(RM) $*.o\n\n其等效于：\n\n(%.o) : %.c\n$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o\n$(AR) r $@ $*.o\n$(RM) $*.o"}
        {:block/id #uuid "66387e93-d138-4462-a673-d9ad79e3dba2",
         :block/properties {:heading 3},
         :block/format :markdown,
         :block/children [],
         :block/content
         "###  **四、注意事项**\n\n在进行函数库打包文件生成时，请小心使用make的并行机制（\"-j\"参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。\n但就目前而言，你还是应该不要尽量不要使用\"-j\"参数。"}
        {:block/id #uuid "66387e93-d3bc-4aed-a9b0-7a7e12843499",
         :block/properties {:heading 2},
         :block/format :markdown,
         :block/children [],
         :block/content
         "##  **后序**\n**——**\n\n终于到写结束语的时候了，以上基本上就是GNU make的Makefile的所有细节了。其它的产商的make基本上也就是这样的，无论什么样的make，都是以文件的依赖性为基础的，其基本是都是遵循一个标准的。这篇文档中80%的技术细节都适用于任何的make，我猜测\"函数\"那一章的内容可能不是其它make所支持的，而隐含规则方面，我想不同的make会有不同的实现，我没有精力来查看GNU的make和VC的nmake、BCB的make，或是别的UNIX下的make有些什么样的差别，一是时间精力不够，二是因为我基本上都是在Unix下使用make，以前在SCO Unix和IBM的AIX，现在在Linux、Solaris、HP-UX、AIX和Alpha下使用，Linux和Solaris下更多一点。不过，我可以肯定的是，在Unix下的make，无论是哪种平台，几乎都使用了Richard Stallman开发的make和cc/gcc的编译器，而且，基本上都是GNU的make（公司里所有的UNIX机器上都被装上了GNU的东西，所以，使用GNU的程序也就多了一些）。GNU的东西还是很不错的，特别是使用得深了以后，越来越觉得GNU的软件的强大，也越来越觉得GNU的在操作系统中（主要是Unix，甚至Windows）\"杀伤力\"。\n\n对于上述所有的make的细节，我们不但可以利用make这个工具来编译我们的程序，还可以利用make来完成其它的工作，因为规则中的命令可以是任何Shell之下的命令，所以，在Unix下，你不一定只是使用程序语言的编译器，你还可以在Makefile中书写其它的命令，如：tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、 ftp……等等，等等，来完成诸如\"程序打包\"、\"程序备份\"、\"制作程序安装包\"、\"提交代码\"、\"使用程序模板\"、\"合并文件\"等等五花八门的功能，文件操作，文件管理，编程开发设计，或是其它一些异想天开的东西。比如，以前在书写银行交易程序时，由于银行的交易程序基本一样，就见到有人书写了一些交易的通用程序模板，在该模板中把一些网络通讯、数据库操作的、业务操作共性的东西写在一个文件中，在这些文件中用些诸如\"@@@N、###N\"奇怪字串标注一些位置，然后书写交易时，只需按照一种特定的规则书写特定的处理，最后在make时，使用awk和sed，把模板中的\"@@@N、###N\"等字串替代成特定的程序，形成C文件，然后再编译。这个动作很像数据库的\"扩展C\"语言（即在C语言中用\"EXEC　SQL\"的样子执行SQL语句，在用 cc/gcc编译之前，需要使用\"扩展C\"的翻译程序，如cpre，把其翻译成标准C）。"}],
       :block/content "makefile"}],
     :block/content "交叉编译 #？"}
    {:block/id #uuid "662afd34-8057-42a6-92d2-7eab53b2a41a",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "互斥锁 #？"}
    {:block/id #uuid "663ad38b-595e-4be5-b032-0a9834e48bfe",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "663ad38e-21f0-4543-b7ab-ae69b6bfdf3f",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "```Makefile\nedit : main.o kbd.o command.o display.o \\\n\tinsert.o search.o files.o utils.o\n    cc -o edit main.o kbd.o command.o display.o \\\n    \tinsert.o search.o files.o utils.o\n        \nmain.o : main.c defs.h\n\tcc -c main.c\nkdb.o : kbd.c defs.h command.h\n\tcc -c kbd.c\ncommand.o : command.c defs.h command.h\n\tcc -c command.c\ndisplay.o : display.c defs.h buffer.h\n\tcc -c display.c\ninsert.o : insert.c defs.h buffer.h\n\tcc -c insert.c\nsearch.o : search.c defs.h buffer.h\n\tcc -c search.c\nfiles.o : files.c defs.h buffer.h command.h\n\tcc -c files.c\nutils.o : utils.c defs.h\n\tcc -c utils.c\nclean:\n\trm edit main.o kbd.o command.o display.o \\\n    \tinsert.o search.o files.o utils.o\n```"}
      {:block/id #uuid "663ad652-8209-40ef-a4f6-96a2d6aff4c4",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "663ad73d-0fe7-42a9-a37f-2adebfd5696a",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "```makefile\nobjects = main.o kbd.o command.o display.o \\\n\tinsert.o search.o files.o utils.o\nedit : %(objects)\n    cc -o edit %(objects)\n        \nmain.o : main.c defs.h\n\tcc -c main.c\nkdb.o : kbd.c defs.h command.h\n\tcc -c kbd.c\ncommand.o : command.c defs.h command.h\n\tcc -c command.c\ndisplay.o : display.c defs.h buffer.h\n\tcc -c display.c\ninsert.o : insert.c defs.h buffer.h\n\tcc -c insert.c\nsearch.o : search.c defs.h buffer.h\n\tcc -c search.c\nfiles.o : files.c defs.h buffer.h command.h\n\tcc -c files.c\nutils.o : utils.c defs.h\n\tcc -c utils.c\nclean:\n\trm edit main.o kbd.o command.o display.o \\\n    \tinsert.o search.o files.o utils.o\n```"}],
       :block/content "变量"}
      {:block/id #uuid "663ad71f-ea30-427b-a35c-0503eaa53979",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "663ad743-93d3-4de1-a906-f2f7e1c9ae2b",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "```makefile\nobjects = main.o kbd.o command.o display.o \\\n\tinsert.o search.o files.o utils.o\nedit : %(objects)\n    cc -o edit %(objects)\n        \nmain.o : defs.h\nkdb.o : defs.h command.h\ncommand.o : defs.h command.h\ndisplay.o : defs.h buffer.h\ninsert.o : defs.h buffer.h\nsearch.o : defs.h buffer.h\nfiles.o : defs.h buffer.h command.h\nutils.o : defs.h\n\n.PHONY : clean\nclean:\n\trm edit main.o kbd.o command.o display.o \\\n    \tinsert.o search.o files.o utils.o\n```"}],
       :block/content "自动推导"}
      {:block/id #uuid "663ad7ed-ba5e-4c46-b327-d49ebf1a0959",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "663ad7f3-6601-4a1b-a074-ecd02724a10c",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "```makefile\nobjects = main.o kbd.o command.o display.o \\\n\tinsert.o search.o files.o utils.o\n    \nedit : $(objects)\n\tcc -o edit $(objects)\n    \n%(objects) : defs.h\nkbd.o command.o files.o : command.h\ndisplay.o insert.o search.o files.o : buffer.h\n\n.PHONY : clean\nclean:\n\t-rm edit %(objects)\n```"}],
       :block/content "另类风格"}
      {:block/id #uuid "663ad767-492b-431e-aff7-c2df610d8457",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "663ada2e-a598-43bf-9af4-98fd6a3b792a",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content "读入所有的Makefile；"}
        {:block/id #uuid "663ada41-83f2-4645-850b-e5c8e26d5bdb",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content "读入被$\\mathsf{include}$的其他Makefile；"}
        {:block/id #uuid "663ada50-45a2-4bd4-979b-c9e9843f88d9",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content "初始化文件中的变量；"}
        {:block/id #uuid "663ada57-5695-4bb0-83e9-97c19ae29066",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content "推导隐晦规则，并分析所有规则；"}
        {:block/id #uuid "663ada61-9aad-49a8-833c-0028a0a14f94",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content "为所有的目标文件创建依赖关系链；"}
        {:block/id #uuid "663ada69-92ab-4785-b8a2-9509893a41ed",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content "根据依赖关系，决定哪些目标要重新生成；"}
        {:block/id #uuid "663ada77-9258-49e9-904f-acc843162cc2",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content "执行生成命令。"}],
       :block/content "$\\mathsf{make}$的工作方式"}
      {:block/id #uuid "663addb0-d98e-4504-a5f7-1c34b9522237",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "663adf03-e6ba-4078-a797-90085fade789",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "伪目标并非一个文件而是一个标签，并不会通过$\\mathsf{make}$生成一个文件，也无法生成其依赖关系并决定是否要执行，所以必须显式地指明这个伪目标才能让其生效。因此伪目标不能和文件名重名，但也可以通过$\\mathsf{.PHONY}$标记来显式指明伪目标，即使存在重名文件，依然会被视为一个伪目标。"}
        {:block/id #uuid "663addba-cff6-432d-a392-0d55feaefff2",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "伪目标也可以作为默认目标，需要生成多个可执行文件时，可以使用伪目标作为默认目标\n```makefile\nall : prog1 prog2 prog3\n.PHONY : all\n\nprog1: prog1.o utils.o\n\tcc -o prog1 prog1.o utils.o\nprog2: prog2.o\n\tcc -o prog2 prog2.o\nprog3: prog3.o\n\tcc -o prog3 prog3.o sort.o utils.o\n```"}
        {:block/id #uuid "663adea9-afc6-42e8-8330-025ff6151ab5",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "伪目标同样可以成为依赖\n```makefile\n.PHONY : cleanall cleanobj cleandiff\n\ncleanall : cleanobj cleandiff\n\trm program\n\ncleanobj :\n\trm *.o\n    \ncleandiff:\n\trm *.diff\n```"}],
       :block/content "伪目标"}
      {:block/id #uuid "663ae339-6db2-4841-acdd-940f5f89ac8e",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "663ae33c-152b-4d2e-b826-a8f750b1b799",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "```makefile\nbigoutput littleoutput : text.g\n\tgenerate text.g -$(subst output,,$@)>$@\n\n# equivalent expression\n\nbigoutput : text.g\n\tgenerate text.g -big>bigoutput\n\nlittleoutput : text.g\n\tgenerate text.g -little>littleoutput\n```"}],
       :block/content "多目标"}
      {:block/id #uuid "663ae335-a4c7-4697-8e97-f8d2431f6ad5",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "663ae4e5-06d1-4eeb-ada6-46f3fd3f3cb0",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "```makefile\nobjects = foo.o bar.o\n\nall : $(objects)\n\n$(objects) : %.o : %.c\n\t$(CC) -c $(CFLAGS) $< -o $@\n    \n# equivalent expression\n\nfoo.o : foo.c\n\t$(CC) -c $(CFLAGS) foo.c -o foo.o\nbar.o : bar.c\n\t$(CC) -c $(CFLAGS) bar.c -o bar.o\n```"}],
       :block/content "静态模式"}],
     :block/content "makefile"})}
  {:block/id #uuid "662712a7-37f0-4b8d-b7d8-0e9f211e1f72",
   :block/page-name "hls__H5U&Easy系列可编程逻辑控制器编程与应用手册_1713834305243_0",
   :block/properties
   {:file
    "[H5U&Easy系列可编程逻辑控制器编程与应用手册_1713834305243_0.PDF](../assets/H5U&Easy系列可编程逻辑控制器编程与应用手册_1713834305243_0.PDF)",
    :file-path
    "../assets/H5U&Easy系列可编程逻辑控制器编程与应用手册_1713834305243_0.PDF"},
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "662712a7-98c0-4a71-b847-b77b32a87419",
     :block/properties
     {:file
      "[H5U&Easy系列可编程逻辑控制器编程与应用手册_1713834305243_0.PDF](../assets/H5U&Easy系列可编程逻辑控制器编程与应用手册_1713834305243_0.PDF)",
      :file-path
      "../assets/H5U&Easy系列可编程逻辑控制器编程与应用手册_1713834305243_0.PDF"},
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "65f39d76-84c6-4db6-ae9d-65eacd493ba8",
   :block/page-name "Mar 15th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "65f39d76-5cc8-4d36-863b-e0e5463cec60",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "DONE [[伺服驱动器]] 学习 #📓Note\nDEADLINE: <2024-03-31 Sun 18:00>\n:LOGBOOK:\n* State \"DONE\" from \"LATER\" [2024-03-18 Mon 09:06]\nCLOCK: [2024-03-18 Mon 09:06:44]--[2024-03-18 Mon 11:31:09] =>  02:24:25\n* State \"DONE\" from \"NOW\" [2024-03-18 Mon 11:31]\nCLOCK: [2024-03-18 Mon 13:15:07]--[2024-03-18 Mon 13:15:22] =>  00:00:15\nCLOCK: [2024-03-18 Mon 13:15:33]--[2024-03-19 Tue 09:03:01] =>  19:47:28\nCLOCK: [2024-03-19 Tue 09:03:07]--[2024-03-19 Tue 11:48:33] =>  02:45:26\nCLOCK: [2024-03-20 Wed 17:04:48]--[2024-03-20 Wed 18:05:02] =>  01:00:14\nCLOCK: [2024-03-21 Thu 09:06:30]--[2024-03-21 Thu 09:07:03] =>  00:00:33\nCLOCK: [2024-03-27 Wed 16:49:37]--[2024-03-27 Wed 17:57:33] =>  01:07:56\n* State \"DONE\" from \"LATER\" [2024-03-27 Wed 18:02]\nCLOCK: [2024-03-28 Thu 09:27:33]--[2024-03-28 Thu 14:03:20] =>  04:35:47\n:END:"})}
  {:block/id #uuid "6625fcd2-0be0-4396-99ae-994db8bbaf44",
   :block/page-name "🗃️Archive",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14811-7b59-4d75-8a72-de9a5dfbb22a",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14811-505a-4552-9499-31377dfc0553",
       :block/properties
       {:query-table true, :query-properties "[:block]"},
       :block/format :markdown,
       :block/children [],
       :block/content
       "{{query (and (task DONE) (not (page [[🗂️Project]])))}}"}],
     :block/content "**DONE**"}
    {:block/id #uuid "6603ef97-4b67-4b33-bf82-69948bf18e2c",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "6603efa6-8f6e-4f66-9b65-b60c3fecaf25",
       :block/properties
       {:query-table true, :query-properties "[:block]"},
       :block/format :markdown,
       :block/children [],
       :block/content
       "{{query (and (task DONE) (page [[🗂️Project]]))}}"}],
     :block/content "**ARICHIVED PROJECT**"}
    {:block/id #uuid "65f14811-c840-41a2-b0bf-41666f0ecfc9",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14811-d4b9-44b2-8e14-8444a7052e5f",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "{{query(task CANCELED)}}"}],
     :block/content "**CANCELED**"})}
  {:block/id #uuid "65f14810-c0df-421f-9943-360cc310b90c",
   :block/page-name
   "hls__Electric_Motors_and_Drives_-_Fundamentals,_Types_and_Applications_1710120613540_0",
   :block/properties
   {:file
    "[Electric_Motors_and_Drives_-_Fundamentals,_Types_and_Applications_1710120613540_0.pdf](../assets/Electric_Motors_and_Drives_-_Fundamentals,_Types_and_Applications_1710120613540_0.pdf)",
    :file-path
    "../assets/Electric_Motors_and_Drives_-_Fundamentals,_Types_and_Applications_1710120613540_0.pdf"},
   :block/children
   ({:block/id #uuid "65f14810-570f-43ac-91d4-dffafd799c4e",
     :block/properties
     {:file
      "[Electric_Motors_and_Drives_-_Fundamentals,_Types_and_Applications_1710120613540_0.pdf](../assets/Electric_Motors_and_Drives_-_Fundamentals,_Types_and_Applications_1710120613540_0.pdf)",
      :file-path
      "../assets/Electric_Motors_and_Drives_-_Fundamentals,_Types_and_Applications_1710120613540_0.pdf"},
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "660a4f29-45ed-4796-9dfa-d141df503e45",
   :block/page-name "Mar 26th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66021bc9-e853-4372-976e-f83c8d702e09",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "#+BEGIN_CAUTION\n必须相信自己最坏的判断\n负数存于单字寄存器中会变为一个巨大的正值（第一位的负号会被识别为1）\n测试时记得限制轴的最大转速#☣️Warning\n#+END_CAUTION"})}
  {:block/id #uuid "66262043-90a0-4bec-8b25-745566a31e6f",
   :block/page-name "嵌入式典型平台（ARM）",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "662622f0-a51e-41c9-8ed7-d895ad20ebaa",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[体系结构]]"}
    {:block/id #uuid "66262300-af45-4401-ae4a-174e78b51eda",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[嵌入式裸机]]"}
    {:block/id #uuid "66262310-6102-44a3-97b3-4ca3a7274614",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[嵌入式操作系统]]"})}
  {:block/id #uuid "6626238e-543f-4b6d-aa20-76384e6afab3",
   :block/page-name "网络编程",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66279356-9fa8-47d4-91c8-d6a61a4f9685",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## TCP/IP协议家族"}
    {:block/id #uuid "6627935f-c116-4be5-bcff-ef8b8ba7df1b",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## Socket通信和应用"}
    {:block/id #uuid "66279367-2956-45e4-9cd0-bda320500ed6",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## TCP编程"}
    {:block/id #uuid "6627936c-ecfc-4fd9-ba62-2b7ac15a8cbb",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## UDP编程"})}
  {:block/id #uuid "6625fcd2-417d-430c-b521-d6f7cb2994e6",
   :block/page-name "C++程序设计",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "660bac09-f111-496e-9078-389b40e0afbd",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "6625fcd2-9b14-450f-bde3-783c5739f37f",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "660b6136-d5da-4e49-a160-19ac87d3aa37",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "|Type|Meaning|Minimum Size|\n|bool|boolean|NA|\n|char|character|8bits|\n|wchar_t|wide character|16bits|\n|char16_t|Unicode character|16bits|\n|char32_t|Unicode character|16bits|\n|short|short integer|16bits|\n|int|integer|16bits|\n|long|long integer|32bits|\n|long long|long integer|64bits|\n|float|single-precision floating-point|6 significant digits|\n|doulbe|double-precision floating-point|10 significant digits|\n|long double|extended-precision floating-point|10 significant digits|"}
        {:block/id #uuid "660b61f2-3f6a-4255-9856-714d177cfe85",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "660b62c8-b29e-4033-9e83-ee402fad68d3",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "```C++\nbool b = 42;\t\t\t// b is true\nint i = b;\t\t\t\t// i has value 1\ni = 3.14;\t\t\t\t// i has value 3\ndouble pi = i;\t\t\t// pi has value 3.0\nunsigned char c = -1;\t//assuming 8-bit chars, c has value 255\nsigned char c2 =256;\t//assuming 8-bits chars, the value of c2 is undefined\n```"}
          {:block/id #uuid "660b64ed-c052-4cdb-8ad0-951b31e9b6d1",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "当赋超范围值给无符号类型变量时，编译器会用所赋值与256取模，并将其余数赋予变量。"}
          {:block/id #uuid "660b655b-16b9-4b7f-92d7-27b519c8ee97",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "当赋超范围值给有符号类型变量时，结果是$\\mathsf{undefined}$，程序可能可以运行，也可能崩溃，也可能产生乱码。"}],
         :block/content "数据类型转化"}
        {:block/id #uuid "660b76d7-4f81-44c8-9bd4-7c8ea3ee7e94",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "660b76dd-ec53-4970-a8b0-b08b3555a3fe",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "660b7736-c90c-4a50-8b4d-a25e4377423b",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "十进制：正常表示 >>> $\\mathsf{20}$;"}
            {:block/id #uuid "660b76fe-b4b7-4ade-aeec-e2a1e7b5e4f9",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "八进制：开头为0>>> $\\mathsf{024}$；"}
            {:block/id #uuid "660b7718-fb0e-45c6-bd65-0ac7288c68fe",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "十六进制：开头为0x或者0X>>> $\\mathsf{0x14}$；"}
            {:block/id #uuid "660b78ed-269b-4dfa-852f-7da0feff4c61",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "默认情况下，十进制常量是有符号的，八进制和十六进制常量可能是有符号的也有可能是无符号的；"}
            {:block/id #uuid "660b7937-a723-4579-8f11-6936f7f4384a",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "十进制的数据类型是$\\mathsf{int}$，$\\mathsf{long}$和$\\mathsf{long\\ long}$类型中能够容纳其值的最小类型；"}
            {:block/id #uuid "660b7968-7276-4d05-9c4a-097896c415a9",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "八进制和十六进制则是$\\mathsf{int}$，$\\mathsf{unsigned\\ int}$，$\\mathsf{long}$，$\\mathsf{unsigned\\ long}$，$\\mathsf{long\\ long}$和$\\mathsf{unsigned\\ long\\ long}$中能够容纳其值的最小类型。"}],
           :block/content "整数可以用十进制，八进制以及十六进制表示，以$\\mathsf{20}$为例"}
          {:block/id #uuid "660b7796-8aca-4fe5-961a-a75ea31b1ccc",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "660b7a48-ea96-4adc-8cfa-dd2f8b3932f1",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "3.1415      3.1415E0     0.    0e0    .001\n以上均为合法表示"}
            {:block/id #uuid "660b7a7d-6c98-4128-8c0c-c38cf64b2c67",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "浮点数默认的数据类型为**double**。"}],
           :block/content "浮点数可以用小数点或者科学计数法表示"}
          {:block/id #uuid "660b7a91-6f67-4054-a198-d73827e1945e",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "660b7aa6-0ee6-43ea-a303-eeca48cf6c31",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "字符：'a'，默认数据类型为$\\mathsf{char}$"}
            {:block/id #uuid "660b7aac-76f5-479b-ba20-0424ed3aa243",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "字符串：\"Hello World！\"，默认的数据类型是由$\\mathsf{char}$组成的$\\mathsf{array}$。"}
            {:block/id #uuid "660b7ac2-80e9-42b6-8cb4-6d49115ef5e5",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "编译器会自动再每个字符串后面附上一个空字符（'\\0')，因此字符串的实际长度要比看起来大1。"}],
           :block/content "字符和字符串应分别使用单引号和双引号表示"}
          {:block/id #uuid "660b9dea-de26-41b6-b5fe-6fcf8c73e83a",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "660b9df7-8ff1-4d2e-b78a-ec5b96b542ef",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "布尔值：$\\mathsf{true}$ 和 $\\mathsf{false}$；"}
            {:block/id #uuid "660b9e06-58c9-4f40-aab4-eab231b8cf97",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "指针：$\\mathsf{nullptr}$ 空指针。"}],
           :block/content "布尔值和指针"}
          {:block/id #uuid "660b8070-6a0f-4dfe-8a61-dfd54e64b55a",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "660b9b66-12ce-48dc-b745-4e135c164dbd",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "#+BEGIN_CENTER\n字符和字符串\n#+END_CENTER\n|前缀|含义|类型|\n|u|Unicode 16 字符|**char16_t**|\n|U|Unicode 32 字符|**char32_t**|\n|L|长字符|**wchar_t**|\n|u8|utf-8（仅字符串）|**char**|"}
            {:block/id #uuid "660b9c53-11d1-4076-a373-4cd21bec99da",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "#+BEGIN_CENTER\n整数和浮点数\n#+END_CENTER\n|常量类型|前缀|数据类型|\n|整数|u 或 U|**unsigned**|\n||l 或 L|**long**|\n||ll 或 LL|**long long**|\n|浮点数|f 或 F|**float**|\n||l 或 L|**long double**|"}],
           :block/content "可以通过前缀或者后缀改变字面值的数据类型"}],
         :block/content "字面值常量"}
        {:block/id #uuid "660b7c4b-6957-4c06-a558-02632ac33ecd",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "660b7c50-d361-4317-a906-9771eadf4751",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "|||||\n|换行|\\\\n|水平缩进|\\\\t|\n|警报|\\\\a|垂直缩进|\\\\v|\n|退格|\\\\b|双引号|\\\\\"|\n|反斜杠|\\\\\\|单引号|\\\\'|\n|问号|\\\\？|回车|\\\\r|\n|跳页|\\\\f|||"}],
         :block/content "转义字符"}],
       :block/content "### 基本类型"}
      {:block/id #uuid "660bab03-978c-49d4-95d5-532aef63ef4f",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "660bab17-af2b-42c6-9da3-262cee6b0b85",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "660bab68-f0ea-44b5-ac84-37c05bf74478",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "以下四种方法均可以将变量a初始化为0\n```c++\nint a = 0;\nint a = {0};\nint a{0};\nint a(0);\n```"}
          {:block/id #uuid "660bab95-b849-4b9d-ae72-9e1341214f51",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "使用花括号进行初始化被称为**列表初始化（list initialization）**。其好处在于**当列表初始化被用于基本类型变量时，如果存在丢失信息的风险，编译器会报错**\n```c++\nlong double ld = 3.1415926536;\nint a{ld}, b = {ld};\t//error: narrowing conversion required\nint c(ld), d = ld;\t\t//ok: but value will be truncated\n```"}
          {:block/id #uuid "660bad8f-ad97-4483-b387-dd1e8bac15ba",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "660baed8-4cbc-4751-adb3-a516a1490ac9",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "定义于任何函数体之外的变量被初始化为0；"}
            {:block/id #uuid "660baf33-ce6d-4c52-a886-c722aa53788f",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "定义于函数体内部的基本类型变量将不被初始化，其值为$\\mathsf{undefined}$；试图复制或以其它形式访问此变量会产生错误。"}],
           :block/content
           "如果定义变量的时候没有初始化，变量会被**默认初始化**；这些变量会被赋予一个默认值，具体取决于变量的类型和变量被定义的位置。\ncollapsed:: true"}
          {:block/id #uuid "660bafeb-9a05-4078-8f75-b71ee2f0cace",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "大多数类都支持无需显式初始化变量，即为变量提供了合适的默认值；而部分类要求对每个变量初始化，否则将产生错误。"}],
         :block/content "变量初始化"}
        {:block/id #uuid "660bb1b4-b7b2-4e3d-9470-6ec0e82c3740",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "660bb2d2-e335-4fe1-a436-37124437b6db",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "C++支持分别编译，为了使得不同文件中的变量可以共享，C++区别了**声明**和**定义**。"}
          {:block/id #uuid "660bb1be-7f01-4347-be4e-2278ff85c80b",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "变量**声明**是为变量指定名称和类型，变量**定义**除了指定名称和类型外，还要为变量申请储存空间，可能还要初始化变量。"}
          {:block/id #uuid "660bb2a9-5a5e-4e16-a4f6-29a5cf01e521",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "如果需要仅**声明**变量而不**定义**变量，C++引入了$\\mathsf{extern}$关键字\n```C++\nextern int i;\t\t\t\t\t//declares but does not define i\nint j;\t\t\t\t\t\t\t//declares and defines j\nextern double pi = 3.14159;\t\t//defines and initializes pi\n```\n如果初始化$\\mathsf{extern}$关键字标记的变量，**声明**将会变成**定义**；而在函数中初始化$\\mathsf{extern}$标记的变量，则会引发错误。"}
          {:block/id #uuid "660bb92f-fb02-42bc-aa6f-041cb84dc54f",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "#+BEGIN_NOTE\n变量只能**定义**一次，但可以**声明**很多次。\n#+END_NOTE"}],
         :block/content "变量声明和定义"}
        {:block/id #uuid "660bb9f9-92c3-40b3-99b4-851a8e2abdfb",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "660bbbbb-6b32-4cc6-8a4a-0594f179d9b2",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "长度不限，可包含**字母**、**数字**和**下划线**；"}
          {:block/id #uuid "660bbbe8-4c64-4cb1-84fb-a6e1824ec035",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "必须以字母或下划线开头；"}
          {:block/id #uuid "660bbbf7-511d-42a0-93e8-9e37626620c1",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "不能出现两个连续的下划线；"}
          {:block/id #uuid "660bbc19-d203-433f-9a27-f4e03a893401",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "下划线后不能跟大写字母；"}
          {:block/id #uuid "660bbc21-e232-4e69-8197-00d118b44c3d",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "函数体外的标识符不能以下划线开头。"}
          {:block/id #uuid "660bbc49-de55-4968-be1c-914a2ec785c1",
           :block/properties {},
           :block/format :markdown,
           :block/children [],
           :block/content
           "#+BEGIN_NOTE\n**标识符命名规范**\n\n标识符应体现实际含义\n\n变量命名全部使用小写，如$\\mathsf{index}$而不是$\\mathsf{Index}$或$\\mathsf{INDEX}$\n\n用户自定义的类名以大写开头，如$\\mathsf{Sales\\_item}$\n\n如果标识符由多个单词组成，则单词间应该有明显的区分，例如$\\mathsf{student\\_loan}$或者$\\mathsf{studentLoan}$，而不是$\\mathsf{studentloan}$\n#+END_NOTE"}],
         :block/content "标识符"}],
       :block/content "### 变量"}
      {:block/id #uuid "660bc1bc-336c-40b1-b2be-e394e3d0396f",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "660bc1c6-9c39-4c79-b2cb-730873f69482",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "**复合类型**：基于其他类型定义的类型"}
        {:block/id #uuid "660bc1fd-11d6-4185-af4d-9de5c1314a0a",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "660bc254-7b5c-41c7-92a7-77f23871916e",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "**引用**为对象起了另外一个名字，通过将声明符写成$\\mathsf{\\& d}$的形式来定义引用类型，其中$\\mathsf{d}$是声明的变量名：\n```C++\nint ival = 1024;\nint &refVal = ival;\t\t// refVal refers to (is another name for) ival\nint &refVal2;\t\t\t// error: a reference must be initialized\n```"}
          {:block/id #uuid "660bc238-4b7e-432f-b976-bc567ebdcf9b",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "(这里所提到的引用均指左值引用“lvalue reference”）"}
          {:block/id #uuid "660bc42c-3d62-4452-92f8-aa2f381be760",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "绝大多数引用的类型都要和与之绑定的对象一致，除了两种特殊情况；引用必须绑定在对象上。"}],
         :block/content "引用（reference）\ncollapsed:: true"}
        {:block/id #uuid "660bc469-c128-4b54-a21d-e8e483b9411a",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "660bc485-9c3a-45c1-8b82-ffe6fc419cfb",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "**指针**是指向（point to）另一种类型的复合类型。"}
          {:block/id #uuid "660bc4b9-d6e5-4e4d-bf31-602b93cbce39",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "与**引用**不同，指针本身是一个对象，允许对指针赋值或者复制，而在指针的生命周期内也允许先后指向几个不同的对象。"}
          {:block/id #uuid "660bc500-0831-4e6a-a616-d195a4f746ff",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "指针无需在定义时进行初始化，在块作用域（block scope）中定义的未初始化指针，也将拥有一个未定义的值。"}
          {:block/id #uuid "660bc55e-15de-4f8b-b605-8618f012e04a",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "指针的定义方法是将声明符写成$\\mathsf{* d}$的形式，其中$\\mathsf{d}$是指针名字；如果一条语句定义了几个指针，每个指针前面都应该有$\\mathsf{*}$：\n```c++\nint *ip1, *ip2;\t\t// both ip1 and ip2 are pointers to int\nint dp, *dp2;\t\t// dp2 is a pointer to double; dp is a double\n```"}
          {:block/id #uuid "660bc6ce-49c0-43df-86cc-6f5784b760a3",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "指针存放某个对象的地址，通常使用**取地址符（& operator）**获取对象地址：\n```c++\nint ival = 42;\nint *p = &ival;\t\t// p holds the address of ival; p is a pointer to ival\n```"}
          {:block/id #uuid "660bc764-de01-4432-8b77-19d82075d8eb",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "与引用相同，除了两种例外情况，指针的类型必须与其指向的对象类型相匹配。"}
          {:block/id #uuid "660bc8ea-75ba-4ded-80d9-c76e9ce1becb",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "660bc86f-8acb-4998-8533-f69f2386c647",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content "指向一个对象；"}
            {:block/id #uuid "660bc878-79f6-42b5-941d-8a1051d014d1",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content "指向一个对象所占空间的下一个位置；"}
            {:block/id #uuid "660bc89e-a568-4b9e-82f7-feb04d73389c",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content "空指针，即没有指向任何一个对象；"}
            {:block/id #uuid "660bc8bc-8e31-4815-88c6-72e7dc5119fd",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content "无效指针，即上述情况之外的其他值"}
            {:block/id #uuid "660bc8f5-2849-421e-9d00-b3e0c7c19507",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "第二种和第三种指针是有效的，但和第四种情况一样，这些指针都没有指向具体对象，试图访问这些指针指向的对象所产生的后果无法预计。"}],
           :block/content "指针的值（即地址）应处于以下四种状态之一："}
          {:block/id #uuid "660bcbc0-114b-4fa7-8275-83830c9461da",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "如果指针指向了一个对象，可以使用**解引用符（* operator）**访问该对象：\n```c++\nint ival = 42;\nint *p = &ival;\t\t// p holds the address of ival; p is a pointer to ival\ncout << *p;\t\t\t// * yields the object to which p points; prints 42\n```\n解引用一个指针会得出指针所指向的对象，因此给解引用的结果赋值就是给指针指向的对象赋值：\n```C++\nint ival = 3;\nint *p = &ival;\n*p = 0;\t\t\t\t// * yields the object; assigns a new value to ival through p\ncout << ival; \t// prints 0\n```"}
          {:block/id #uuid "660bcde6-67aa-40e0-97ae-7019f94041fa",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "空指针并不指向任何对象，以下是几种空指针的定义方法：\n```c++\nint *p1 = nullptr;\nint *p2 = 0;\n// must #include cstdlib\nint *p3 = NULL;\n```"}
          {:block/id #uuid "660bcf2f-6614-4d49-8d7e-f9dbf80b6b44",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "将一个整数型变量赋值给指针是非法的，即使此变量的值为0\n```C++\nint zero = 0;\nint *pi = nullptr;\npi = zero;\t\t// error: cannot assign an int to a pointer\n```"}
          {:block/id #uuid "660bd51e-e75a-44b1-9aca-c48e2903f969",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "$\\mathsf{void}$ *指针是一种特殊类型的指针，可用于存放任意对象的地址。但无法直接操作$\\mathsf{void}$ *指针所指向的对象，因为我们并不知道所指对象到底是什么类型。"}
          {:block/id #uuid "66124b86-c997-4a1c-b1ff-3e03f1cab816",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "66124b8e-86e4-40e8-bd83-457ed0d6bfa0",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "直接使用数组名会被转换为指向数组首个元素的指针\n```C++\nint ia[3][3] = {\n  {1, 2, 3},\n  {4, 5, 6},\n  {7, 8, 9}\n};\nint (*p)[3] = ia;\t\t// p is a pointer to an array containts 4 ints\np = &ia[0];\t\t\t\t// equal to the code above\nstd ::cout << **p;\t\t// output 1\nstd ::cout << *p[1];\t// output 2\nstd ::cout << *p;\t\t// output the address of the '1'\nstd ::cout << p;\t\t// output the address of the array '1, 2, 3'\nstd ::cout << std ::endl;\n```"}],
           :block/content "指针与数组"}],
         :block/content "指针（pointer）"}
        {:block/id #uuid "661a30aa-c708-42f2-9f6e-fcc1ad2d4672",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "558383fb-4fc5-45f2-8e27-b661df1a2ca0",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "需要注意的是，在下列代码中，符号\\*和符号\\&各自存在不同的含义\n```c++\nint a = 1;\nint *p = &a;\nint &r = a;\n// outputs the address of variable a\nstd ::cout << p << std ::endl;\nstd ::cout << &r << std ::endl;\n// outputs the value of variable a\nstd ::cout << *p << std ::endl;\nstd ::cout << r << std ::endl;\n```"}
          {:block/id #uuid "b13be0ab-0c10-4d75-9f49-9df6510d9a1b",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "在定义对象的语句中，如上述第2，3行，符号\\*和符号\\&是对类型的指示，说明定义的为指针和引用。"}
          {:block/id #uuid "ac8cd21b-c381-45e4-803b-574ac8016c25",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "而在使用对象的语句中，符号\\*和符号\\&分别为解引用符和取地址符。"}
          {:block/id #uuid "502295e6-4c6f-4ce2-ad17-c16759e35639",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "当对一个指针使用解引用符\\*时，得到的是一个引用。\n```c++\n// outputs \"Test Success.\"\nstring & ptrTest(string *p){\n  *p = \"Test Success.\";\n  return *p\n}\nstring * refTest(string &r){\n    r = \"Test Success.\";\n    return &r;\n}\nstring & ptrTest();\nstring * refTest();\n\nint main(){\n  string s = \"Test.\"\n  string *p = &s;\n  string &r = r;\n  r = ptrTest(p); \t\t\t// p = refTest(r);\n  cout << r << endl; \t\t// cout << *p << endl;\n  return 0;\n}\n```\n上述代码中，函数$\\mathsf{ptrTest}$返回类型是一个**引用**，而定义中返回的是**对一个指针的解引用**；函数$\\mathsf{refTest}$返回类型是一个**指针**，而定义中返回的是**对一个引用的取地址**。两个函数均可正常运行。\n但是，引用并不是一个对象，而指针是个占用一定储存空间的对象，为什么对一个引用取地址可以得到一个指针？既然引用不是一个对象，也不占用储存空间，为什么可以对引用取地址 #？\n经测试，取得的是引用绑定对象的地址 #。"}],
         :block/content "解引用符（\\*）和取地址符（\\&）"}],
       :block/content "### 复合类型"}
      {:block/id #uuid "660ce9f2-7b67-4f31-8f15-e074bd3e4d2b",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "660cea32-29ae-4c0c-8907-56ec3fa5a226",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "用于定义不能被改变的变量。"}
        {:block/id #uuid "660cea8a-7f6b-4ef2-b37c-b810d8824ed7",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "$\\mathsf{const}$类型对象必须在定义时完成初始化。"}
        {:block/id #uuid "660ceab4-ddfd-45d8-8f7c-297c88d3a390",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "默认情况下，$\\mathsf{const}$对象仅在文件内有效；如果希望在所有文件中声明并使用$\\mathsf{const}$对象，则需要在在定义时也增加$\\mathsf{extern}$关键字：\n```c++\n// file_1.cc\nextern const int bufSize = fcn();\t// defines and initializes a const that is accessible to other files\n// file_2,cc\nextern const int bufSize;\t\t\t// same bufSize as defined in file_1.cc\n```"}
        {:block/id #uuid "660cece5-1d91-4fc4-b9cb-082742f86c06",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "**类型是**$\\mathsf{const}$**的对象不管是变量还是指针都不能修改**，牢记此原则即可。部分教材中讲的常量的引用，指向常量的指针还是常量指针都是把此简单的原则复杂化了。\n```C++\nconst int i = 1;\nint j = 1;\nconst int *p = &i;\t\t\t// p is a pointer to a const int i, the value of p can be modified\nconst int *const q = &i; \t// q is a CONST pointer to a const int i, the value of q can not be modified\nint *const r = &j;\t\t\t// r is a CONST pointer that always points to the int j, but the value of j can be modified through the pointer r\n```"}
        {:block/id #uuid "660cf016-c8fd-4ca1-bb51-c0e73d796bc7",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "660cf027-88d6-4424-8c5b-0390637f53c9",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "常量表达式：其值不可修改，编译时即可得到结果的表达式。"}
          {:block/id #uuid "660cf0be-9e93-4034-b0b5-73c463c40754",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "为判断初始值是否为常量表达式，C++11 允许将变量声明为$\\mathsf{constexpr}$ 类型以便编译器验证变量的初始值是否是一个常量表达式：\n```c++\nconstexpr int mf = 20;\t\t\t//20 is a constant expression\nconstexpr int limit = mf + 1;\t// mf + 1 is a constant expression\nconstexpr int sa = size();\t\t// ok only if size is a constexpr fuction\n```"}
          {:block/id #uuid "660cf256-13e3-44fa-9b3d-d99146166d80",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "引用和指针都能定义成$\\mathsf{constexpr}$，但其初始值受到严格限制。简单来说要求所引用或指向的对象存放于固定地址（如定义于所有函数体之外的对象或有效范围超出函数本身的变量）。"}
          {:block/id #uuid "660cf2e2-a883-48eb-b37f-e77b5b08293b",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "在$\\mathsf{constexpr}$声明中如果定义了一个指针，限定符$\\mathsf{constexpr}$仅对指针有效，而对其所指向的对象无效\n```c++\nconst int *p = nullptr;\t\t// p is a pointer to a const int\nconstexpr int *q = nullptr;\t// q is a const pointer to int\n```"}],
         :block/content "$\\mathsf{constexpr}$和常量表达式"}],
       :block/content "### $\\mathsf{const}$限定符"}
      {:block/id #uuid "660cf3eb-a1e6-4334-8665-6e1245428830",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "660cf3f9-49ad-4483-800d-57e387dfe321",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "660cf6fe-a803-4b4d-9378-e1574fba864f",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "有两种定义方式：\n```C++\ntypedef double wages;\t\t// wages is a synonym for double\nusing wages = double;\t\t// wages is a synonym for double\ntypedef doulbe *p;\t\t\t// p is a synonym for double*\n// expression below is valid\ntypedef double wages, *p;\t// equal to line1 plus line3\n```"}
          {:block/id #uuid "660cf5f6-f2c2-436e-9c2d-222e2459cfa6",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "值得注意的是：\n```C++\ntypedef char *p;\nconst p q = 0;\t// q is a const pointer to char rather than a pointer to a const char \n```"}],
         :block/content "类型别名"}
        {:block/id #uuid "660cf707-063e-4126-a132-a13dbfd5fbbc",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "660cf827-0e57-46de-8ba6-8a7cbc6c122f",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "$\\mathsf{auto}$类型说明符使编译器通过初始值来推测变量类型\n```C++\ndouble a = 1.0;\ndouble b = 1.0;\nauto c = a + b;\t\t// c is double\n```"}
          {:block/id #uuid "660cf73f-58ac-458b-904f-4599327efae8",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "660cf987-c88b-4da3-a0c0-6771db166b66",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "需注意，当$\\mathsf{decltype}$使用的表达式是一个引用时，其结果也是引用类型，而非引用的对象的类型。*（引用从来都作为其所引用对象的同义词出现，仅在*$\\mathsf{decltype}$*中是一个例外。）*"}],
           :block/content
           "$\\mathsf{decltype}$类型指示符可使编译器通过表达式的类型推测要定义的变量类型，但不会用该表达式的值初始化变量\n```C++\ndecltype(f()) = x;\t\t// sum has whatever type f returns \n```"}],
         :block/content
         "$\\mathsf{auto}$类型说明符和$\\mathsf{decltype}$类型指示符"}
        {:block/id #uuid "660cf673-fd13-499f-8a76-08a66d3f03bd",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content ""}],
       :block/content "### 处理类型"}
      {:block/id #uuid "660cfa41-bb26-47f8-983d-f7df8a9e02ca",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "660cfa47-8e6f-461a-a512-94bf686aa886",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "自定义数据结构实际上就是定义类，可以使用$\\mathsf{struct}$或$\\mathsf{class}$关键字，二者除默认访问权限不同外完全相同，以$\\mathsf{struct}$为例\n```C++\n#include <stirng>\nusing namespace std\nstruct Sales_data{\n  string bookNo;\n  unsigned units_sold = 0;\n  double revenue = 0.0;\n}; \t\t// note the semicolon\n```"}],
       :block/content "### 自定义数据结构"}],
     :block/content "## 变量和基本类型"}
    {:block/id #uuid "66138af6-0451-460f-8a03-84fe669a0182",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "6625fcd2-6db4-4424-8a39-346e261abd20",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "661233f3-5b61-40c0-b81c-7d980ed4febd",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "解引用和类成员访问顺序\n```c++\n#include <string>\n\nstd ::string s = \"dereferences and member access\";\nauto it = s.begin();\n\n(*it).empty(); \t\t// dereferences it and calls the member empty on the resulting object\n*it.empty();\t\t// error: attempts to fetch the member named empty from it but it is an iterator and has no member named empty\n```"}
        {:block/id #uuid "661233b8-4a61-4cfe-96ac-324d6d12f8d0",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "**-> 操作符是解引用并访问其对象(*it).mem的简化写法。**"}],
       :block/content "-> 操作符"}
      {:block/id #uuid "661255ea-0dca-4236-a53f-081dc35d3e8e",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "661255f0-6926-4ad7-8b61-0a696dda258c",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "条件运算符允许将简单的$\\mathsf{if-else}$逻辑嵌入到单个表达式中，格式如下：\n```c++\ncond ? expr1 : expr2;\n```\n首先求$\\mathsf{cond}$的值，为真则对$\\mathsf{expr1}$求值并返回，为假则对$\\mathsf{expr2}$求值并返回。"}
        {:block/id #uuid "661256c2-b44f-4555-b90e-e04f204c28a0",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "条件运算符允许嵌套。"}],
       :block/content "条件运算符（**?:**）"}
      {:block/id #uuid "66125e3c-f243-43e3-a02f-52cdea213150",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66125e3f-741d-49f3-b65d-f41a34ab3b61",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "$\\mathsf{break}$ 语句：只能出现在迭代语句或$\\mathsf{switch}$语句内部，负责终止离它最近的迭代（或$\\mathsf{switch}$）语句，并从这些语句之后的第一条语句开始执行。"}
        {:block/id #uuid "66125ebe-5dc7-43c0-be8b-dcad1da744e5",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "$\\mathsf{continue}$ 语句：终止最近循环中的当前迭代并立即开始下一次迭代；（只有当$\\mathsf{switch}$语句嵌套在迭代语句内部时，才能在$\\mathsf{switch}$里使用$\\mathsf{continue}$）"}
        {:block/id #uuid "66125f4b-9af6-4513-abe7-cf8417f9f60a",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "$\\mathsf{go to}$ 语句：不要在程序中使用。"}],
       :block/content "跳转语句"}],
     :block/content "## 数组、表达式和语句"}
    {:block/id #uuid "66138b4a-8616-49d5-98f4-017f09ba2ac6",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "661cf416-51d0-4ba8-b071-f2ba3e2e0d4d",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66128268-b00f-4c00-ab6a-3d7d213ae46d",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "函数的名字必须在使用之前**声明**，函数声明无需函数体，用分号代替即可\n```c++\nint read_voltage(char *data, int len){\n  int voltage = 0;\n  /* codes */\n  return voltage;\n}\t\t\t\t\t\t\t\t\t\t\t// DEFINES a funciton\nint read_voltage(char *data, int len);\t\t// DECLARES a function\n```"}
        {:block/id #uuid "66128482-2461-44f3-936d-79e7e8e4a9aa",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "函数三要素（返回类型，函数名和形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作**函数原型（function prototype)**。"}
        {:block/id #uuid "66135841-a3f5-40f4-9432-5a490caf9c00",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "**含有函数声明的头文件应该被包含到定义函数的源文件中。**"}
        {:block/id #uuid "661a2fa1-5b35-454f-8791-a237207039f4",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "16267a04-f0c6-4e06-a51a-eabb19595eb3",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "将函数指定为内联函数（$\\mathsf{inline}$），通常就是将它在每个调用点上“内联地”展开，可以有效消除函数运行时的开销\n```c++\ncout << shorterString(s1, s2) << endl;\n// probably is expanded during compilation into something like\ncout << (s1.size() < s2.size() ? s1 : s2) <<endl;\n```"}
          {:block/id #uuid "cb1d0e54-cb5a-4847-9d89-dd495aaeca02",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "想要将函数声明为内联函数，只需要在其返回类型前增加关键字$\\mathsf{inline}$即可\n```c++\ninline const string &shorterString(const string &s1, const string &s2)\n{\n  return s1.size() < s2.size() ? s1 : s2;\n}\n```"}
          {:block/id #uuid "2f58f4b6-4df1-49ac-a411-ab80a3e86beb",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "内联机制用于优化规模较小、流程直接、调用频繁的函数。大多数编译器都不支持内联递归函数，一个75行以上的函数也不大可能在调用点内联地展开。"}
          {:block/id #uuid "89e10067-afb4-41a3-b3a9-af4fdb639271",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "#+BEGIN_NOTE\n**内联函数和**$\\mathsf{constexpr}$**函数定义在头文件内**\n\n因为内联函数和$\\mathsf{constexpr}$函数可以在程序中多次定义，但要求某个给定的函数其多个定义必须完全一致，因此应定义在头文件内。\n#+END_NOTE"}],
         :block/content "内联函数（$\\mathsf{inline}$）"}],
       :block/content "### 函数声明"}
      {:block/id #uuid "66135c07-e65a-4722-8af5-ce8bf80edbf1",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66136045-0fdf-4f15-8ce3-26b67682fe8c",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "661284f6-8269-462c-b4b0-37c4c9f1844e",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "利用引用可以使得函数可以访问函数外部的变量\n```c++\n#include <iostream>\n\nvoid incValue(int &i){\n  ++i;\n  return;\n}\nvoid incValue();\nint main(){\n  for (int k=0;k<10;++k){\n    incValue(a);\n  }\n  std ::cout << a << std ::endl;\n  return 0;\n}\t\t\t// output '10'\n```"}
          {:block/id #uuid "6613606e-c57b-40c4-a551-de0bf109b5a4",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "661360df-c89d-4e78-9874-94e7467aed9b",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "一个比较两个$\\mathsf{string}$对象长度的函数，因为$\\mathsf{string}$对象可能会非常长，所以应该尽量避免拷贝它们，这时引用形参是比较明智的选择。\n```C++\n// compare the length of two strings\nbool isShorter(const string &s1, const string &s2)\n{\n  return s1.size() < s2.size();\n}\n```"}],
           :block/content
           "使用引用避免拷贝：拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）不支持拷贝操作。此时函数只能通过引用形参来访问该类的对象。"}
          {:block/id #uuid "661361d1-8d59-426d-901d-00b3036ab242",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "使用引用形参返回额外信息：一个函数只能返回一个值，若想要返回多个值一种方法是**定义一个新的数据类型**，让数据类型中包含多个值；另一种更简单的方法是给函数传入一个额外的引用实参，其本质还是**利用引用形参是函数访问函数外部变量**。"}],
         :block/content "引用传参"}
        {:block/id #uuid "66138bda-13b9-4030-97f5-c42d17d4ef52",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "66138c18-6117-4afa-b61c-c28728f10c8a",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "因为数组无法拷贝，且使用数组时会将其转换为指向首元素的指针，所以函数无法通过值的方式传递数组参数。但是函数的形参可以写成类似数组的形式：\n```c++\n// desipite appearences, these three declarations of print are equivalent\n// each function has a single parameter of type const int*\nvoid print(const int*);\nvoid print(const int[]);\t//shows the intent that the function takes an array\nvoid print(const int[10]);\t// dimension for documentation purposes (at best)\n```"}
          {:block/id #uuid "66138dc0-5326-42c5-8996-0fc03e9a8b40",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "66138e84-42b5-40e4-861a-f435bdb20109",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content
             "**使用标记指定数组长度**\n需要数组自身包含一个结束标记。以C style字符串为例，C style 字符串储存在字符数组中，最后一个字符后跟着一个空字符，函数在处理C style字符串时遇到空字符停止\n```C++\nvoid print(const char *cp){\n  if(cp)\t\t\t\t// if cp is not a null pointer\n    while(*cp)\t\t\t// so long as the character it points to is not a null character\n      cout << *cp++；\t// print the character and advance the pointer\n}\n```\n这种方法适用于数据中带有明显的结束标记且该标记不会与普通数据混淆的情况。"}
            {:block/id #uuid "66139081-bd50-4e87-8cad-9b8dcf2685eb",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content
             "**使用标准库规范**\n传递指向数组首元素和尾后元素的指针\n```C++\nvoid print(const int *beg, const int *end){\n  // print every element starting at beg up to but not including end\n  while (beg ! = end)\n    cout << *beg++ << endl;\t\t// print the current element and advance the pointer\n}\n```"}
            {:block/id #uuid "6613904d-2300-4e97-9e0e-db6b9199df6b",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content
             "**显式传递表示数组大小的形参**\nC 程序和过去的C++程序中经常使用这种方法\n```c++\n// const int ia[] is equivalent to const int* ia\n// size is passed explicitly and used to control access to element of ia\nvoid print(const int ia[], size_t size){\n  for (size_t i = 0; i ! = size； ++i){\n    cout << ia[i] << endl;\n  }\n}\n```"}],
           :block/content
           "由于数组是通过指针方式传递的，函数通常无法确定数组的具体长度，需要调用者提供一些额外的信息"}],
         :block/content "数组形参"}
        {:block/id #uuid "66139517-da92-465f-93b6-3f86195a4fc3",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "6613953f-d7e1-4c63-9d5a-dde4c74c1cf3",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "66139592-ef9e-41bc-a697-b5af4bc45756",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children
             [{:block/id #uuid "661395f6-1528-481a-ac5f-c9536b0c89b5",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "$\\mathsf{initializer\\_list}$类型定义在同名头文件中，提供的操作如下\n|||\n|initializer_list<T>  lst; |默认初始化，T类型元素的空列表|\n|initializer_list<T>  lst{a, b, c, ...};|lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const|\n|lst2(lst) or lst2 =lst|拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后原始列表和副本共享元素|\n|lst.size()|列表中的元素数量|\n|lst.begin()|返回指向lst中首元素的指针|\n|lst.end()|返回指向lst中为元素下一位置的指针|"}
              {:block/id #uuid "6613984b-09b4-41c5-8b2d-5f5bfe27afa8",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "$\\mathsf{initializer\\_list}$对象中的元素永远是常量值，无法改变。"}
              {:block/id #uuid "66139891-b22c-4676-bcca-19b77f0b5457",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "使用如下形式编写的输出错误信息的函数，使其可以作用于可变数量的实参\n```C++\nvoid error_msg(initializer_list<string> il){\n  for (auto beg = il.begin(); beg ! = il.end(); ++beg){\n    cout << *beg << \"  \";\n  }\n  cout << endl;\n}\n```"}
              {:block/id #uuid "6613977d-d39c-474a-9b3f-cc22d132c08c",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "如果想向$\\mathsf{initializer\\_list}$形参中传递一个值的序列，则必须把序列放在一对花括号内\n```C++\nstring expected = \"characters\";\nstring actual = \"sentenses\";\nif (expected ! = actual)\n  error_msg({\"functionX\", expected, actual});\nelse\n  error_msg({\"functionX\", \"okay\"});\n```"}
              {:block/id #uuid "66139a43-b696-4a8b-9075-382d177e5ea8",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "以上代码两次调用同一函数$\\mathsf{error\\_msg}$，但两次调用传递的参数数量不同。但**本质上还是只传递了一个实参，只是该形参类似于一个长度可变的列表**。"}],
             :block/content
             "如果所有实参类型相同，可以传递一个名为$\\mathsf{initializer\\_list}$的标准库类型；"}
            {:block/id #uuid "661395c6-4217-4045-8483-8de49bcf842a",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content "如果实参的类型不同，可以编写**可变参数模板**。"}],
           :block/content "无法预知应向函数传递几个实参时，可以通过以下两种方法编写能处理不同数量实参的函数"}],
         :block/content "可变形参\ncollapsed:: true"}
        {:block/id #uuid "6613ae05-a28e-4903-8f90-0add539eebe6",
         :block/properties {},
         :block/format :markdown,
         :block/children [],
         :block/content
         "#+BEGIN_NOTE\n**默认实参**\n\n通常应该在函数声明中指定默认实参，并将该声明放在合适的头文件中；\n\n一旦某个形参被赋予了默认值，那它之后的所有形参都必须有默认值；\n\n当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。\n#+END_NOTE"}],
       :block/content "### 函数传参"}
      {:block/id #uuid "6613cd1d-8f2b-4f8d-8172-b2abfee26266",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66149926-51ce-4208-8500-75a8b626479f",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "函数指针指向的是函数而非对象，和其他指针一样，函数指针指向特定的类型。而函数的类型由其形参类型和返回类型共同决定，与函数名无关。声明某个函数的指针，只需要用指针替换函数名即可\n```c++\nbool lengthCompare(const string &, const string &);\t\t\t// declares a function\nbool (*pf)(const string &, const string &);\t\t\t\t\t// declares a pointer to a function\nbool *pf(const string &, const string &);\t\t\t\t\t// declares a function named \"pf\" that returns a bool*\n```"}
        {:block/id #uuid "66149b22-898a-4d9e-85ea-89cd6b5b3697",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "当把函数名作为一个值使用时，该函数会自动转换为指针。可以直接使用指向某函数的指针调用该函数，无需提前解引用该指针\n```c++\n// 2 expressions below are equivalent\npf = lengthCompare;\npf = &lengthCompare;\n// calls the function lengthCompare\nbool b1 = pf(\"hello\", \"goodbye\");\nbool b2 = (*pf)(\"hello\", \"goodbye\");\nbool b3 = lengthCompare(\"hello\", \"goodbye\");\n```"}
        {:block/id #uuid "66149c8b-4758-4f30-85d7-dd64233802c9",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "和数组一样，不能定义函数类型的形参，但是形参可以是指向函数的指针。可以直接将函数作为实参使用，此时它会自动转化成指针\n```c++\n// the third parameter is a function type that will convert to a pointer automatically\n// third parameter ia a function type and is automatically treated as a pointer to function\nvoid useBigger(const string &s1, const string &s2,\n              bool pf(const string &, const string &));\n// equivalent declaration: explicitly define the parameter as a pointer to function\nvoid useBigger(const string &s1, const string &s2,\n              bool (*pf)(const string &, const string &));\n// automatically converts the function lengthCompare to a pointer to function\nuseBigger(s1, s2, lengthCompare);\n```"}
        {:block/id #uuid "6614a395-05c2-48fa-bc2c-4ee65485dacd",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "$\\mathsf{typedef}$和$\\mathsf{decltype}$可以极大简化使用函数指针的代码\n```c++\n// Func and Func2 have function type\ntypedef bool Func(const string &, const string &);\ntypedef decltype(lengthCompare) Func2;\t\t// equivalent type\n// FuncP and FuncP2 have poitner to function type\ntypedef bool (*FuncP)(const string &, const string &);\ntypedef decltype(lengthCompare) *FuncP2;\t// equivalent type\n// equivalent declarations of useBigger with type aliases\nvoid useBigger(const string &, const string &, Func);\nvoid useBigger(const string &, const string &, FuncP);\t// equivalent declaration\n```"}
        {:block/id #uuid "6614a60b-169b-4d16-ae2f-0f3744c851e9",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "同样的，一个函数不能返回一个函数类型，但可以返回一个指向函数的指针类型。但是，编译器不会自动将返回的函数类型转换为指针，必须显式地定义返回指针类型\n```C++\nusing F = int(int*, int);\t\t\t// F is a function type, not a pointer\nusing PF = int (*)(int*, int); \t\t// PF is a pointer to function type\nPF f1(int);\t\t\t\t\t\t\t// ok: PF is a pointer to function; fl returns a pointer to function\nF f1(int);\t\t\t\t\t\t\t// error: F is a function type; fl can't return a function\nF *f1(int);\t\t\t\t\t\t\t// ok: explicitly specify that the return tyhpe is a pointer to function\nint (*f1(int))(int*, int);\t\t\t// ok: decaration of f1 without aliases\nauto f1(int) - > int(*)(int*, int);\t// ok: trailing return\n```"}
        {:block/id #uuid "661a2eed-7579-4544-a938-fe4d02b7336b",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "定义函数指针类型：\n```c++\ntypedef int (*pFunc_t)(char *frame, int len);\t\t// defines a type named \"pFunc_t\" point to a function\nint read_voltage(char *data, int len){\n  int voltage = 0;\n  /* codes */\n  return voltage;\n}\nint main(){\n  pFunc_t pHandler = read_voltage;\n}\n```\n$\\mathsf{int}$为函数返回值，括号内为形参。"}],
       :block/content "### 函数指针"}
      {:block/id #uuid "66138df9-7a38-426c-b2f2-53106899afbd",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "6613a377-6604-432c-bac8-c12a58d18b17",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "如果在同一作用域内的几个函数名字形同但形参不同，则称之为重载函数。调用函数时，编译器会通过传入实参的类型推断想要的是哪个函数。\n```c++\nvoid pirnt(const char *cp);  \t\t\t\t\t// func1\nvoid pirnt(const int *beg, const int *end);\t\t// func2\nvoid pirnt(const int ia[], size_t size);\t\t// func3\n\nint j[2] = {0, 1};\nprint(\"Hello World\");\t\t// calls func1\nprint(begin(j), end(j)); \t// calls func2\nprint(j, end(j)-begin(j));\t// calls func3\n```"}
        {:block/id #uuid "6613ac72-e2a9-4b3a-8556-efb65723c347",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "#+BEGIN_NOTE\n只重载确实非常相似的操作，重载后会丢失名字中本来拥有的信息。是否重载函数要看哪个更容易理解。\n#+END_NOTE"}
        {:block/id #uuid "6613acc9-b202-4041-b212-350cd3702768",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "6613acde-17e4-4bb9-bb66-0a2e5e802b99",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "以函数$\\mathsf{shorterString}$为例\n```C++\n\\\\ returns a reference to the shorter of two strings\nconst string &shorterString(const string &s1, const string &s2){\n\treturn s1.size() < = s2.size() ? s1 : s2;\n}\n```\n这个函数的参数和返回类型都$\\mathsf{const\\  string}$的引用。我们可以对两个非常量的$\\mathsf{string}$实参调用这个函数，但返回的结果依然是$\\mathsf{const\\  string}$。因此可以通过$\\mathsf{const\\  string}$重载函数获得一个新的$\\mathsf{shorterString}$函数，当它的实参不是常量时，得到的结果是一个普通的引用\n```C++\nstring &shorterString(string &s1, string &s2){\n  auto &r = shorterString(const_cast<const string&>(s1), \n                          const_cast<const string&>(s2));\n  return const_cast<string&>(r);\n}\n```"}
          {:block/id #uuid "6613ae09-3cde-4c5e-81a0-88b9a9be72b0",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content ""}],
         :block/content "$\\mathsf{const\\_cast}$和重载"}],
       :block/content "### 函数重载"}
      {:block/id #uuid "6625fcd2-83d6-4b33-8032-da7eb6ca7973",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content ""}
      {:block/id #uuid "661361ab-a669-4e9c-bfee-93cfed1b7799",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "6613a0d5-9ff5-4fbf-beeb-37bdfd2a12e2",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "尾置返回类型跟在形参列表后以一个->符号连接，在本该出现返回类型的位置放置一个$\\mathsf{auto}$\n```c++\n// func takes an int argument and returns a pointer to an array of ten ints\nauto func(int i) - > int(*)[10];\n```"}],
       :block/content "尾置返回类型（trailing return type）"}
      {:block/id #uuid "661a2d99-70e7-4b79-aa32-0f4ddc54723d",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content ""}],
     :block/content "## 函数"}
    {:block/id #uuid "661cf416-8043-4fdf-97aa-c4a877f092e8",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "54dcef9f-5709-4cd5-8a2b-9d94a0780005",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "#+BEGIN_NOTE\nC++对于类的相关称呼令人难以接受，为此在后续笔记中，将使用Python语言中对于类的相关称呼：\nC++：数据成员        =>  Python：属性\nC++：成员函数        =>  Python：方法\nC++：类类型对象   =>  Python：类的实例\n#+END_NOTE"}
      {:block/id #uuid "e5a9ff95-14e7-45c6-a4d8-1429ff77bf6e",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "bd483c2f-f8f4-4a70-b01c-a7e6d291ae54",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "以类$\\mathsf{Sales\\_data}$为例，在其中定义一个方法$\\mathsf{isbn}$，用来返回属性$\\mathsf{bookNo}$\n```C++\nstruct Sales_data{\n  std ::string isbn() const {return bookNo;}   \t// defines a method\n  Sales_data& combine(const Sales_data&);\t\t// declares a method that is defined outside the class\n  std ::string bookNo;\t\t\t\t\t\t\t// defines a property\n}\n// Insttantiates the class \"Sales_data\" and calls the method \"isbn\"\nSales_data total;\nstd ::string book_number = total.isbn();\nunsigned units_sold = 0;\ndouble revenue = 0.0;\n```\n调用类的方法实际上通过一个名为$\\mathsf{this}$的隐式形参来访问调用它的那个实例。如上述代码，编译器首先将$\\mathsf{total}$的地址传递给隐式的形参$\\mathsf{this}$，然后通过$\\mathsf{this}$将该地址传递给方法$\\mathsf{isbn}$。因此$\\mathsf{this}$实际上就是指向该实例的指针。所以可以将$\\mathsf{isbn}$定义为如下形式（虽然没有必要）\n```c++\nstd ::string isbn() const {return this - > bookNo;}\nstd ::string isbn() const {return (*this).booklNo;}\t  // equivalent definition\n```"}
        {:block/id #uuid "ea64973f-9f40-4c2d-b0fd-5844491be831",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "可以注意到，方法的定义中，在形参列表后紧跟着一个关键则$\\mathsf{const}$，其作用是修改隐式$\\mathsf{this}$指针的类型。在默认情况下，$\\mathsf{this}$的类型是指向实例类型非常量版本的常量指针，如在$\\mathsf{Sales\\_ data}$中，其类型是$\\mathsf{Sales\\_ data *const}$。增加关键字$\\mathsf{const}$后，其类型则变为$\\mathsf{const Sales\\_ data *const}$，是一个指向常量的常量指针。像这样使用$\\mathsf{const}$的方法（成员函数）被称为常量方法（常量成员函数）。*注：括号内的称呼为C++原本称呼。*"}
        {:block/id #uuid "796c9cf0-db0a-44e1-ad70-b4911a2f697b",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "类的方法必须在类的内部声明，但是可以在类的外部定义。其定义必须与其声明匹配，即返回类型，参数列表和方法名都必须与声明相同。如果方法被声明为常量方法，其定义也必须在参数列表后明确指定$\\mathsf{const}$属性。同时，类外定义方法的名字必须包含它所属的类名\n```c++\ndouble Sales_data ::avg_price() const {\n  if (units_sold)\n    return revenue/units_sold;\n  else\n    return 0;\n} // defines a method outside the class\n```\n很显然，此方法使用$\\mathsf{revenue}$和$\\mathsf{units\\_sold}$时，隐式地使用了$\\mathsf{Sales\\_data}$的 属性。"}
        {:block/id #uuid "d4913ef1-af30-4496-9517-31f734e217df",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "可以定义一个返回$\\mathsf{this}$对象的函数\n```c++\nSales_data & Sales_data ::combine(const Sales_data &rhs){\n  units_sold += rhs.units_sold;\n  revenue += rhs.revenue;\n  return *this;\n}\t\t// returns a reference to the instance that calls the method\n```"}
        {:block/id #uuid "176167de-1e38-43f3-8303-26506cfe88ce",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "8ad64b2e-b20d-42ec-9330-07c7d618134a",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "类可以自定义某种类型在类中的的别名。别名和其他成员一样，存在访问限制。\n```c++\nclass Screen{\npublic:\n  typedef std ::string ::size_type pos;\t\t// defines alias\n  using pos = std ::string ::size_type;\t\t// equivalent defination of alias\nprivate:\n  pos cursor = 0;\n  pos height = 0, width = 0;\n  std ::string contents;\n}\n```"}],
         :block/content "类中类型别名"}
        {:block/id #uuid "360aabf3-b7bf-40cc-a000-c17b82ce828b",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "定义在类内的方法是自动内联的，可以在类内定义或声明式显式地声明内联，也可以在类外部定义方法时用$\\mathsf{inline}$修饰方法的定义。为了便于理解，请只在类外部定义方法时说明$\\mathsf{inline}$内联。"}
        {:block/id #uuid "dabf716c-f962-4ddd-a3cf-2104de227531",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "有时需要通过一个$\\mathsf{const}$方法修改类的某个属性，通过在属性的声明中加入$\\mathsf{mutable}$关键字即可。"}],
       :block/content "### 方法（成员函数）的定义"}
      {:block/id #uuid "bd7558df-d4ad-475e-bde3-75619d110eb0",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "9c21747d-9491-434b-9714-e77639398414",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "指类需要用到的一些辅助函数，其定义的操作从概念上属于类的接口的组成部分，但它们实际上并不属于类本身。"}
        {:block/id #uuid "968fabdd-2b53-4489-b415-ad647a621849",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "和定义其他函数一样，通常把函数定义和函数声明分离开。如果函数概念上属于类但不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内，以保证用户使用接口的任一部分都只需要引入一个文件。"}],
       :block/content "### 定义类相关的非方法函数（接口函数）"}
      {:block/id #uuid "4fb818d4-5474-4ab7-8e76-dabda22523ef",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "64aca7d3-4668-4f1f-8a40-3270c8082aa4",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "每个类都分别定义了其属性被初始化的方式，类通过一个或者几个特殊的方法来控制其对象的初始化过程，这些函数称为构造函数（constructor）。构造函数会在类被实例化的时候运行，初始化类的属性。"}
        {:block/id #uuid "6ec93a6a-f24d-4944-ac49-c4abdfbc6d10",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "构造函数名字和类名字相同，无返回类型；一个类可以通过重载包含多个构造函数。"}
        {:block/id #uuid "b633bbe0-3efa-4215-a006-36db896f6830",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "不同于其他方法，构造函数不能被声明成$\\mathsf{const}$，当创建类的一个$\\mathsf{const}$对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性 。因此构造函数在$\\mathsf{const}$对象的构造过程中可以向其写值。"}
        {:block/id #uuid "6216ee7c-a171-461a-9494-43589839f70b",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "如果没有显式地定义构造函数，编译器会为类隐式地创建一个**合成的默认构造函数**，类则会通过该合成的默认构造函数来进行**默认初始化**。合成的默认构造函数仅适用于非常简单的类。"}
        {:block/id #uuid "82e9ec60-9863-4c04-bfc6-6b88e845a336",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "0ce1049a-03b4-400e-b064-d87d733e2e36",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content
           "第一个构造函数不接受任何实参，所以是一个默认构造函数；在后面增加了$\\mathsf{=default}$来要求编译器生成构造函数。其中$\\mathsf{=default}$可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。如果$\\mathsf{=default}$在类的内部，则默认构造函数是内联的；如果在类的外部，则不是内联的。"}
          {:block/id #uuid "1ef1eedd-126f-4dea-bd2c-c714655ea391",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content
           "第二个构造函数出现了冒号以及冒号和花括号之间的代码，称为**构造函数初始值列表**，负责为新创建的对象的一个或几个属性赋初值。花括号之间为空，是因为除赋初值外不执行其他操作。"}
          {:block/id #uuid "63808469-f70b-439a-8108-a1e8959208f8",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content
           "第三个构造函数没有构造函数初始值列表，因为其不给直接属性赋初始值，而是调用了$\\mathsf{read}$函数给属性赋初值。"}
          {:block/id #uuid "2a487bb2-73ef-4404-b8c2-792d622001cf",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "没有通过初始值列表或者执行操作进行初始化的属性将通过类内初始值（如果有）初始化，或者执行默认初始化。"}],
         :block/content
         "定义$\\mathsf{Salse\\_data}$的构造函数\n```c++\nstruct Sales_data{\n  // adds a constructor\n  Sales_data() = default;\t\t\t\t\t\t\t\t\t// defines constructor 1\n  Sales_data(const std ::string &s, unsigned n, double p):\n  \t\t\tbookNo(s), units_sold(n), revenue(p*n){}\t\t// defines constructor 2\n  Sales_data(std ::istream &);\t\t\t\t\t\t\t\t// declares constructor 3\n  /* former definition */\n};\nSales_data ::Salse_data(std ::istream &is){\n  read(is, *this);\n}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// defines constructor 3\n```\n上述代码定义并重载了3个构造函数。其中"}
        {:block/id #uuid "04537f8d-6044-46ec-99c7-62af5637e559",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "类属性的初始化和赋值有区别。如果先定义属性，再进行赋值，在类实例化的时候会先进行默认初始化，再进行赋值。这种区别事关底层效率问题，而且一些类型的成员必须被初始化，默认初始化会产生难以预料的问题。因此建议养成**使用构造函数初始化**的习惯。"}
        {:block/id #uuid "1a43d1d0-4a57-4142-9c4f-04bbab6c8b75",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "4c6ba40f-d6d4-46a6-a514-67c8369a698e",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "委托构造函数允许构造函数使用其他构造函数完成自身初始化过程，也就是构造函数间的相互调用\n```C++\nclass DeleCon{\npublic:\n  \t// non-delegating constructor\n\tDeleCon(std ::string s, unsigned u, double d) : \n  \t\t\tprop1(s), prop2(u), prop3(u*d)){}\t\t\t\t\t// constructor 0\n  \t// delegating constructor\t\t\n  \tDeleCon() : DeleCon(\"\", 0, 0){}\t\t\t\t\t\t\t\t// constructor 1\n  \tDeleCon(std ::string s) : DeleCon(s, 0, 0){}\t\t\t\t// constructor 2\n  \tDeleCon(std ::istream &is) : DeleCon(){read(is, *this)}\t\t// constructor 3\n}\n```\n其中，构造函数0是非委托构造函数；构造函数1是默认构造函数，其委托了构造函数0；同时，构造函数2也委托了构造函数0；构造函数3则委托了默认构造函数1。"}],
         :block/content "委托构造函数（delegating constructor）"}],
       :block/content "### 构造函数"}
      {:block/id #uuid "aa9656af-7676-4e7e-9e62-0b277b490262",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "661cf416-186e-43e2-8bc3-eab2f502063a",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "bdd22d33-e432-4175-b138-c77db0aa70f6",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content
           "定义在$\\mathsf{public}$说明符之后的属性在整个程序内可被访问，$\\mathsf{public}$属性定义类的接口；"}
          {:block/id #uuid "a59ee253-d916-47ae-a71d-bcbf856ee1c9",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content
           "定义在$\\mathsf{private}$说明符之后的属性可以被类的方法访问，但是不能被使用该类的代码访问，$\\mathsf{private}$部分封装了类的实现细节。"}
          {:block/id #uuid "1a689f10-afaf-4408-86bb-846d30c1c675",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "再次定义类$\\mathsf{Sales\\_data}$\n```c++\nclass ClassTest{\npublic:\n    ClassTest() = default;\n    const int *get_tt() const;    \nprivate:\n    int tt = 99;\n};\n\nconst int* ClassTest ::get_tt() const {\n    const int *p = &tt;\n    return p;\n}\n\nint main(){\n    ClassTest ct;\n    const *p = ct.get_tt();\n    cout << *p << endl;\t\t\t\t\t// ok: tt can be accessed by method\n\tcout << ct.tt << endl;\t\t\t\t// error: tt cannnot be accessed by function\n    return 0;\n}\n```"}
          {:block/id #uuid "2eb959d1-5ad9-4dd2-8f63-c016ed360118",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "使用$\\mathsf{class}$和$\\mathsf{struct}$定义类的区别在于，使用$\\mathsf{class}$关键字则默认的访问权限是$\\mathsf{private}$，使用$\\mathsf{struct}$关键字则默认的访问权限是$\\mathsf{public}$。"}],
         :block/content
         "使用访问说明符（access specifiers）加强类的封装性：\ncollapsed:: true"}
        {:block/id #uuid "495b3844-aca6-4494-bb82-217b0d74536a",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "58e465ed-a3ff-4a33-acbb-d43d36fb13d0",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的**友元（friend）**，只需要增加一条以$\\mathsf{friend}$开头的函数声明语句即可\n```c++\nclass Sales_data{\nfriend Sales_data add(const Sales_data&, const Sales_data&);\nfriend std ::istream &read(std::istream&, Sales_data&);\nfriend std ::ostream &print(std::ostream&, const Sales_data&);\n/*\n* omit as before\n*/\n}\n```"}
          {:block/id #uuid "a6b29f87-4677-49be-88d9-9a04c38e4a80",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "虽然许多编译器不要求，但建议在定义类的头文件中，在友元声明之外再专门对函数进行一次声明。"}
          {:block/id #uuid "f2121676-fe41-46d8-8f4c-6b6243842ba6",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "如下代码可以编译通过且正常输出\n```c++\n// ok: outputs 99\nclass ClassTest{\nfriend void print(const ClassTest& ct);\npublic:\n    ClassTest() = default; \nprivate:\n    int tt = 99;\n};\n\nvoid print(const ClassTest& ct){\n    cout << ct.tt << endl;\n    return;\n}\nint main(){\n    ClassTest ct;\n    print(ct);\n    return 0;\n}\n```\n但如果用函数$\\mathsf{print}$直接访问$\\mathsf{ClassTest}$的属性$\\mathsf{tt}$则无法访问#？\n```c++\nclass ClassTest{\nfriend void print(const int);\npublic:\n    ClassTest() = default;  \nprivate:\n    int tt = 99;\n};\n\nvoid print(const int i){\n    cout << i << endl;\n    return;\n}\nint main(){\n    ClassTest ct;\n    print(ct.tt);\n    return 0;\n}\n```\n因为函数$\\mathsf{print}$作为类$\\mathsf{ClassTest}$的友元，可以在函数内部访问$\\mathsf{ClassTest}$的$\\mathsf{private}$属性，但是$\\mathsf{print(ct.tt)}$实际上类似如下代码\n```c++\nint temp = ct.tt;\t\t// cannot access the property tt\nprint(temp);\n```\n通过指针或者引用同样无法访问#。"}
          {:block/id #uuid "ecbb03ea-7a4a-4955-b392-5cf5b9d4505f",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "类可以把其他类或者其他类的方法定义成自己的友元。一旦一个类指定了一个友元类，则友元类的函数可以访问此类包括非共有成员在内的所有成员。需要注意的是，友元关系不具有传递性，类A是类B的友元，类B是类C的友元，并不代表类A可以访问类C的相关成员。"}
          {:block/id #uuid "078f5dd6-6d9e-4593-91f2-85ed3217e2e4",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "7994cc0b-d667-4923-bdcb-7d599a2ed663",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content
             "首先定义$\\mathsf{Window\\_mgr}$类，并在其中声明$\\mathsf{clear}$方法，但不能定义它；"}
            {:block/id #uuid "73b7964d-beff-433e-8525-98ae3fdfb0fb",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content
             "接下来定义$\\mathsf{Screen}$类，包括对于$\\mathsf{clear}$方法的友元声明；"}
            {:block/id #uuid "3c681dd6-a8a8-4716-b322-7a353e007f2e",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content
             "最后定义$\\mathsf{clear}$方法，此时它才可以使用$\\mathsf{Screen}$类的成员。"}],
           :block/content
           "想要令某个方法作为友元必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。为什么，第一、二步能否互换 #？ \n```C++\nclass Window_mgr{\npublic:\n    using ScreenIndex = std ::vector<Screen>  ::size_type;\n    void clear(ScreenIndex);\nprivate:\n    std ::vector<Screen> screens{Screen(24, 80, ' ')};\n};\nclass Screen{\n  friend void Window_mgr ::clear(ScreenIndex);\n  /*\n  ...\n  */\n};\nvoid Window_mgr ::clear(ScreenIndex i){\n  Screen &s = screens[i];\n  s.contents = string(s.height * s.width, ' ');\n}\n```\n注意，上述代码中$\\mathsf{Window\\_mgr}$类中无法类内初始化$\\mathsf{Screen}$，因为还没有定义$\\mathsf{Screen}$类。如果第一、二步互换，则无法对$\\mathsf{clear}$方法进行友元声明，因为其参数类型$\\mathsf{ScreenIndex}$是在$\\mathsf{Window\\_mgr}$类中定义的 #。 \n以上述代码为例"}],
         :block/content "友元（friend）\ncollapsed:: true"}],
       :block/content "### 访问控制与封装"}
      {:block/id #uuid "3d80ae1c-7fab-49df-827c-0e725346e726",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "bbec9e3b-00b8-409c-aaae-f948b62a1a9f",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "返回一个类和返回一个类的引用导致函数产生的行为是完全不同的\n```c++\nScreen & Screen ::set(char c){\n  contents[cursor] = c;\n  return *this;\n}\nScreen & Screen ::set(pos row, pos col, char c){\n  contents[row*width + col] = c;\n  return *this;\n}\nScreen & Screen ::move(pos row, pos col){\n  pos \n  return *this;\n}\n```\n当返回$\\mathsf{*this}$时，返回的是调用方法的类的实例的引用，会对类的实例本身进行修改。如果返回类型为$\\mathsf{Screen}$，则会生成一个$\\mathsf{Screen}$类的副本，原来调用$\\mathsf{set}$方法或者$\\mathsf{move}$方法的实例将不会发生改变。"}
        {:block/id #uuid "1ab571e8-e1c0-4fa7-9705-d1215ae94539",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "b5c88c77-957a-4d04-a610-451f7227e217",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "由于非常量版本的方法对于常量对象是不可用的，所以只能在一个常量对象上调用$\\mathsf{const}$方法；而且，虽然可以在非常量对象上调用常量版本的方法，但显然此时非常亮版本更为合适。"}
          {:block/id #uuid "ffbc1091-a5f5-420f-8824-f660e3de038c",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "如下代码中，定义了一个名为$\\mathsf{do\\_display}$的方法，用于执行实际操作，所有的$\\mathsf{display}$操作都将调用这个函数，然后返回执行操作的对象\n```c++\nclass Screen{\npublic:\n  Screen & display(std ::ostream &os)\n  \t\t\t\t\t{do_display(os); return *this;}\n  const Screen & display(std ::ostream &os) const\n  \t\t\t\t\t{do_display(os); return *this;)}\nprivate:\n  void do_display(std ::ostream &os) const {os << contents;}\n};\nScreen sc1(5,3);\nconst  Screen sc2(5,3);\nsc1.display(cout);\t\t// calls non-const version\nsc2.display(cout);\t\t// calls const version\n```\n可以看到，当我们在某个实例上调用$\\mathsf{display}$时，该实例自身决定了应该调用常量还是非常量版本。"}
          {:block/id #uuid "effd9525-0117-4270-a799-dd89841e4ff2",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "#+BEGIN_NOTE\n**对于共享代码使用私有方法功能**\n\n以基于$\\mathsf{const}$的重载为例，定义了一个单独的$\\mathsf{private}$方法$\\mathsf{do\\_display}$。\n\n首先是为了避免在多处使用相同代码，如果不定义额外的私有方法，则需要在两个重载函数中重复相同的代码。当需要修改的时候，需要进行两次完全相同的修改。这在一个非常复杂的类中是非常困难的。而使用私有方法仅需在私有方法中修改一次；\n\n其次，可以有效减小代码量，提升代码可读性；\n\n另外，定义在类内的私有方法是内联的，调用不会产生额外的开销。\n\n{{embed ((66162836-5171-419b-af33-7e6749c9f2aa))}} \n#+END_NOTE"}
          {:block/id #uuid "b1aaffc7-b673-425b-a0f5-668129d51809",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "5d6afd8c-bd71-4979-a4ff-8cdb73f975c6",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "有的时候希望类的某个成员与类保持关联，而非与实例保持关联。比如一个银行账户需要一个属性表示当前的利率，实际上，没有必要每个银行账户类的实例都储存一个利率信息。而且当利率变化，希望每个实例都能使用新值。"}
            {:block/id #uuid "791022e2-173e-40c2-b59a-30adff1695d4",
             :block/properties nil,
             :block/format :markdown,
             :block/children
             [{:block/id #uuid "96595fe5-e29a-4cbc-954d-f0adb4e71e20",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "通过在成员的声明前加上关键字$\\mathsf{static}$使得其与类关联在一起。\n```c++\nclass Account{\npublic:\n  void calculate(){amount += amount * interestRate;}\n  static double rate() {return interestRate;}\nprivate:\n  std ::string owner;\n  double amount;\n  static double interestRate;\n  static double initRate();\n};\nvoid Account::rate(double newRate){\n  interestRate = newRate;\n  return;\n}\ndouble Account ::interestRate = initRate();\n```\n以上代码中$\\mathsf{Acount}$类的实例中只包含$\\mathsf{owner}$和$\\mathsf{amount}$属性，而不包含和静态对象$\\mathsf{interestRate}$相关的数据。只存在一个$\\mathsf{interestRate}$对象被所有$\\mathsf{Acount}$类的实例共享。"}
              {:block/id #uuid "09de93d9-6553-4958-96e9-de628136786f",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "类似地，静态方法也不与任何实例绑定在一起，也不包含$\\mathsf{this}$指针。作为结果，静态方法不能声明成$\\mathsf{const}$，也不能在$\\mathsf{static}$函数体内使用$\\mathsf{this}$指针。这以限制既适用于$\\mathsf{this}$的显式使用，也对调用非静态成员的隐式使用有效。"}
              {:block/id #uuid "e5cbc315-46a0-44aa-9b9b-ff149da47517",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "对于静态方法，既可以在类内定义也可以在类外定义。但是需注意，在类外定义静态方法时，不能重复$\\mathsf{static}$关键字，该关键字只出现在类内部的声明语句。"}
              {:block/id #uuid "610dcc66-6679-4acb-b51c-bd9ed635d735",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "因为静态属性不属于任何一个实例，因此其并不是在实例化时被定义的，这也意味着静态属性不能被类的构造函数初始化。相反的，必须在类的外部定义和初始化每个静态属性。而类似于全局变量，静态属性定义在任何方法或者函数之外，一旦被定义，将一直存在于程序的整个生命周期中。"}],
             :block/content "静态成员的声明与定义\ncollapsed:: true"}
            {:block/id #uuid "f34492db-6120-4778-9f52-17ac2f85fe69",
             :block/properties nil,
             :block/format :markdown,
             :block/children
             [{:block/id #uuid "54991873-99dd-454c-8878-e87540eebb3f",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "可以使用作用域运算符直接访问静态成员，也可以通过类的实例、引用或者指针来访问\n```c++\ndouble r;\nr = Account :: rate();\t// access a static member using the scope operator\nAcount ac1;\nAcount *ac2 = &ac1;\n// equivalent ways to call the static member rate function\nr = ac1.rate();\t\t\t// through an Account instance or reference\nr = ac2 - > rate();\t\t// through a pointer to an Account instance\n```"}
              {:block/id #uuid "0957da75-77ef-4f8d-9a06-3e9ae511d3fe",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content "成员函数不用通过作用域运算符即可直接使用静态成员。"}],
             :block/content "静态成员的使用\ncollapsed:: true"}],
           :block/content "类的静态成员\ncollapsed:: true"}],
         :block/content "基于常量$\\mathsf{const}$的重载\ncollapsed:: true"}],
       :block/content "### 返回类型问题"}],
     :block/content "## 类"}
    {:block/id #uuid "661a3305-dbcd-436b-81b6-7b48bfecdfa9",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "661cf416-651e-44c5-808b-3e3c1f6467b3",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "661cf416-9a38-44cb-8e1b-55cc812ecd26",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "66189c96-dd9f-421c-a191-7334063c7d70",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "向容器添加或删除元素；"}
          {:block/id #uuid "66189caa-4de4-47a9-ad53-6b548e0242e5",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "非顺序访问容器中的元素。"}
          {:block/id #uuid "66189cb6-fe7c-401c-93b8-6cbbb3110f4d",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "|容器|性能|\n|$\\mathsf{vector}$|可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢|\n|$\\mathsf{deque}$|双端队列。支持快速随机访问。在头尾位置插入/删除速度很快|\n|$\\mathsf{lsit}$|双向链表。只支持双向顺序访问。在$\\mathsf{list}$中任何位置进行插入/删除操作速度都很快|\n|$\\mathsf{forward\\_list}$|单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快|\n|$\\mathsf{array}$|固定大小数组。支持快速随机访问，不能添加或删除元素|\n|$\\mathsf{string}$|与$\\mathsf{vector}$相似的容器，但专门用于保存字符。随机访问快，在尾部插入/删除速度快|"}],
         :block/content
         "顺序容器有很多种，提供了控制元素储存和访问顺序的能力。所有的顺序容器都提供了快速顺序访问元素（遍历）的能力，但是其在以下方面有不同的性能侧重：\ncollapsed:: true"}
        {:block/id #uuid "66189df2-c045-423f-b373-6f611a7f19cc",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "661cf416-a3c6-4d29-b987-176e30be78cf",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content ""}
          {:block/id #uuid "6625fcd2-c788-45da-925b-c618bad8fdd3",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content ""}],
         :block/content
         "collapsed:: true\n#+BEGIN_NOTE\n**顺序容器选择**\n\n新标准库的容器比旧版本快得多，现代C++应该使用标准库容器，而不是更原始的数据结构，如内置数组。\n\n如果没有特殊需求，选择$\\mathsf{vector}$。\n\n如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则\n        —— 首先，确定是否真的需要在容器中间添加元素。当处理输入数据时，通常可以很容易地向$\\mathsf{vector}$追加数据，然后再调用标准库的$\\mathsf{sort}$函数来重排容器中的元素，从而避免在在中间位置添加元素。\n        —— 如果必须在中间位置添加元素，考虑在输入阶段使用$\\mathsf{list}$，一旦输入完成，将$\\mathsf{list}$中的内容拷贝到一个$\\mathsf{vector}$中。\n#+END_NOTE"}],
       :block/content "### 顺序容器（sequential container）"}
      {:block/id #uuid "6625fcd2-ef12-420f-b7fe-9e546236853c",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "6618a397-0488-47ff-860b-31c2983c0f82",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "静态内存：用于保存局部$\\mathsf{static}$对象，类$\\mathsf{static}$对象以及定义在函数之外的任何变量。其内存在使用之前分配，在程序结束时销毁。"}
        {:block/id #uuid "6618a3f6-aecc-44e4-a240-f0b81b302f98",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "栈内存：用来保存定义在函数内的非$\\mathsf{static}$对象，仅在其程序块运行时才存在。"}
        {:block/id #uuid "6618a427-0bf9-4445-bcb7-6c7ac7c803f3",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "动态内存：这部分内存被称为**自由空间（free store）**或**堆（heap）**。程序用堆来储存**动态分配（dynamically allocate）**的对象）——即那些在程序运行时分配的对象。动态对象的生存期由程序控制，当动态对象不再使用后，必须显式地销毁他们。"}
        {:block/id #uuid "6618c6ad-61b4-4d36-92f0-f9ff3868c024",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "6618c6bb-2ce3-460e-aca5-a762b7b53e0f",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content "程序不知道自己需要使用多少对象；"}
          {:block/id #uuid "6618c6ca-21dc-4d6d-a31a-c147ee1b2715",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content "程序不知道所需对象的准确类型；"}
          {:block/id #uuid "6618c6d8-7a33-41d3-b105-adc035d7c5aa",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content "程序需要在多个对象间共享数据。"}],
         :block/content "程序使用动态内存处于以下三种原因之一："}
        {:block/id #uuid "6618a4cd-af7c-4469-87cc-e0597f40731c",
         :block/properties {:heading 4},
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "6618a502-2ac6-4d4f-994d-b7b37e9adb75",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "6618a515-7860-4783-a451-169193b08eeb",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "$\\mathsf{new}$：在动态内存中为对象分配空间并返回一个指向该对象的指针，可以选择对对象进行初始化；"}
            {:block/id #uuid "6618a53c-504f-45f6-aee1-42b6bee317fa",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "$\\mathsf{delete}$：接受一个动态对象的指针，销毁该对象，并释放与之相关的内存。"}],
           :block/content "动态内存的管理通过一对运算符完成：\ncollapsed:: true"}
          {:block/id #uuid "6618a626-ee21-4cb5-aa1d-3e3429801898",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "为了更容易且更安全的使用动态内存，新标准库提供两种**智能指针（smart pointer）**类型来管理动态对象。其行为类似普通指针，但是可以负责自动释放所指的对象。$\\mathsf{shared\\_ptr}$允许多个指针指向同一个对象；$\\mathsf{unique\\_ptr}$则“独占”所指向的对象。另外，标准库中还定义了一个名为$\\mathsf{weak\\_ptr}$的伴随类，是一种弱引用，指向$\\mathsf{shared\\_ptr}$所管理的对象。这三种类型均定义在$\\mathsf{memory}$头文件中。"}
          {:block/id #uuid "6618a716-3421-433b-9bd4-dfdd855e3cb7",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "6618a729-d2f5-4ce9-b651-b81559502470",
             :block/properties {},
             :block/format :markdown,
             :block/children [],
             :block/content
             "类似$\\mathsf{vector}$，智能指针也是模板，因此创建方式和$\\mathsf{vector}$一样，需要在尖括号内给出指针可以指向的类型\n```C++\nshared_ptr<string> p1;\nshared_prt<list<int>> p2;\n```\n其基本使用方法与常规指针一致。"}
            {:block/id #uuid "6618a970-4b33-4938-8df8-3ea5fcf5ec24",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "|操作|功能|\n|make\\_shared<T>(args)                            |返回一个$\\mathsf{shared\\_ptr}$，指向一个动态分配的类型为$\\mathsf{T}$的对象。使用$\\mathsf{args}$初始化此对象|\n|shared\\_ptr<T> p(q)        |$\\mathsf{p}$是$\\mathsf{shared\\_ptr\\  q}$的拷贝：此操作会递增$\\mathsf{q}$中的计数器。$\\mathsf{q}$中的指针必须能转换为$\\mathsf{T*}$|\n|p = q        |$\\mathsf{p}$和$\\mathsf{q}$都是$\\mathsf{shared\\_ptr}$，所保存的指针必须能相互转换。此操作会递减$\\mathsf{p}$的引用计数，递增$\\mathsf{q}$的引用计数；若$\\mathsf{p}$的引用计数变为0，则将其管理的原内存释放|\n|p.unique()        |若$\\mathsf{p.use\\_count()}$为1，返回$\\mathsf{true}$；否则返回$\\mathsf{false}$|\n|p.use_count()        |返回与$\\mathsf{p}$共享对象的智能指针数量；可能很慢，主要用于调试|"}
            {:block/id #uuid "6618a825-48d4-44f5-aeb0-16fa2957ea85",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "使用$\\mathsf{make\\_shared}函数分配和使用动态内存\n```C++\nshared_ptr<int> p3 = make_shared<int>(42); \t// defines a shared point to int 42\nauto p4 = make_shared<string>(10, '0');\t\t// defines a shared point to a string \"0000000000\"\n```"}
            {:block/id #uuid "6618ae53-0615-430f-918c-c4f5835995b0",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "$\\mathsf{shared\\_ptr}$的拷贝与赋值会记录有多少个其他$\\mathsf{shared\\_ptr}$指向相同的对象。可以认为$\\mathsf{shared\\_ptr}$有一个关联的计数器，称为**引用计数（reference count）**。一旦一个$\\mathsf{shared\\_ptr}$的计数器变为0，它就会自动释放自己所管理的对象。当指向一个对象的最后一个$\\mathsf{shared\\_ptr}$被销毁时，$\\mathsf{shared\\_ptr}$类会自动通过**析构函数（destructor）**销毁此对象。\n\n$\\mathsf{shared\\_ptr}$的析构函数会递减它所指向的对象的引用计数，如果引用计数变为0，$\\mathsf{shared\\_ptr}$的析构函数就会销毁对象并释放内存。"}
            {:block/id #uuid "6618c62d-9947-43a0-a943-88c1f2407acb",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content ""}
            {:block/id #uuid "6618a563-d93d-479a-b9bf-09801f191fe1",
             :block/properties nil,
             :block/format :markdown,
             :block/children
             [{:block/id #uuid "6618c865-ec31-4ad4-beba-964a86ecfa98",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "定义一个名为$\\mathsf{Blob}$的类，希望其实例的不同拷贝之间能够共享相同的属性。\n```c++\n#include <string>\n#include <vector>\n\nusing std ::vector;\nusing std ::string;\n\nclass StrBlob\n{\npublic:\n\tusing size_type = vector<string> ::size_type;\n\tStrBlob() : data(make_shared<vector<string>>()) {}\n\tStrBlob(std::initializer_list<string> il):\n\t\t\t\tdata(make_shared<vector<string>>(il)) {}\n\tsize_type size() const {return data -> size();}\n\tbool empty() const {return data -> empty();}\n\t// adds and deletes elements\n\tvoid push_back(const string &t){data -> push_back(t);}\n\tvoid pop_back();\n\t// accesses elements\n\tstring & front();\n\tstd ::string & back();\nprivate:\n\tstd ::shared_ptr<std ::vector<std ::string>> data;\n\t// if data[i] is illegal, throws an error\n\tvoid check(size_type i, const std::string &msg) const;\n};\n\nvoid StrBlob ::check(size_type i, const string &msg) const\n{\n\tif (i >= data -> size())\n\t\tthrow out_of_range(msg);\n}\nstring & StrBlob ::front()\n{\n\tcheck(0, \"front on empty StrBlob\");\n\treturn data -> front();\n}\nstring & StrBlob ::back()\n{\n\tcheck(0, \"back on empty StirBlob\");\n\treturn data -> back();\n}\nvoid StrBlob ::pop_back()\n{\n\tdata -> pop_back();\n\treturn;\n}\n```"}],
             :block/content "使用动态内存的常见原因是允许多个对象共享相同的状态。"}],
           :block/content "$\\mathsf{shared\\_ptr}$\ncollapsed:: true"}
          {:block/id #uuid "6618f45d-b7bf-4779-96fb-be68573cdb6f",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "6618f489-f749-4062-ab2d-492533acb60b",
             :block/properties nil,
             :block/format :markdown,
             :block/children
             [{:block/id #uuid "6618f4db-20cb-4aa3-91ec-c8df74b2449f",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "```c++\nint *pi = new int;  \t\t\t\t\t\t\t\t\t// default initialization\nint *pi = new int(1024);\t\t\t\t\t\t\t\t// direct initialization\nvector<int> *pv = new vector<int>{1, 2, 3, 4, 5, 6};\t// initialization with list\nstring *ps = new string();\t\t\t\t\t\t\t\t// initialization with value\n```\n在堆内分配的内存是无名的，因此$\\mathsf{new}$无法为其分配的对象命名，而是返回一个指向该对象的指针。\n默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是$\\mathsf{undefined}$。"}
              {:block/id #uuid "6618f8da-9d31-4861-bfda-da56c0cf86aa",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content "和变量类似，动态分配的对象可以通过值初始化，列表初始化或者直接初始化。"}],
             :block/content "使用$\\mathsf{new}$动态分配和初始化对象"}
            {:block/id #uuid "6618f8f6-bbad-4fe7-ad53-fe6f886ab33e",
             :block/properties nil,
             :block/format :markdown,
             :block/children
             [{:block/id #uuid "6618f908-76b1-41d1-9b8a-f27d1596ad13",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "```C++\ndelete p;\t// p must be a pointer to dynamically allocated object or nullptr\n```\n传递给$\\mathsf{delete}$的指针必须指向一个动态分配对象或者是空指针。释放一块并非$\\mathsf{new}$分配的内存或者将相同的指针值释放多次，其行为都是未定义的。"}],
             :block/content "使用$\\mathsf{delete}$释放动态内存"}],
           :block/content "直接管理内存"}
          {:block/id #uuid "661a33ca-1cd1-400d-950d-6b191814f3c3",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "661cf416-21a7-49b9-8370-f61a486ee916",
             :block/properties nil,
             :block/format :markdown,
             :block/children
             [{:block/id #uuid "661904aa-06a1-4f53-a0f6-3edc4e8c2d96",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "|操作|功能|\n| unique_ptr<T> u | 空$\\mathsf{unique\\_ptr}$，可以指向类型为$\\mathsf{T}$的对象。$\\mathsf{u1}$会使用$\\mathsf{delete}$来释放它的指针$ |\n| --- | --- |\n| unique_ptr<T, D> u2 | \\mathsf{u2}$会使用一个类型为$\\mathsf{D}$的可调用对象来释放它的指针 |\n| unique_ptr<T, D> u(d) | 空$\\mathsf{unique\\_ptr}$，可以指向类型为$\\mathsf{T}$的对象。用类型为$\\mathsf{D}$的对象$\\mathsf{d}$代替$\\mathsf{delete}$ |\n| u  = nullptr | 释放$\\mathsf{u}$指向的对象，将$\\mathsf{u}$置位空 |\n| u.release() | $\\mathsf{u}$放弃对指针的控制权，返回指针，并将$\\mathsf{u}$置为空 |\n| u.reset() | 释放$\\mathsf{u}$指向的对象 |\n| u.reset(q) | 如果提供了内置指针$\\mathsf{q}$，令$\\mathsf{u}$指向这个对象；否则将$\\mathsf{u}$置为空 |\n|u.reset(nullptr)||"}],
             :block/content
             "$\\mathsf{unique\\_ptr}$“拥有”它所指的对象。某个时刻只能有要给$\\mathsf{unique\\_ptr}$指向一个给定对象。当$\\mathsf{unique\\_ptr}$被销毁时，它所指向的对象也被销毁。\ncollapsed:: true"}
            {:block/id #uuid "661a3401-2c11-4b65-9120-653064f076e9",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "与$\\mathsf{shared\\_ptr}$不同，当我们定义一个$\\mathsf{unique\\_ptr}$时，需要将其绑定到一个$\\mathsf{new}$返回的指针上，且必须采用直接初始化形式\ncollapsed:: true\n```c++\nunique_ptr<double> p1; \t\t\t\t// unique_ptr can point at a double\nunique_ptr<int> p2(new int(42));\t//  p2 points to int with value 42\nunique_ptr<int> p3(p2);\t\t\t\t// error: no copy for unique_ptr\np3 = p2;\t\t\t\t\t\t\t// error；no assign for unique_ptr\n```\n$\\mathsf{unique\\_ptr}$不支持普通的拷贝和赋值行为。"}
            {:block/id #uuid "661cf416-29f3-4fa6-b1c5-700d183f1bb2",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "可以通过$\\mathsf{release}$和$\\mathsf{reset}$将指针的所有权从一个（非$\\mathsf{const}$）$\\mathsf{unique\\_ptr}$转移给另一个\n```c++\nunique_ptr<string> p1(new string(:\"Stegosaurus\"));\nunique_ptr<string> p2(p1.release.());\t\t\t// release and return the pointer\nunique_ptr<string> p3(new string(\"Trex\"));\np2.reset(p3.release());\t\t\t\t\t\t\t// transfer string \"Trex\" from p3 to p2\n```\n需要注意的是，如果不用另一个智能指针保存$\\mathsf{release}$返回的指针，将不会自动释放内存\n```C++\n// error: memory of p1 will not be freed and the pointer will be lost\np1.release();\n// ok: but don't forget to free the memory\nauto p = p1.release();\n```"}
            {:block/id #uuid "661cf416-7ac5-486d-b96a-2f9cb5a01ca6",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "不能拷贝$\\mathsf{unique\\_ptr}$的规则有一个意外：可以拷贝或者赋值一个将要销毁的$\\mathsf{unique\\_ptr}$。最常见的例子是从函数返回一个$\\mathsf{unique\\_ptr}$\n```c++\nunique_ptr<int> clone(int p){\n  // ok: define a unique_ptr from a int*\n  return unique_ptr<int>(new int(p));\n}\nunique_ptr<int> clone(int p){\n  unique_ptr<int> ret(new int(p));\n  return ret;\n}\n```"}
            {:block/id #uuid "661cf416-0cf7-4695-88e6-9930e07d29da",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content ""}],
           :block/content
           "$\\mathsf{unitque\\_ptr}$\ncollapsed:: true"}
          {:block/id #uuid "661cf416-5afe-404e-89d0-1abb5dd5320f",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "661cf416-0474-45cd-8d7d-b36552567dc0",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "$\\mathsf{weak\\_ptr}$是一种不控制所指向对象生存周期的智能指针，它指向一个由$\\mathsf{shared\\_ptr}$管理的对象。将一个$\\mathsf{weak\\_ptr}$绑定到一个$\\mathsf{shared\\_ptr}$不会改变$\\mathsf{shared\\_ptr}$的引用计数，也不会影响指向对象是否被释放。"}
            {:block/id #uuid "661cf416-8eba-43cb-b9ec-fc29cc384eca",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "$\\mathsf{weak\\_ptr}$支持的操作\n|||\n|weak_ptr<T> w|空$\\mathsf{weak\\_ptr}$，可以指向类型为$\\mathsf{T}$的对象|\n|weak_ptr<T> w(sp)|与$\\mathsf{shared\\_ptr\\ sp}$指向相同对象的$\\mathsf{weak\\_ptr}$，$\\mathsf{T}$必须能转换为$\\mathsf{sp}$所指向的类型|\n|w = p|$\\mathsf{p}$可以是要给$\\mathsf{shared\\_ptr}$或一个$\\mathsf{weak\\_ptr}$。赋值后$\\mathsf{w}$和$\\mathsf{p}$共享对象|\n|w.reset()|将$\\mathsf{w}$置为空|\n|w.use_count()|与$\\mathsf{w}$共享对象的$\\mathsf{shared\\_ptr}$的数量|\n|w.expired()|若$\\mathsf{w.use_count()}$为0，返回$\\mathsf{true}$，否则返回$\\mathsf{false}$|\n|w.lock()|如果$\\mathsf{expired}$为$\\mathsf{true}$，返回一个空$\\mathsf{shared\\_ptr}$；否则返回一个指向$\\mathsf{w}$的对象的$\\mathsf{shared\\_ptr}$|"}
            {:block/id #uuid "661cf416-946b-4955-a6ca-1240e1050d52",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "创建一个$\\mathsf{weak\\_ptr}$时，需要使用$\\mathsf{shared\\_ptr}$进行初始化\n```c++\nauto p = make_shared<int> (42);\nweak_ptr<int> wp(p); // the reference count of p will not change\n```"}
            {:block/id #uuid "661cf416-ebba-49d5-a69b-d97491cf0f76",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "由于对象可能不存在，因此不能直接使用$\\mathsf{weak\\_ptr}$访问对象， 而必须调用$\\mathsf{lock}$。此函数检查指向的对象是否存在，如果存在，返回一个指向共享对象的$\\mathsf{shared\\_ptr}$。"}],
           :block/content "$\\mathsf{weak\\_ptr}$\ncollapsed:: true"}
          {:block/id #uuid "661cf416-a90d-459b-8278-1ffc18704b8b",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "661cf416-adb5-4f1f-af11-421b91c75f33",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "定义一个函数$\\mathsf{end}$，用其代替智能指针默认的删除器函数$\\mathsf{delete}$\n```c++\n// defines a function end whose parameter is a pointer to class PtrTest\nvoid end(PtrTest *p){};\t\t\t\t\t\t\t\t\t\nPtrTest pt;\n// adds a pointer to the delete function as a parameter\nshared_ptr<PtrTest> p(&pt, end);\n// adds a pointer to the delete function as a paramter and\n// supplies the delete type inside the angle brackets\nunique_ptr<PtrTest, decltype(end)*> p(&pt, end);\t\t\n```"}
            {:block/id #uuid "661cf416-f78a-40d3-83d4-5c3c43e52833",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "在$\\mathsf{shared\\_ptr}$中只需要将删除器函数作为参数在初始化时传入即可。而在$\\mathsf{unique\\_ptr}$中则需要另外在尖括号中指定删除器函数的类型。"}
            {:block/id #uuid "661cf416-269b-44c1-90da-be2a6dd8d749",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content ""}],
           :block/content
           "重载删除器（$\\mathsf{deleter}$)函数\ncollapsed:: true"}],
         :block/content "#### 动态内存和智能指针"}
        {:block/id #uuid "661cf416-0286-43dd-827d-b58b41584e9b",
         :block/properties {:heading 4},
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "661cf416-987e-434a-90a7-18f131c1d170",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "动态数组可以一次为多个对象分配内存，分配内存、初始化和释放如下\n```c++\n// allocates memory for a dynamical list\nint pia = new int[10];\ntypedef int arrT[42];\nint *p = new arrT;\n\n// initializes a dynamical list\nint pia = new int[10]();\nint pia2 = new int[3]{3, 4, 5};\nstring pia3 = new stirng[10]{'a', \"an\", \"the\", string(3, 'x')};\n// releases a dynamical list\ndelete [] pia;\n```"}
          {:block/id #uuid "661cf416-81e6-449e-8fed-e88209cb865d",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "动态数组实际并非数组类型，分配一个动态数组时，得到的是指向数组首元素的指针\n```c++\n#include <iostream>\nint main(){\n  int *p = new int[2]{'0', '1'};\n  std ::cout << *p << std ::endl;\t// output 0\n  std ::cout << p[0] << std ::endl; // output 0\n  std ::cout << p[1] << std ::endl;\t// output 1\n}\n```"}
          {:block/id #uuid "661cf416-4373-4c42-b459-e1a4246071a7",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "661cf416-4faf-4e95-9c1b-55eeba7a8f1b",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "标准库中提供了一个可以管理$\\mathsf{new}$分配的数组的$\\mathsf{unique\\_ptr}$版本。为了使用$\\mathsf{unique\\_ptr}$管理动态数组，必须在对象类型后跟一对空方括号\n```c++\nunique_ptr<int []> up(new int[10]);\nup.release();\n```"}
            {:block/id #uuid "661cf416-f44d-4c0e-9a3f-53c85593327f",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "$\\mathsf{shared\\_ptr}$不支持直接管理动态数组，如果希望使用$\\mathsf{shared\\_ptr}$管理一个动态数组，必须提供自己定义的删除器。另外$\\mathsf{shared\\_ptr}$未定义下标运算符，智能指针类型也不支持指针算数运算，因此为了访问数组中的元素，必须用$\\mathsf{get}$获取一个内置指针，然后用它来访问元素\n```C++\nshared_ptr<int> sp(new int[10], [](int *p){delete [] p;});\nsp.reset();\nfor (size_t i = 0; i ! = 10; ++i)\n  *(sp.get() + i) = i;\n```"}],
           :block/content "智能指针和动态数组"}
          {:block/id #uuid "661cf416-0c8f-4142-b7a3-266ef1f8bc8c",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "661cf416-e23e-4251-a597-d0c6691d9046",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "标准库$\\mathsf{allocator}$类定义在头文件memory中，可以将内存分配和对象构造分离开。提供一种类型感知的内存分配方法，分配的内存是原始的，未构造的。\n```c++\nallocate<string> alloc;\nauto const p = alloc.allocate(n);\nauto q = p;\t\t\t\t\t\t// p is a pointer to the position of the element constructed at last\nalloc.construct(q++);\t\t\t// *q is a null string\nalloc.construct(q++, 10, 'c');\t// *q is cccccccccc\nalloc.costruct(q++, \"hi\");\t\t// *q is hi\nwhile (q! = p){\n  alloc.destroy(--q);\t\t\t// release constructed string\n}\nalloc.deallocate(p, n);\t\t\t// return allocted memory to system\n```"}
            {:block/id #uuid "661cf416-7d0b-478a-92b3-6f36da91644c",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "$\\mathsf{allocator}$类支持的操作\n|||\n|allocator<T> a          |定义了一个名为$\\mathsf{a}$的$\\mathsf{allocator}$对象，可以为类型$\\mathsf{T}$的对象分配内存|\n|a.allocate(n)         |分配一段原始的、未构造的内存，保存n个类型为$\\mathsf{T}$的对象|\n|a.deallocate(p, n)              |释放从$\\mathsf{T*}$指针$\\mathsf{p}$中地址开始的内存，这块内存保存了n个类型为$\\mathsf{T}$的对象；$\\mathsf{p}$必须是一个先前由$\\mathsf{allocate}$返回的指针，且n必须是$\\mathsf{p}$类创建时所要求的大小。在调用$\\mathsf{deallocate}$类之前，用户必须对每个在这块内存中创建的调用$\\mathsf{destroy}$|\n|a.construct(p, args)               |$\\mathsf{p}$必须是一个类型为$\\mathsf{T*}$的指针，指向一块原始内存；$\\mathsf{arg}          $被传递给类型为$\\mathsf{T}$的构造函数，用来在$\\mathsf{p}$指向的内存中构造一个对象|\n|a.destroy(p)          |$\\mathsf{p}$为$\\mathsf{T*}$类型的指针，此算法对$\\mathsf{p}$指向的对象执行析构函数|"}
            {:block/id #uuid "661cf416-e4bd-43ff-8d99-0b9e0784df37",
             :block/properties nil,
             :block/format :markdown,
             :block/children
             [{:block/id #uuid "661cf416-4760-457b-a1c3-a9cdd6a0e7f6",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "标准库为$\\mathsf{allocator}$类定义了两个伴随算法，可以在给定目的位置创建元素，而不是由系统分配内存给它们\n|||\n|uninitialized_copy(b, e, b2)|从迭代器b和e指出的输入范围中拷贝元素到迭代器b2指定的未构造原始内存中。b2指向的内存必须足够大，能容纳输入序列中元素的拷贝|\n|uninitialized_copy_n(b, n, b2)|从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中|\n|uninitialized_fill(b, e, t)|在迭代器b和e指定的原始内存范围中创建对象，对象的值均为t的拷贝|\n|uninitialized_fill_n(b, n, t)|从迭代器b指向的内存地址开始创建n个对象。b必须指向足够大的未构造的原始内存，能够容纳给定数量的对象|"}],
             :block/content "拷贝和填充未初始化内存的算法"}
            {:block/id #uuid "661cf416-33dc-4ebb-aa3a-7f1c39d6d03f",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content ""}],
           :block/content "$\\mathsf{allocator}$类\ncollapsed:: true"}],
         :block/content "#### 动态数组"}],
       :block/content "### 内存管理"}],
     :block/content "## C++标准库"}
    {:block/id #uuid "661cf416-c649-406b-b880-a10aef0d5ca4",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "661cf416-1447-4685-b6b9-50ba987046cf",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "661cf538-e62c-4b6c-9938-90872da37990",
         :block/properties {:heading 4},
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "661cf53e-1fbe-4663-b783-e36bf9a623b8",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。"}
          {:block/id #uuid "661cf56f-fc58-4af0-bc3c-8352af23d05a",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "661cf5d9-1582-42a0-b636-bae49dc60166",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content "将一个对象作为实参传递给一个非引用类型的形参时；"}
            {:block/id #uuid "661cf601-3e0f-4554-888e-26206307dec3",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content "从一个返回类型为非引用类型的函数返回一个对象；"}
            {:block/id #uuid "661cf611-cd25-4300-b575-318fddc4cbd1",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content "用花括号列表初始化一个数组中的元素或一个聚合类中的成"}
            {:block/id #uuid "661cf62f-a195-40f9-b548-0a6e55cadb52",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "某些类类型还会对他们所分配的对象使用拷贝初始化"}],
           :block/content
           "拷贝构造函数定义了当我们对一个类进行拷贝初始化时的操作。\ncollapsed:: true\n除了用$\\mathsf{=}$定义变量时，拷贝初始化在下列情况也会发生"}
          {:block/id #uuid "661cf655-22f8-4d7f-919e-649192677bf0",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "```c++\nclass CopyConstructor{\npublic:\n\tCopyConstructor(const CopyConstructor &)；\nprivate:\n  \tint prop_a = 0;\n  \tstring prop_b = \"Copy Constructor Test\";\n  \tdouble prop_c = 0.5;\n};\n// equivalent copy constructer to the synthesized copy constructor\nCopyConstructor ::CopyConstructor(const CopyConstructor &orig):\n\t\t\t\t\t\t\t\tprop_a(orig.prop_a), \n\t\t\t\t\t\t\t\tprop_b(orig.prop_b), \n\t\t\t\t\t\t\t\tprop_c(orig.prop_c)\n                                {}\n```"}],
         :block/content "#### 拷贝构造函数"}
        {:block/id #uuid "661cf853-64a5-4111-b0b9-7b388da35e36",
         :block/properties {:heading 4},
         :block/format :markdown,
         :block/children [],
         :block/content
         "#### 拷贝赋值运算符\n```c++\nclass Foo{\npublic:\n  \tFoo& operator= (const Foo &);\nprivate:\n  \tint prop_a;\n  \tdouble prop_b;\n  \tstring prop_c;\n};\nFoo ::operator= (const Foo &orig){\n  \tprop_a = orig.prop_a;\n  \tprop_b = orig.prop_b;\n  \tprop_c = orig.prop_c;\n  \treturn *this;\n}\n```\n拷贝赋值运算符实际上即为名为$\\mathsf{operator=}$的函数，通常应该返回一个指向其左侧运算对象的引用。"}
        {:block/id #uuid "661d07f4-fded-41c7-9899-5c3bc74d84d7",
         :block/properties {:heading 4},
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "661d07fb-b2b9-48b8-88a1-3d3f35ad33fe",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "析构函数执行与构造函数相反的操作，释放对象所使用的资源，并销毁对象的非$\\mathsf{static}$数据成员。"}
          {:block/id #uuid "661d0847-e660-4cce-99c6-e4d1e6bedb45",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "析构函数不接受参数，也没有返回值，因此无法重载，一个类只能有一个析构函数\n```c++\nclass Foo{\npublic:\n  \t~Foo();\t// destructor\n}\n```"}
          {:block/id #uuid "661d08a4-4d66-4f98-ae7c-3f7c49349a01",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "在一个构造函数中，成员初始化是在执行函数体之前完成的；而析构函数刚好相反，首先执行函数体，然后销毁成员。成员按照初始化顺序**逆序**销毁。"}
          {:block/id #uuid "661d0944-a31c-4127-9dca-6ac830634620",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "661d094b-81bc-4712-aa73-72535e0af5f0",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content "变量在离开其作用域时被销毁；"}
            {:block/id #uuid "661d0965-18fe-4d6b-90c1-857370e64ea5",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content "当一个对象被销毁时，其成员被销毁；"}
            {:block/id #uuid "661d096f-6c6d-49a3-9e1d-f10c8fd37f5b",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content "容器（无论是标准库容器还是数组）被销毁时，其元素被销毁；"}
            {:block/id #uuid "661d097e-c04b-4443-95e8-621f1fa4ee64",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content
             "对于动态分配的对象，当对指向它的指针应用$\\mathsf{delete}$运算符时被销毁；"}
            {:block/id #uuid "661d09a0-0487-42b1-8bae-1288c1d66223",
             :block/properties {:logseq.order-list-type "number"},
             :block/format :markdown,
             :block/children [],
             :block/content "对于临时对象，当创建它的完整表达式结束时被销毁。"}],
           :block/content "什么时候会调用析构函数"}],
         :block/content "#### 析构函数"}],
       :block/content "### 拷贝、赋值与销毁"}],
     :block/content "## 拷贝控制"}
    {:block/id #uuid "661cf416-2189-4c56-b9d5-c12c6d3e3fd1",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "6625fcd2-7250-4d0e-9362-9184c78033e2",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "预处理就是为了提高编程效率，在对程序编译之前，根据预处理命令进行相应的处理。"}
      {:block/id #uuid "6625fcd2-b807-441b-a80c-915bb2dd67cb",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "6625fcd2-06ba-49de-8f5f-3152afa0d703",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "定义一个标识符代表全局变量或者语句"}
        {:block/id #uuid "6625fcd2-7ae9-41e9-9b7a-a3cb3f8a8bfb",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "6625fcd2-1005-4e44-8d4c-d4ebd499fd12",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "```c++\n#define PI 3.1415\n```"}
          {:block/id #uuid "6625fcd2-e62d-42a1-bef3-f874b519728c",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content "宏定义一般使用全大写，便于识别；"}
          {:block/id #uuid "6625fcd2-95fe-4983-a280-5cda6d2e26d4",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content "使用宏名代替某个字符串，可以减少书写工作量，同时也便于修改；"}
          {:block/id #uuid "6625fcd2-eef7-4fbc-a7b2-fce4d92e38c0",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content "宏定义不是C语言，不需要加分号；"}
          {:block/id #uuid "6625fcd2-1f56-4a87-b023-7c449f84d223",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content "\\#$\\mathsf{define}$出现在程序函数外面，有效范围是本文件；"}
          {:block/id #uuid "6625fcd2-7612-4e85-bcdf-212abbf29833",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content "可以使用\\#$\\mathsf{undef}$命令手动终止宏的作用域；"}
          {:block/id #uuid "6625fcd2-8486-49a9-968b-37a3da48170a",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content "进行宏定义时，可以引用已经定义的宏名，层层置换。"}],
         :block/content "不带参数的宏定义"}
        {:block/id #uuid "6625fcd2-2ec1-48b8-abe0-185e251d1b69",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "6625fcd2-b6a3-42e8-a832-c0d804846960",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "```c++\n#define S(a, b) a*b\n```"}
          {:block/id #uuid "6625fcd2-ec2b-498f-b330-159de001179d",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content
           "对带参数的宏的展开只是将语句中的宏名后面括号内的实参字符代替\\#$\\mathsf{define}$命令行中的形参；"}
          {:block/id #uuid "6625fcd2-1133-44bc-b60a-439d65178c2f",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content "在宏定义时，宏名与参数之间不要加空格；"}
          {:block/id #uuid "6625fcd2-2ef3-4c5d-b8ef-26aabe30a529",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content "预定义中的宏参数不需要定义类型，因为只是替换；"}
          {:block/id #uuid "6625fcd2-e0e1-4dd6-bd48-b411a09c3aa2",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content "调用函数只能得到一个返回值，而宏可以得到几个结果；"}
          {:block/id #uuid "6625fcd2-6eb6-40c4-a7c9-67232012f6f3",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children [],
           :block/content
           "宏展开时，每次都会替换，所以使用带参数的宏定义，相对函数而言，会使得程序变长。但是宏替换不占用运行时间，只占编译时间，而函数调用则要占用运行时间（包括分配单元，保护现场，值传递，返回等）。"}],
         :block/content "带参数的宏定义"}
        {:block/id #uuid "6625fcd2-a4eb-463f-831d-571503370539",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content ""}],
       :block/content "### 宏定义"}
      {:block/id #uuid "661cf416-5cf0-4b62-902a-9240b633e1e6",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "6613cca6-0aa9-4cfe-b1ce-a3114c088164",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "6613ccbd-1f0d-41ee-a1ca-b70351aa55b3",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "$\\mathsf{assert}$是一种预处理宏（preprocessor marco）。所谓预处理宏其实是一个预处理变量，$\\mathsf{assert}$宏定义在$\\mathsf{cassert}$头文件中，使用一个表达式作为它的条件：\n```c++\n#include <cassert>\nassert(expr);\n```\n首先对$\\mathsf{expr}$求值，若为假，$\\mathsf{assert}$输出信息并终止程序的执行；若为真则不执行操作。"}],
         :block/content "$\\mathsf{assert}$预处理宏"}
        {:block/id #uuid "6613cd26-29cb-47d7-b1e5-dccfb83f6782",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "6613cdc8-ac9c-4856-a50d-f8da4d114d92",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "$\\mathsf{assert}$的行为依赖于一个名为$\\mathsf{NDEBUG}$的预处理变量的状态。如果定义了$\\mathsf{NDEBUG}$，则$\\mathsf{assert}$不执行操作。默认状态下没有定义$\\mathsf{NDEBUG}$，此时$\\mathsf{assert}$将执行运行时检查。"}],
         :block/content "$\\mathsf{NDEBUG}$预处理变量"}],
       :block/content "### 调试帮助"}],
     :block/content "## 预处理命令"}
    {:block/id #uuid "6606125a-2594-4314-b943-fcfa1bd7461b",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "6625fcd2-5118-4f5a-b252-426ac4c595a6",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66261221-a570-43b9-adbd-648b99419f14",
         :block/properties {:heading 4},
         :block/format :markdown,
         :block/children [],
         :block/content "#### 内核态与用户态 #？"}
        {:block/id #uuid "6625fcd2-a4b9-4024-88dc-4bbd190b8021",
         :block/properties {:heading 4},
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "6625fcd2-a802-4954-8308-904eb4f69bfc",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "Linux内核为$\\mathsf{printk}$定义了8个输出等级，可以通过设置默认的输出等级控制其是否输出到终端或者串口\n```C++\n#define KERN_EMERG KERN_SOH \"0\"\t\t/* 最高输出等级，系统可能处于不可用的状态 */\n#define KERN_ALERT KERN_SOH \"1\"\t\t/* 紧急和立刻需要处理的输出 */\n#define KERN_CRIT KERN_SOH \"2\"\t\t/* 紧急情况 */\n#define KERN_ERR KERN_SOH \"3\"\t\t/* 发生错误 */\n#define KERN_WARNING KERN_SOH \"4\"\t/* 警告 */\n#define KERN_NOTICE KERN_SOH \"5\"\t/* 重要的提示 */\n#define KERN_INFO KERN_SOH \"6\"\t\t/* 提示信息 */\n#define KERN_DEBUG KERN_SOH \"7\"\t\t/* 调试输出 */\n```"}
          {:block/id #uuid "6625fcd2-de7d-43ab-87a5-5d641a21a643",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "为了便于调试，可以加上函数名字和行号\n```c++\nprintk(KERN_EMERG \"figo: %s, %d\", __func__, __LINE__);\n```\n双引号前增加$\\mathsf{KERN\\_EMERG}$用来说明输出等级。"}
          {:block/id #uuid "6625fcd2-01b1-478c-b8f4-d40b630f36b9",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "6625fcd2-4d0b-4b82-982a-9c6d349c3fca",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "|数据类型|printk格式符|\n|int|%d  %x|\n|unsigned int|%u  %x|\n|long|%ld  %lx|\n|long long|%lld  %lld|\n|unsigned long long|%llu  %llx|\n|size_t|%zu  %zx|\n|函数指针|%pf|"}],
           :block/content "$\\mathsf{printk}$输出等级\ncollapsed:: true"}
          {:block/id #uuid "6625fcd2-072f-42c2-a7b3-457d010fc2cd",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "6625fcd2-b440-46df-aa20-b3749fe000cf",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "为了简化$\\mathsf{printk}$使用，Linux对其进行了进一步封装，将每一个输出等级进行封装为一个$\\mathsf{pr\\_xx}$函数，以$\\mathsf{KERN\\_ALERT}$等级为例\n```c++\n#define pr_alert(fmt, ...) printk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)\n```"}
            {:block/id #uuid "6625fcd2-50bf-4da5-92bf-12821f15369f",
             :block/properties nil,
             :block/format :markdown,
             :block/children
             [{:block/id #uuid "6625fcd2-2622-4582-9422-1106136a8fb1",
               :block/properties {:logseq.order-list-type "number"},
               :block/format :markdown,
               :block/children [],
               :block/content
               "如果设置了$\\mathsf{CONFIG\\_DYNAMIC\\_DEBUG}$，则$\\mathsf{pr\\_debug}$扩展为$\\mathsf{dynamic\\_pr\\_debug}$，主要用于动态输出；"}
              {:block/id #uuid "6625fcd2-0500-4d17-9127-b8a21019b908",
               :block/properties {:logseq.order-list-type "number"},
               :block/format :markdown,
               :block/children [],
               :block/content
               "否则，如果定义了$\\mathsf{DEBUG}$宏，则它等同于具有$\\mathsf{KERN\\_DEBUG}$日志级别的$\\mathsf{printk}$；"}
              {:block/id #uuid "6625fcd2-7334-4adb-99b3-e44b6ebdc55f",
               :block/properties {:logseq.order-list-type "number"},
               :block/format :markdown,
               :block/children [],
               :block/content "如果未定义$\\mathsf{DEBUG}$宏，则无操作。"}
              {:block/id #uuid "6625fcd2-6142-49cf-bfcc-436be0cf3628",
               :block/properties nil,
               :block/format :markdown,
               :block/children [],
               :block/content
               "```c++\n#if defined(CONFIG_DYNAMIC_DEBUG) || \\\n\t(defined (CONFIG_DYNAMIC_DEBUG_CORE) && defined(DYNAMIC_DEBUG_MODULE))\n#include <linux/dynamic_debug.h>\n/**\n * pr_debug - Print a debug-level message conditionally\n * @fmt: format string\n * @...: arguments for the format string\n *\n * This macro expands to dynamic_pr_debug() if CONFIG_DYNAMIC_DEBUG is\n * \tset. Otherwise, if DEBUG is defined, it's equivalent to a printk with\n *\tKERN_DEBUG loglevel. If DEBUG is not defined it does nothing.\n *\n * It uses pr_fmt() to generate the format string (dynamic_pr_debug() uses\n *\tpr_fmt() internally).\n */\n#define pr_debug(fmt, ...) dynamic_pr_debug(fmg, ##__VA_ARGS__)\n#elif defined(DEBUG)\n#define pr_debug(fmt, ...) printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#else\n#define pr_debug(fmt, ...) no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)\n#endif\n```"}],
             :block/content
             "由于$\\mathsf{DEBUG}$等级比较常用，内核对其的封装又分为三种情况"}],
           :block/content "$\\mathsf{pr\\_xx}$封装"}],
         :block/content "#### $\\mathsf{printk}$"}],
       :block/content "### 代码调试"}],
     :block/content "## Linux相关"}
    {:block/id #uuid "6625fcd2-1b2a-4311-b0c3-3469a1c68a48",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "660ad89d-2c35-47d6-8e81-4f1b8d2f2daf",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "#+BEGIN_NOTE\n**数据类型**\n\n当确定值不为负时，使用**无符号**类型；\n\n整数尽量使用$\\mathsf{int}$类型，$\\mathsf{short}$类型通常长度不够，而$\\mathsf{long}$类型在应用中通常和$\\mathsf{int}$长度一致，$\\mathsf{int}$类型长度不足时，应使用$\\mathsf{long\\ long}$类型；\n\n浮点数应使用$\\mathsf{double}$类型，$\\mathsf{float}$类型通常精度不够，且相比单精度浮点数计算，双精度的计算成本增加可以忽略不计；在某些设备上，双精度计算速度要高于单精度；通常所需的精度无需使用$\\mathsf{long double}$类型，其和显著增加运行时间。\n#+END_NOTE"}
      {:block/id #uuid "660b6672-851c-489f-81b3-9d1722a71cbf",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "#+BEGIN_NOTE\n**避免**$\\mathsf{undefined}$**和依赖环境的定义**\n\n通常$\\mathsf{undefined}$来自编译器不需要或者无法检测的错误，即使代码通过编译，程序运行也会出错。\n\n不幸的是，在某些环境或者某些编译器中，包含$\\mathsf{undefined}$的程序可以正确运行。但没法保证在其他编译器，甚至同一编译器的不同版本下也能正常运行。\n\n类似的，程序通常应该避免依赖环境的定义，比如假定$\\mathsf{int}$类型的变量长度是一个已知的定值。这种程序是无法移植的，只能在固定的设备上使用。\n#+END_NOTE"}
      {:block/id #uuid "660b71f6-874e-4796-95a8-2ffbc94276aa",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "#+BEGIN_NOTE\n**避免有符号和无符号变量的混用**\n\n有符号变量会被自动转变为无符号变量，负数会被转变为非常大的正数，这在某些场合是非常危险的。\n\n比如，轴的转速可以通过正负来表示方向，当轴的转速和一个无符号数进行运算后，会变成一个巨大的正值导致危险。\n\n因此，和无符号数的运算需务必确认变量类型。\n#+END_NOTE"}
      {:block/id #uuid "660bbe1d-f310-4e5f-89d6-51cae7983ab4",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "{{embed ((660bbc49-de55-4968-be1c-914a2ec785c1))}}"}
      {:block/id #uuid "660bc149-52e7-48f0-8c65-a34d53e11828",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "#+BEGIN_NOTE\n**当第一次使用某对象时再定义**\n\n在对象第一次被使用的附近定义它，有助于更容易地找到变量的定义，也有助于赋予一个更为合理的初始值。\n#+END_NOTE"}
      {:block/id #uuid "660bcfc3-c7fc-4792-b340-cf0ef279be42",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "#+BEGIN_NOTE\n**初始化所有指针**\n\n未初始化的指针是引发程序运行时错误的常见原因。\n\n在大多数编译器中，使用一个未经初始化的指针时，该指针所占据空间的当前内容被视作一个地址。使用该指针相当于访问一个本不存在位置上的一个本不存在的对象。当指针所占的空间恰好存在内容，这些内容又被当作了某个地址，则很难分清该指针是否有效。\n\n因此建议初始化所有指针，并且尽可能在定义了对象后再定义指向它的指针。如果没有和指针绑定的对象，使用$\\mathsf{nullptr}$或者0初始化指针。\n#+END_NOTE"}
      {:block/id #uuid "660bd638-00c0-4053-9918-339be625b014",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "#+BEGIN_NOTE\n**定义多个变量**\n\n变量的定义包括一个基本数据类型和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但声明符的形式可以不同。类型修饰符（&和*）实际上是声明符的一部分而非基本数据类型的一部分。\n\n涉及引用或指针的声明一般有两种写法。\n第一种将修饰符和变量标识符写在一起：\n```c++\nint *p1, *p2;\t// both p1 and p2 are pointers to int\n```\n第二种把修饰符和类型名写在一起，每条语句只定义一个变量：\n```c++\nint* p1;\t// p1 is a pointer to int\nint* p2;\t// p2 is a pointer to int\n```\n#+END_NOTE"}
      {:block/id #uuid "660cfcbc-5337-4adb-916a-7cf6fb12f19f",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "#+BEGIN_NOTE\n**头文件保护**\n\n为避免重复包含，所有头文件均应习惯性加上头文件保护符，即使头文件确实不需要保护。\n\n整个程序中头文件保护符必须唯一，（实际上，所有预处理变量均应唯一。）通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中其他实体发生名字冲突，一般把预处理变量的名字全部大写。\n\n```C++\n#ifndef SALES_DATA_H\n#define SALES_DATA_H\n/*EMPTY*/ \n#endif\n```\n#+END_NOTE"}
      {:block/id #uuid "661a3010-f688-44d2-95fc-c05864a7de85",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "{{embed ((6613ae05-a28e-4903-8f90-0add539eebe6))}}"}],
     :block/content "## 代码规范"}
    {:block/id #uuid "660b6fd6-1713-439f-a679-500d0e499628",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "661a343b-fdc0-469c-a7fb-f5e588f5c3a1",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "660b6fe5-0bba-4357-9c55-2eef85a057b8",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "```C++\nfor (unsigned i=10, i>0, i--)\n{\n  std::cout << i << std::endl;\n}\t//输出10，9，8，...，2，1\n//============================================================\nunsigned i = 11;\nwhile(i>0)\n{\n  i--;\n  std::cout << i << std::endl;\n}\t//输出10，9，8，...，2，1，0\n/*\n * for循环先执行 i--，再执行判断；\n * while循环先执行判断，再执行i--；\n*/\n```"}],
       :block/content "### $\\mathsf{while}$和$\\mathsf{for}$循环语句的细节区别"}
      {:block/id #uuid "661a2f1b-6882-4d8c-818f-56b0904ae40b",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "661a2f36-fc2a-40c2-b699-2d343450d9a4",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "```console\ngcc main.cpp -o main.exe\n/* \"-o\" is used for a fucking custom name rather than any execution.\n * What the fuuuuuuuuuuuuuuuuuuuuuckkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk!\n * or else a file named \"a.out\" will be built.*/\n ./main.exe\t\t// executes (or \"./a.exe\")\n```"}],
       :block/content "### gcc编译问题"}
      {:block/id #uuid "6618de36-16b4-49cd-b7b9-39f5965dcfa1",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "6618de3e-640a-45de-8c81-7911f0cfb30d",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "```c++\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass RefTest\n{\npublic:\n    RefTest():data(\"I wanna be the guy\"){}\n    RefTest(string s):data(s){}\n    string & ref1(void){string & r = data; return data;}\nprivate:\n    string data;\n};\n\nint main()\n{\n    RefTest rt;\n    string s1 = rt.ref1(); \t\t\t// ok: s1 is a string copy from rt.data\n    string & r1 = rt.ref1();\t\t// ok: r1 is a reference to rt.data\n}\n```\n个人理解：以方法（或函数）$\\mathsf{ref1}$为例，方法本身在$\\mathsf{rt.ref1()}$中就已经完成了，无论是否有变量接收其返回值。接收返回值相当于一步赋值操作。所以允许进行可行的隐式类型转换，即并不严格要求接收变量类型与方法（或函数）返回值类型相同。"}
        {:block/id #uuid "6618e605-1136-4da1-b5a8-d6fc3692e3d2",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "```c++\nclass RefTest\n{\npublic:\n    RefTest():data(\"I wanna be the guy\"){}\n    RefTest(string s):data(s){}\n    string str1(void){return data;}\n    const string str1(void) const {return data;}\n    string data;\n};\n\nint main()\n{\n    RefTest rt;\n    string & r1 = rt.data;\n    string s2 = rt.str1();\t\t\t// ok: s2 is a string copy from rt.data\n    string & r2 = rt.str1();\t\t// error: cannot bind non-const lvalue reference to type 'string &' \n\tconst string & r3 = rt.str1();  // ok: why?\n}\n```\n直接访问的属性可以直接与引用绑定，但是通过方法返回的属性却无法直接与引用绑定。$\\mathsf{const}$类型才可以与引用绑定，为什么 #？\n因为通过方法（或函数）返回的值是一个临时量，C++不允许将引用绑定到临时量上 #。 （猜测：方法或函数完成后，临时量的地址将被销毁，内存将被释放。此时引用无法找到地址？使用指针做测试，猜想验证正确。 ）"}],
       :block/content "### 返回类型问题"}
      {:block/id #uuid "661e3982-26f0-4c15-a9b1-377c1ceaaa4b",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "661e39a5-3914-43cd-b135-d08732b2c735",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "```C++\nwhile (1)\n{\n  \tif (!prop_a && prop_b)\n\t{\n  \t\t// statements here will execute with the rising edge.\n\t}\n\tprop_a = prop_b;\n}\n\n```"}],
       :block/content "### 如何实现上升（下降）沿触发"}
      {:block/id #uuid "661e3a64-075e-4af1-b9f8-6e591ac79a7c",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "661f3d99-a338-46e2-a923-b7766c15c1ab",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "使用unicode字符集时，$\\mathsf{tchar.h}$ 头文件中的宏 $\\mathsf{\\_T}$无法使用，需要切换为多字节字符集。"}],
       :block/content "### Visual Studio问题"}],
     :block/content "## 问题记录"}
    {:block/id #uuid "660a4f28-d806-4d8d-9634-ce4a1d52ce01",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "660a4f28-1de7-4fb9-aec5-2818cc8751c3",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "((66061aac-f575-4eb5-9f38-611f7061ab93))"}
      {:block/id #uuid "660a4f28-2b3b-4f04-abcb-7da118b3f8ef",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "((66061acf-5c09-4a98-9266-1d290f487b90))"}
      {:block/id #uuid "660a4f28-49f4-4def-b2d1-e98896a1a543",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "((66061adc-2e43-489b-afaa-e0041b8b670f))"}
      {:block/id #uuid "660ad912-4e7a-46e6-b1ce-0f4429b20d16",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "((660a5c8e-1b0b-4511-b968-20856e92ee01))"}],
     :block/content "## *References*"})}
  {:block/id #uuid "6618aca2-329a-4fc7-9272-4436abb01566",
   :block/page-name "README",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "6618aca2-329c-40e3-9da4-450a855b05db",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "中文 | [English](README.en.md)\n\n"}
    {:block/id #uuid "6618aca2-0e88-4121-9200-a9aebf291656",
     :block/properties {:heading 1},
     :block/format :markdown,
     :block/children [],
     :block/content
     "# logseq-plugin-luckysheet\n\n在 Logseq 中嵌入电子表格 Luckysheet。你也可以用它来维护一张 markdown 表格。\n\n表格数据存储在 `assets` 文件夹下。"}
    {:block/id #uuid "6618aca2-b974-48f7-afa5-7fd1cd72d55d",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 使用展示\n\n![demo](demo.gif)"}
    {:block/id #uuid "6618aca2-a5ed-4c4b-8d11-8a58f4bb1be4",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content
     "## 使用示例\n\n```\n{{renderer :luckysheet, workbook name}}\n```"}
    {:block/id #uuid "6618aca2-378d-44a6-bfe1-8614add21018",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content
     "## 免责声明\n\n本插件中使用的表格是第三方的开源软件 [Luckysheet](https://github.com/mengshukeji/Luckysheet)，非插件作者维护。插件作者不对由此带来的可能数据丢失或错误负任何直接或间接责任。"})}
  {:block/id #uuid "65f14810-ee71-45d9-b55f-b87b1d8bce1f",
   :block/page-name "hls__控制之美[卷一]_1709865510701_0",
   :block/properties
   {:file
    "[控制之美[卷一]_1709865510701_0.pdf](../assets/控制之美[卷一]_1709865510701_0.pdf)",
    :file-path "../assets/控制之美[卷一]_1709865510701_0.pdf"},
   :block/children
   ({:block/id #uuid "65f14810-b0f3-4fc8-8e93-60c56c598e39",
     :block/properties
     {:file
      "[控制之美[卷一]_1709865510701_0.pdf](../assets/控制之美[卷一]_1709865510701_0.pdf)",
      :file-path "../assets/控制之美[卷一]_1709865510701_0.pdf"},
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "6625fcd2-7c7d-4ca6-8a03-106aeaeb6619",
   :block/page-name "📓Note",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14811-3bf9-411d-aed9-c5bf847d8a96",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[控制理论]]"}
    {:block/id #uuid "65f14811-ae04-4701-a5b6-a4ea0273927a",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[电机控制]]"}
    {:block/id #uuid "66261b7e-89fa-4bf7-a783-8154b3a120b5",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[嵌入式编程基础]]"}
    {:block/id #uuid "6626201e-1859-40de-a315-9bdaab27a7d6",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[嵌入式硬件基础]]"}
    {:block/id #uuid "6626201f-f1c3-43ef-9dd8-cfaee7a2f10b",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[嵌入式典型平台（ARM）]]"}
    {:block/id #uuid "66262033-87ca-4f79-8f69-406ec3c1fd21",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[嵌入式应用层开发]]"}
    {:block/id #uuid "66262043-8f95-4be3-93fe-afaf94e32644",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[嵌入式底层开发]]"})}
  {:block/id #uuid "66261cab-ea5a-490f-a321-6d6274e852d3",
   :block/page-name "操作系统原理",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66261cac-882e-4e8f-9efc-8a0835c7c77f",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### 内存管理和调度"}
    {:block/id #uuid "66261cb4-8955-44e2-8375-ff73ec5bb118",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66261cd3-299d-4fac-9669-0ce7b76b1201",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 多线程"}
      {:block/id #uuid "66261cda-18f0-4f3e-84de-e1bb4c91325c",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 并发"}
      {:block/id #uuid "66261cde-35bc-46aa-ad43-0d66c6500c94",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 锁"}],
     :block/content "### 多任务"}
    {:block/id #uuid "66261cbf-4b54-4eb0-8d20-360fff458f8c",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### I/O 原理"}
    {:block/id #uuid "66261cca-7596-41b6-bc5f-e06187935d7a",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### 文件管理"})}
  {:block/id #uuid "66261f2f-4f73-4352-bb7d-2d0dc15a3811",
   :block/page-name "常见开发工具",
   :block/properties nil,
   :block/format :markdown,
   :block/children ()}
  {:block/id #uuid "6617b405-5c65-41a6-a808-f5996a7d7967",
   :block/page-name "Apr 12th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "6617b406-4223-49b6-8ce4-a91db955e26f",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "这是**伊戈德拉修**的致敬版——**伊德戈拉米**！ #balderdash"})}
  {:block/id #uuid "660a4f29-b4ca-4a97-88fb-cc1133721aa2",
   :block/page-name "Mar 12th, 2024",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14810-30e8-4560-8213-d32a8c56ca18",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "DONE 索要伺服电机相关资料 [[Mar 12th, 2024]]\n:LOGBOOK:\nCLOCK: [2024-03-12 Tue 09:18:01]\nCLOCK: [2024-03-12 Tue 09:18:02]--[2024-03-12 Tue 17:51:12] =>  08:33:10\n:END:"})}
  {:block/id #uuid "66261d71-f153-4093-b0da-d3ca0c651155",
   :block/page-name "单片机原理/微机原理/计组原理",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66261d73-b2d1-4273-8e0f-8190dede1268",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### 计算机的基本组成"}
    {:block/id #uuid "66261d8c-4d87-4c76-a5b3-1bd77ba7a61e",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### 指令和运算"}
    {:block/id #uuid "66261d90-b6d3-4696-8ec2-54a3c4492af8",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### 处理器架构和设计"}
    {:block/id #uuid "66261d95-9f1c-4ce0-ae07-111b89887a78",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### 存储系统"}
    {:block/id #uuid "66261d9b-6343-4809-98d9-dbcd44118de8",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children [],
     :block/content "### I/O 系统"}
    {:block/id #uuid "66261da2-a3ed-4522-9007-332a4af4fe4b",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "6625b3d9-0978-4792-83cc-e74a1b2db5e9",
   :block/page-name "Apr 22nd, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "6625b3db-fddd-41af-b921-642bb5d8c691",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "88.1 kg #Weight"})}
  {:block/id #uuid "65f14810-08a1-4906-bfb9-53e74d823c11",
   :block/page-name "Mar 13th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "65f14810-b531-425c-b2e6-e312f495f997",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "DONE Samkoon伺服驱动器及电机了解 [[Mar 13th, 2024]]\n:LOGBOOK:\nCLOCK: [2024-03-13 Wed 14:38:09]\nCLOCK: [2024-03-13 Wed 14:38:12]--[2024-03-13 Wed 15:21:07] =>  00:42:55\n:END:"})}
  {:block/id #uuid "660a4f29-6c25-4c39-9d96-e435fbbc2c49",
   :block/page-name "Project. Charmander",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14810-88d5-4e62-a4da-e43eb099a35b",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "**项目背景** 入职了解工控行业相关内容，学习Samkoon产品（HMI，PLC及其上位软件）的使用。"}
    {:block/id #uuid "65f14810-f514-4046-95f1-5a95fbab29b6",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "**项目目标** \n[[Mar 11th, 2024]] 完成液压站控制系统的PLC编程及HMI组态设计\n[[Mar 13th, 2024]] 更新-完成SK和PLC试题。"}
    {:block/id #uuid "65f14810-5a43-4f8e-8d89-ac1fe3350b78",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f24f8e-7638-42a8-9c24-cdfe23a2e5db",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children [],
       :block/content
       "![image.png](../assets/image_1710123062272_0.png)\n![image.png](../assets/image_1710123107550_0.png)"}
      {:block/id #uuid "65f24fa5-137f-4a3e-8b8e-327765a840fb",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f24fbc-65c2-4e4e-a3ea-3a3649c8349f",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content
         "按下M0就把D0-D200的双数值提取出来，并存放在D300开始的地址里，存放方式是先把总个数存放在D300,第一个号数存放在D301，第一个值存放在D302里，第二个号数存放在D303里，第二个值存放在D304里，类似这样存放，如果双数的个数大于100，置位Y0，否则复位Y0。"}
        {:block/id #uuid "65f24fda-1e97-448f-968c-062356ddc80b",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content
         "当你回家打开锁后，家里的智能系统执行如下动作：\n(1)、窗户开始打开(Y0控制)，当窗户打开到最大（感应器为M0）开始定时，50秒后开始关窗户（完全关闭感应器为M1）\n(2)窗户打开到最大，空调开始启动（Y6），运行115秒后切换到(Y7)模式。\n请用PLC编程实现以上功能。"}
        {:block/id #uuid "65f24ff4-1084-44d7-a8fb-378c4aa3fc83",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content
         "用plc实现功能：\n（1）按一下M0，把1、2、3、4、5的值分别写到D0、D1、D2、D3、D4，然后把D0、D1、D2、D3、D4加起来存放在D5里；\n（2）按一下M1，把10、20、30、40、50的值分别写到D0、D1、D2、D3、D4，然后把D0、D1、D2、D3、D4加起来存放在D5里。"}
        {:block/id #uuid "65f25023-6894-4069-b948-d3ff0504baa2",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content "实现跑马灯功能：从Y0开始到Y7结束循环亮，启动和间隔时间都可以设定。"}],
       :block/content "SK和PLC试题"}],
     :block/content "**项目资料**"}
    {:block/id #uuid "65f14810-b98a-434e-a925-a15da1a04e59",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14810-3dc4-4a82-949d-ab4e62ad4e22",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "DONE PLC编程 [[Mar 11th, 2024]]\n:LOGBOOK:\nCLOCK: [2024-03-11 Mon 09:54:15]\nCLOCK: [2024-03-11 Mon 09:54:16]--[2024-03-11 Mon 14:36:55] =>  04:42:39\n:END:"}
      {:block/id #uuid "65f14810-b525-4a8a-93fc-98e067f7e8e6",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "DONE PLC程序调试 [[Mar 12th, 2024]]\n:LOGBOOK:\nCLOCK: [2024-03-13 Wed 09:39:49]--[2024-03-13 Wed 09:56:13] =>  00:16:24\nCLOCK: [2024-03-13 Wed 13:55:04]--[2024-03-13 Wed 14:31:40] =>  00:36:36\n:END:"}
      {:block/id #uuid "65f14810-1882-4496-a1d7-3b483b09e333",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "DONE HMI组态设计 [[Mar 12th, 2024]]\n:LOGBOOK:\nCLOCK: [2024-03-13 Wed 09:39:51]--[2024-03-13 Wed 09:41:34] =>  00:01:43\nCLOCK: [2024-03-13 Wed 09:56:10]--[2024-03-13 Wed 14:31:18] =>  04:35:08\nCLOCK: [2024-03-13 Wed 14:31:21]--[2024-03-13 Wed 14:31:39] =>  00:00:18\n:END:"}
      {:block/id #uuid "65f24f14-54a6-422b-ab4f-fe1b2fadaeb2",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "DONE SK和PLC试题 [[Mar 13th, 2024]]"}
      {:block/id #uuid "65f14810-022b-4b15-b769-f9514d9363e6",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "DONE 项目总结 [[Mar 14th, 2024]]\n:LOGBOOK:\nCLOCK: [2024-03-14 Thu 09:05:31]--[2024-03-14 Thu 10:28:20] =>  01:22:49\n:END:"}],
     :block/content "**项目计划与进度**"}
    {:block/id #uuid "65f14810-e433-4b6b-8849-12d5ebb7961a",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f25177-83a5-4e57-8972-349f3ec2726b",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f14810-b013-49ba-b35b-8e7f5fea01f3",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "项目设备：FGs-16M PLC，SK-070-QS-G HMI。"}
        {:block/id #uuid "65f14810-c1c5-4ea4-85a0-f625b6c5de38",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "为简化项目，取消过滤器堵塞的相关检测和报警；取消电磁溢流阀相关设计。"}
        {:block/id #uuid "65f14810-2d7e-45a9-948d-fe2f4edf79ab",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "~~I/O 编址~~"}],
       :block/content "液压站控制系统项目（已完成）"}
      {:block/id #uuid "65f25194-5194-4223-9c59-6808da9f0594",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f2519d-c1b8-449d-9ceb-470e30b6136a",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content
         "![image.png](../assets/image_1710379596719_0.png)\n学会了变址寄存器和程序控制FOR循环的使用。"}
        {:block/id #uuid "65f25265-d9d5-4e14-a992-7c9a169eba4e",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content
         "![image.png](../assets/image_1710379680650_0.png)\n很简单，乏善可陈。"}
        {:block/id #uuid "65f252ab-d069-450c-8fdc-0962da88cea3",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content
         "![image.png](../assets/image_1710380668315_0.png)\n![image.png](../assets/image_1710380726843_0.png)\n上升沿并不会在接通的一瞬间开始执行，同样需要遵循从上到下的原则，即需要等待前方的语句执行完毕才会执行，即使前方的语句是非上升沿。 \n#+BEGIN_NOTE\n相乘和单字相乘有区别，此处需要使用单字相乘。\n指令（MUL）将两个16位整数相乘，并产生一个32位的结果（OUT）。\n指令（MULW）将两个16位整数相乘，并产生一个16位的结果。\n指令（MULD）将两个32位整数相乘，并产生一个32位的结果。\n![image.png](../assets/image_1710382869518_0.png) \n如上图，指令（MUL）产生一个双字结果，此时D1用于储存高位，D0用于储存低位。此时D0显示的实际上是D1D0，因为D1为10（16# 000A），故D0为655360（16# 000A 0000）。\nMUL运算后，D0变为双字1000（16# 0000 03E8），会导致D1变为0（16# 0000）。\n#+END_NOTE"}
        {:block/id #uuid "65f2576e-8b9b-419c-8ecb-dd8ecbd04eed",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content
         "![image.png](../assets/image_1710380998620_0.png)\n简单。"}],
       :block/content "SK和PLC试题"}],
     :block/content "**项目记录**"}
    {:block/id #uuid "65f14810-f55d-4957-8c71-2aded45723ad",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14810-845c-4576-8360-e1c1fa1f7a3e",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "首先定义I/O需要对梯形图编程非常熟悉，或者有真实的项目和设备。否则极易多定义或少定义输入输出；"}
      {:block/id #uuid "65f24deb-9651-4b53-933a-5f2418c84253",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "从组态入手更为合适，在设计组态的过程中定义需要的寄存器；"}
      {:block/id #uuid "65f24e52-19e8-48c3-bee8-7b17acc71ec4",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "PLC编程中，通电置位后断开并不会自动复位。需要在下降沿增加复位；"}
      {:block/id #uuid "65f24ea3-db91-4155-9590-0e7c379d0768",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "多种停止条件需综合考虑，并成一个停止位，避免不同停止条件之间相互冲突。"}
      {:block/id #uuid "65f26120-e8b7-4730-b6e5-7777c6e9d756",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "和绝大多数编程语言一样，梯形图编程需要特别注意**数据类型**。"}],
     :block/content "**项目总结**"})}
  {:block/id #uuid "660a4f29-1a6f-4295-8a81-f4a19339c28f",
   :block/page-name "Mar 27th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66037511-e523-43b6-ad23-b8e39b5b22be",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "{{query }}"})}
  {:block/id #uuid "6625fcd2-3999-4b15-b031-bc3d36bd8373",
   :block/page-name "🗂️Project",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14811-4a01-431a-a4bb-1d8b8bd684bd",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "DONE [[Project. Charmander]]"}
    {:block/id #uuid "65f14811-4235-4c25-bfe1-5ca2fa1add3b",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "WAITING [[Project. Carterpie]]"}
    {:block/id #uuid "660a4f29-5e4e-4d8c-b270-25a7915e048a",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "IN-PROGRESS [[Project. Arceus]]"}
    {:block/id #uuid "6616bb3d-e8f9-4523-9b30-5fed80c1bd09",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "IN-PROGRESS [[Project. Spearow]]"})}
  {:block/id #uuid "660a4f29-a42d-4914-abd9-eb3c72e449f0",
   :block/page-name "Mar 22nd, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "65fcdb14-f11a-40dd-be54-c8bb7350117b",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "6615e601-5aca-48d0-9d2c-9d375af7bc9b",
   :block/page-name "Apr 10th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "6615e6a0-42fa-4b9b-8740-4a76e42c7516",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "\"Pressure is privilege.\" 是什么高压锅slogan吗？ #balderdash"}
    {:block/id #uuid "6615e6ed-5bbc-4690-a84c-bc7c7489c860",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "87.2 kg  #Weight"})}
  {:block/id #uuid "6625fcd2-5273-4105-a9e0-fe0818c3baef",
   :block/page-name "📆TODO",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14811-6798-4743-9f4f-7dc0ee5af0b0",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14811-34db-4fd9-a57a-a3f01a049495",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "{{query(task NOW)}}"}],
     :block/content
     "**DOING**\n:LOGBOOK:\nCLOCK: [2024-03-08 Fri 10:30:10]\n:END:"}
    {:block/id #uuid "65f14811-d564-4f40-9c8e-d68c7b02441f",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14811-1098-42f5-ab18-478197adc30a",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "{{query(task LATER)}}"}],
     :block/content "**TODO**"}
    {:block/id #uuid "65f14811-9edb-442c-81c8-5af64cf67fc7",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14811-1054-4223-950f-2587cbf42c57",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "{{query(task WAITING)}}"}],
     :block/content "**WATING**"}
    {:block/id #uuid "66021bdf-23ff-4af5-9744-819f1b2d1f26",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "660a4f29-6400-485d-9fac-470c68b1c33b",
   :block/page-name "Bus",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14810-ebdf-4ad1-be7f-6f2b9c86650e",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[Modbus]]"}
    {:block/id #uuid "65f14810-36ef-4872-85d8-eafde656d2c8",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[EtherCAT]]"})}
  {:block/id #uuid "662622fe-ead9-4a5a-9e9d-77ef12504edc",
   :block/page-name "体系结构",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "662790a2-5c57-49fe-847a-f4449a806995",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 概念和体系结构"}
    {:block/id #uuid "662790ba-8d30-4780-b2f2-37970b0f5db6",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 工作模式"}
    {:block/id #uuid "662790bc-7e12-4c4b-97a1-60e89b67cb9c",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 指令集"}
    {:block/id #uuid "662790c0-4041-4144-8358-42639f361719",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 寻址方式"}
    {:block/id #uuid "662790da-6e9a-4555-b5f1-97651e1b6ec5",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 寄存器"}
    {:block/id #uuid "662790de-b736-40fa-ba42-579c77201127",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 内存管理单元"}
    {:block/id #uuid "662790e2-97c4-4564-80c5-a993ea008f02",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 常见接口和控制器"}
    {:block/id #uuid "662790ea-ecb9-475c-a914-6cdfe75faef6",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 通用编程模型"})}
  {:block/id #uuid "66262066-b293-4c21-9f51-99bc4ef03d58",
   :block/page-name "嵌入式底层开发",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66262511-42c0-42b9-914c-e4714322d2dc",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[可运行系统]]"}
    {:block/id #uuid "6626251a-6798-46ae-9e12-4f4d223fd897",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[Linux 内核编程]]"}
    {:block/id #uuid "6626252c-8dfa-4d65-a14b-23e292efc135",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[Linux 驱动开发]]"})}
  {:block/id #uuid "6626252c-ed9a-498d-8092-6a5af0c5727f",
   :block/page-name "Linux 内核编程",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66279455-9949-4ff0-be4d-14e6296c98bf",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66279464-0520-4240-ad48-988887ba2fde",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 内存寻址和管理"}
      {:block/id #uuid "66279469-a848-4f2c-a805-7a4d115153f4",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 并发和竞态"}
      {:block/id #uuid "6627947c-1002-4a6f-a644-f9c071fd2d23",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 同步"}
      {:block/id #uuid "6627948e-20f8-40e5-b299-12d9c9170423",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 内核中断"}
      {:block/id #uuid "66279491-ca77-48be-8149-6ee549907b6f",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 异常处理"}
      {:block/id #uuid "66279496-a407-47f0-9e2a-54268f3f2261",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 内核定时器原理"}
      {:block/id #uuid "6627949c-5221-49d1-8bd9-3966bec35196",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 内核同步原理"}
      {:block/id #uuid "662794a0-f242-4d0d-b32c-6ed09e61dd93",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 异步通知和异步I/O"}
      {:block/id #uuid "662794a9-ec4c-4b30-8e9c-a7c11cfbc7dc",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 阻塞和非阻塞I/O"}
      {:block/id #uuid "662794c2-df68-4f52-a954-6a943b9b82a5",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content ""}],
     :block/content "## 内核重要机制/概念"}
    {:block/id #uuid "662794cb-1da4-4442-9e47-fe591eeb6869",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "662794dd-b89b-4871-b5ea-e805bcf47039",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 内存管理的基本框架和原理"}
      {:block/id #uuid "662794e5-cb56-4f5e-8ebb-db7c61deca9e",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 段/页/区以及操作"}
      {:block/id #uuid "662794ee-ef70-4bd3-a4f0-57d2bebd72a4",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 内存映射"}
      {:block/id #uuid "662794f1-37a9-4187-8555-ff363f9e2851",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### slab层原理和接口"}
      {:block/id #uuid "662794f7-39c2-4c49-85f0-a26a23582cfc",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 内存池"}
      {:block/id #uuid "66279500-2c42-4920-b432-857068605637",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 进程地址空间原理"}],
     :block/content "## 内存寻址与管理"}
    {:block/id #uuid "66279505-2980-4823-802e-641a46f1c497",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "6627950b-0f20-4390-b5fe-021d0b20f4a0",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 进程描述符及任务结构"}
      {:block/id #uuid "66279514-4a90-46b2-bd65-52c2a8d5df3a",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 进程控制实践和原理"}
      {:block/id #uuid "6627951a-b422-4503-8691-ddbf7e4bf186",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 进程调度策略和算法"}
      {:block/id #uuid "66279520-d2a8-48d5-9cbf-e6e46ad77ef5",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 内核锁机制"}
      {:block/id #uuid "66279524-e9ed-4918-9114-48a55216f181",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 进程间通信"}],
     :block/content "## 进程"}
    {:block/id #uuid "6627968b-6205-4021-8182-960ac85712ef",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66279690-e51c-4eba-96d7-2a17605e9e22",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 临界区和竞争条件"}
      {:block/id #uuid "66279696-c25d-4d52-bc3e-68619fc19cb8",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 死锁原理"}
      {:block/id #uuid "6627969c-f897-4889-8162-5726b73d1d8a",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 内核同步访问"}],
     :block/content "## 内核同步原理"}
    {:block/id #uuid "662796a1-46ee-4a89-91bd-b4be418862e9",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "662796a8-f5af-4b46-b249-ba7651cb8d4c",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 原子操作"}
      {:block/id #uuid "662796ae-05ed-4d85-b9ff-67694ee9dfeb",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 屏障"}
      {:block/id #uuid "662796b4-b4a0-4911-9f72-eba35d55915b",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 自旋锁"}
      {:block/id #uuid "662796b9-7489-4a42-bf01-e395ba395eb2",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 读写锁"}
      {:block/id #uuid "662796bd-032c-48d1-a7cb-3868bbfd8f55",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 信号量"}
      {:block/id #uuid "662796c2-ca64-4a06-87e0-0e64c1218568",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 互斥体"}],
     :block/content "## 并发与竞争"}
    {:block/id #uuid "662796c5-aaae-48d1-94bf-cf03c2df50ef",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "662796cd-ae38-4521-bb1f-ba8d64cabe40",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 定时器类型"}
      {:block/id #uuid "662796d2-7fc1-4f27-8363-7870f0e07d85",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 普通定时器实现"}
      {:block/id #uuid "662796d5-8aac-47a8-88e5-3f4cff0eeb26",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 高精定时器实现"}
      {:block/id #uuid "662796dc-43a0-46e1-b59f-5ae31ff152df",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 动态时钟"}
      {:block/id #uuid "662796e1-ca19-43b3-b2f3-d5db8a88549f",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 时钟中断处理"}
      {:block/id #uuid "662796e5-676b-4ccc-a77e-acffaa3cfebd",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 延迟执行"}],
     :block/content "## 定时器"}
    {:block/id #uuid "662797d2-423f-4fb7-937f-e1ad37c3d7b0",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "662797d9-f675-4569-9e86-fbfebbf1695c",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 中断基础（概念/作用/类型/体系/框架）"}
      {:block/id #uuid "662797eb-1233-4274-be99-be037f38461e",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 机制原理和实现"}
      {:block/id #uuid "662797f2-45ba-4772-8801-3802a86986e9",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 中断处理流程和架构"}
      {:block/id #uuid "662797f9-a51a-4b16-8017-002cd0af5a60",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 中断上下文"}
      {:block/id #uuid "662797fe-5a61-4755-8c53-48373d18de7e",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 中断控制"}
      {:block/id #uuid "66279801-6ec9-4069-8573-a117cc287e86",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 硬/软中断"}
      {:block/id #uuid "66279808-e8e3-43b4-830d-eb2db3a4cb7c",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 中断系统重要数据结构"}],
     :block/content "## 中断"}
    {:block/id #uuid "6627980e-ba08-4ef9-aad2-11c15e619347",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66279813-0030-4261-b0a2-38f8fc18db2a",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 通用文件模型和接口"}
      {:block/id #uuid "66279819-bec8-44b1-8506-31ab3ae9a815",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 相关数据结构"}
      {:block/id #uuid "66279820-b912-4bed-b721-3e2cf8ea8622",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 文件系统类型"}
      {:block/id #uuid "66279825-3709-4b3e-b829-b5f500a95902",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 文件系统内部处理"}
      {:block/id #uuid "6627982a-f24f-448e-aecc-8f941e2f35d3",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 系统调用原理和实现"}],
     :block/content "## 文件系统"}
    {:block/id #uuid "66279832-4dc1-4d71-bf9a-8c7f6cb69a1d",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66279836-107d-4fe0-a101-4746ef99de2e",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### TCP/IP协议原理"}
      {:block/id #uuid "66279840-d8fe-47f8-950e-609edd1d4d80",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 网络分层"}
      {:block/id #uuid "66279846-ec73-4300-b099-21e288ebe90f",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 传输层通信"}
      {:block/id #uuid "6627984a-5fa7-491f-8350-a5dd2d884e2b",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 套接字通信"}
      {:block/id #uuid "6627984e-4e68-42b4-94e1-33412ad63e22",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 缓冲区"}],
     :block/content "## 网络通信"})}
  {:block/id #uuid "6626230e-76f9-4da5-993d-109da0ad9cad",
   :block/page-name "嵌入式裸机",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "662790f7-8048-4baf-a9c3-a8c7ed446a1c",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66279110-e40f-4974-98dc-df957b9f13ad",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 典型电路"}
      {:block/id #uuid "66279114-48ab-4917-976b-deb7f40902b1",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 相关寄存器"}
      {:block/id #uuid "66279119-9884-4e26-86c3-65368352fceb",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 工作模式"}],
     :block/content "## GPIO"}
    {:block/id #uuid "6627911b-8b49-4fbf-b248-42435cc181e6",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66279126-f911-4915-96b3-8555d833537c",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 中断体系"}
      {:block/id #uuid "6627912d-ac8c-48c5-bee5-bdc7f6ea29d0",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 中断向量表"}
      {:block/id #uuid "6627913d-9338-4a6f-8721-1fa252ca71be",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 优先级、嵌套"}
      {:block/id #uuid "66279142-e9de-4d33-b270-9f60426f83d5",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 中断处理流程"}
      {:block/id #uuid "66279149-b6cb-4573-bd41-d921d92ec0f7",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 中断控制器"}
      {:block/id #uuid "6627914d-238c-4de9-9c13-3d17e5a7914e",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 主要寄存器操作"}
      {:block/id #uuid "66279151-da91-4f91-962b-664c552b36b8",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 外部中断"}],
     :block/content "## 中断"}
    {:block/id #uuid "66279156-ba9a-4c22-b722-e47ddc7dc8ac",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "6627915d-2173-4d39-a155-3f687620ec37",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 时钟体系和结构"}
      {:block/id #uuid "66279165-c10b-4a9c-9587-694bd5fff8d9",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 关键寄存器控制"}
      {:block/id #uuid "6627916b-f213-4a52-bb17-d004b19dea0d",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### PMW定时器"}
      {:block/id #uuid "6627916f-a84f-4c8f-9f6e-f14945fe01f9",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 看门狗定时器"}
      {:block/id #uuid "66279173-a239-4c82-ac92-52f567be2e28",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 实时时钟RTC"}],
     :block/content "## 定时器"}
    {:block/id #uuid "6627917a-19ef-4a91-90c9-dc53d4c91b50",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "6627917e-a4d7-43a2-8e39-450411bb14e6",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### Flash"}
      {:block/id #uuid "66279183-2061-4194-9b09-730c8077f2c1",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### SD/TF"}],
     :block/content "## 储存器"}
    {:block/id #uuid "66279188-29bd-4e5e-8ee6-a8ee3683c4f7",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "6627919e-d413-4519-a544-e2281f920cb9",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### UART"}
      {:block/id #uuid "662791a2-9223-4ef6-84ed-764f733b2dee",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### II C"}
      {:block/id #uuid "662791a7-fa46-4ab1-99e5-b8d2f314fe83",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### SPI"}
      {:block/id #uuid "662791aa-4bca-4243-a183-c1b33b9bb308",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### IIS"}
      {:block/id #uuid "662791ac-b37e-4f89-8352-8ac10e9d8559",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### USB"}
      {:block/id #uuid "662791b0-95fc-4eec-86ea-cc522022e285",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### CAN"}
      {:block/id #uuid "662791b5-44bf-4cdd-969e-c5aa80c26b08",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### LIN"}
      {:block/id #uuid "662791b9-3fc3-4880-bfec-ccb64ec4e55d",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### TCP/IP"}
      {:block/id #uuid "662791be-fc73-47e1-a161-526e9f52279e",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### EtherCAT"}],
     :block/content "### 协议/接口/总线"}
    {:block/id #uuid "662791c5-11f0-48ba-a85b-48418a98ba8d",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "662791ce-f63a-4c91-a5f3-adf350d3b0b2",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 蓝牙"}
      {:block/id #uuid "662791d6-3cad-4171-b2de-ab18de55ffc1",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### WIFI"}
      {:block/id #uuid "662791d9-0bb0-471e-a31c-77c88db42339",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### ZigBee"}
      {:block/id #uuid "662791de-2a74-40fe-adb7-8f08f845ce71",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### RF"}],
     :block/content "## 无线模块"}
    {:block/id #uuid "662791e2-cb66-44e2-9b0e-c55cc633e6be",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "662791ef-cb9b-42fd-8316-ffac60b8aa87",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 温度"}
      {:block/id #uuid "662791f5-4c4b-4aa5-9aa6-b8c79f0adc7a",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 湿度"}
      {:block/id #uuid "66279200-27c7-4641-9b88-8ebb5e7d9efe",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 光敏"}
      {:block/id #uuid "66279205-b6d3-4a72-bd55-003dbd4759eb",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 压力"}
      {:block/id #uuid "66279209-8e2a-4472-acf1-bcf84035afe3",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 触摸感应"}
      {:block/id #uuid "6627920e-392d-4769-8b20-0cdcfae2031b",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 红外"}
      {:block/id #uuid "66279215-7734-48a4-ac4f-4425e9121a05",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 多轴传感器"}
      {:block/id #uuid "6627921f-79de-46e0-bc40-97595476cafc",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### GPS"}],
     :block/content "## 传感器"}
    {:block/id #uuid "66279223-8b28-4e25-b760-28164b70083c",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66279228-bec5-44ec-acea-63485278c0d9",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 工作原理"}
      {:block/id #uuid "6627922d-d00e-44fc-894e-509574aabd23",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 参数指标"}
      {:block/id #uuid "66279233-3a15-4231-9461-f899d4bee25c",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 寄存器操作"}],
     :block/content "## AD转换"}
    {:block/id #uuid "6627923b-b090-4617-b823-e790ef2897b2",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66279241-c923-4065-bed6-2aa385b47ad4",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### LCD"}
      {:block/id #uuid "66279246-403b-4a78-984d-014d94cbe8d4",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 触摸屏"}],
     :block/content "## 显示模块"})}
  {:block/id #uuid "663ace8e-f7e1-4a65-ae9e-1eda1f0ccc3a",
   :block/page-name "May 8th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "663ace8f-e5c5-45c0-90fd-93c90d9db2b2",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "88.65 kg #Weight"}
    {:block/id #uuid "663ace9d-397a-4275-a3f5-3f7a5c86a7e1",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "老骥伏枥，藿香正气 #balderdash"})}
  {:block/id #uuid "660a5a11-2309-49d1-bced-53751d06ba39",
   :block/page-name "hls__C++_Primer_3rd_Edition_1711954422504_0",
   :block/properties
   {:file
    "[C++_Primer_3rd_Edition_1711954422504_0.pdf](../assets/C++_Primer_3rd_Edition_1711954422504_0.pdf)",
    :file-path "../assets/C++_Primer_3rd_Edition_1711954422504_0.pdf"},
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "660a5a11-bf1a-4743-b18f-473179ec9d54",
     :block/properties
     {:file
      "[C++_Primer_3rd_Edition_1711954422504_0.pdf](../assets/C++_Primer_3rd_Edition_1711954422504_0.pdf)",
      :file-path
      "../assets/C++_Primer_3rd_Edition_1711954422504_0.pdf"},
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "6625fcd2-d2f8-45cf-9b63-a29c85436b63",
   :block/page-name "🏠Home",
   :block/properties {:query-table false, :page-type "home"},
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "6613c24c-44f2-402f-9711-9a8f79e1e8e2",
     :block/properties {:query-table false, :page-type "home"},
     :block/format :markdown,
     :block/children [],
     :block/content
     "#+BEGIN_QUERY\n {:title [:h1.font-bold \"TODO Today\"]  ; this is new, it's a title!\n :query [:find (pull ?b [*])   ; find me a bunch of blocks\n :where\n (task ?b #{\"NOW\"})          ; any task ?b that is LATER\n ] :collapsed? false}\n#+END_QUERY"}
    {:block/id #uuid "66142990-50bb-48a7-b715-5586dfbd9da9",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "#+BEGIN_QUERY\n{:title [:h1.font-bold\" ️DeadLine\"]\n  :query [:find (pull ?b [*])\n  :in $ ?start ?next\n  :where\n  [?b :block/deadline ?d]  ;;任务标记了deadline \n  [?b :block/marker ?marker]\n  [(>= ?d ?start)]\n  [(< ?d ?next)]\n  [(contains? #{\"NOW\" \"LATER\" \"DOING\" \"TODO\"} ?marker)]]  ;;任务标记关键词\n  :inputs [:today :7d-after]   ;;检索未来7天的DeadLine\n  :collapsed? false\n  :breadcrumb-show? false}   ;;检索结果是否显示面包屑路径\n#+END_QUERY"}
    {:block/id #uuid "6616bb0a-d96f-44ab-a347-49c6f805fd30",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "#+BEGIN_QUERY\n {:title [:h1.font-bold \"IN-PROGRESS Projects\"]\n :query [:find (pull ?b [*])\n :where\n (task ?b #{\"IN-PROGRESS\"})\n [?b :block/page ?page]\n [?page :block/name \"🗂️project\"]\n ] :collapsed? false}\n#+END_QUERY"}
    {:block/id #uuid "6614e48b-1881-4529-97bb-b33688def472",
     :block/properties {:query-table true},
     :block/format :markdown,
     :block/children [],
     :block/content
     "#+BEGIN_QUERY\n  {:title [:h1.font-bold \"Unsolved Problems\"]\n   :query [:find (pull ?b [*])\n   :where\n     (page-ref ?b \"？\") \n     (not (page-ref ?b \"。\"))\n]\n  :breadcrumb-show? false\n  :collapsed? true}\n#+END_QUERY"}
    {:block/id #uuid "66138333-330e-4a5b-a65d-f89547a5f971",
     :block/properties {:query-table false},
     :block/format :markdown,
     :block/children [],
     :block/content
     "#+BEGIN_QUERY\n {:title [:h1.font-bold \"Unorganized Note\"]\n :query [:find (pull ?b [*])\n :where\n[?b :block/page ?p]\n [?p :block/name \"📔temp\"]\n ]\n :collapsed? trur}\n#+END_QUERY"}
    {:block/id #uuid "6614162b-3e77-4d5f-9b71-7a7320310187",
     :block/properties {:query-table false},
     :block/format :markdown,
     :block/children [],
     :block/content
     "#+BEGIN_QUERY\n  {:title [:h1.font-bold \"Daily Balderdash\"]\n   :query [:find (pull ?b [*])\n   :in $ ?today\n   :where\n     (page-ref ?b \"balderdash\") \n     [?b :block/page ?page]\n     [?page :block/journal? true]\n           \n     [?page :block/journal-day ?day]\n     [(= ?day ?today)]\n]\n  :breadcrumb-show? false\n  :inputs     [:today]\n  :collapsed? false}\n#+END_QUERY"}
    {:block/id #uuid "6615e738-ff2e-4bb3-b1ad-533f29b8c513",
     :block/properties {:query-table true},
     :block/format :markdown,
     :block/children [],
     :block/content
     "#+BEGIN_QUERY\n  {:title [:h1.font-bold \"7 Days' Weight\"]\n   :query [:find (pull ?b [*])\n   :in $ ?today ?start\n   :where\n     (page-ref ?b \"weight\") \n     [?b :block/page ?page]\n     [?page :block/journal? true]\n           \n     [?page :block/journal-day ?day]\n     [(<= ?day ?today)]\n     [(> ?day ?start)]\n\n]\n  :breadcrumb-show? false\n  :inputs     [:today :7d-before]\n  :collapsed? false}\n#+END_QUERY"})}
  {:block/id #uuid "660a5cc2-14e6-4ebc-bddb-6afc18a65099",
   :block/page-name "hls__C++Primer_4th_Edition_1711954437042_0",
   :block/properties
   {:file
    "[C++Primer_4th_Edition_1711954437042_0.pdf](../assets/C++Primer_4th_Edition_1711954437042_0.pdf)",
    :file-path "../assets/C++Primer_4th_Edition_1711954437042_0.pdf"},
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "660a5cc2-ed30-4b9b-af11-ef0821023195",
     :block/properties
     {:file
      "[C++Primer_4th_Edition_1711954437042_0.pdf](../assets/C++Primer_4th_Edition_1711954437042_0.pdf)",
      :file-path
      "../assets/C++Primer_4th_Edition_1711954437042_0.pdf"},
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "66261c41-3096-4bc4-b2df-f0bf5c4b4792",
   :block/page-name "数据结构与算法",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66261c45-15dc-41e2-957c-8116f0bb4e3c",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66261c4a-6c61-4308-9fb2-4ce61f23c38f",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 字符串"}
      {:block/id #uuid "66261c57-ebe9-4a5d-9f50-94439d0efb6c",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 数组"}
      {:block/id #uuid "66261c5b-7909-42d0-9923-aef5ee507e99",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 链表"}
      {:block/id #uuid "66261c5f-1231-4794-aaf8-e762ccd5d75b",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 堆"}
      {:block/id #uuid "66261c63-919b-4fc8-8226-14e05c9e30d1",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 栈"}
      {:block/id #uuid "66261c6a-d93d-47e8-9154-d622f7e78b29",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 队列"}
      {:block/id #uuid "66261c75-d74c-4dc3-99a9-285147a75309",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 树"}
      {:block/id #uuid "66261c7a-d5b9-4298-8792-987bb03b49c3",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 哈希"}
      {:block/id #uuid "66261c7d-2c44-49d3-8fdd-662fa99ac99e",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 图"}],
     :block/content "### 数据结构"}
    {:block/id #uuid "66261c81-4fd9-4768-b0dd-0e187a11510a",
     :block/properties {:heading 3},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66261c8a-0cff-4762-85cf-b99372abfbe5",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 查找"}
      {:block/id #uuid "66261c8e-f6eb-4b9c-9951-b258aa091638",
       :block/properties {:heading 4},
       :block/format :markdown,
       :block/children [],
       :block/content "#### 排序"}],
     :block/content "### 算法"})}
  {:block/id #uuid "660ada03-17fe-474c-8bd0-e688612bfffe",
   :block/page-name "Apr 2nd, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "660ada03-a8a7-4a0a-af5c-c925d2971b43",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "66382ccc-df9b-41d7-b1fd-fc8271814e51",
   :block/page-name "May 6th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66382ccd-dd44-4d4e-b7f5-67846d0e15e8",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "90 kg #Weight"}
    {:block/id #uuid "66382cda-47f3-427f-9373-e69cb5aed887",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "65f14810-ee90-4508-ae61-06974da73530",
   :block/page-name "Mar 14th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "65f24ce6-38c1-42ee-bd43-55bb6273bf07",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "DONE [[电子凸轮]]功能学习 #📓Note/\nDEADLINE: <2024-03-27 Wed 18:00 .+1d>\n:LOGBOOK:\nCLOCK: [2024-03-14 Thu 15:50:12]\nCLOCK: [2024-03-14 Thu 15:50:14]\nCLOCK: [2024-03-14 Thu 15:50:28]--[2024-03-14 Thu 17:10:34] =>  01:20:06\n* State \"DONE\" from \"NOW\" [2024-03-14 Thu 17:10]\nCLOCK: [2024-03-15 Fri 09:00:09]--[2024-03-15 Fri 11:37:00] =>  02:36:51\n* State \"DONE\" from \"NOW\" [2024-03-15 Fri 11:37]\n* State \"DONE\" from \"LATER\" [2024-03-15 Fri 14:56]\nCLOCK: [2024-03-15 Fri 14:56:40]--[2024-03-15 Fri 16:58:20] =>  02:01:40\nCLOCK: [2024-03-15 Fri 16:58:22]--[2024-03-15 Fri 16:58:26] =>  00:00:04\n* State \"DONE\" from \"LATER\" [2024-03-15 Fri 16:58]\nCLOCK: [2024-03-15 Fri 16:58:39]--[2024-03-15 Fri 16:58:40] =>  00:00:01\nCLOCK: [2024-03-18 Mon 09:06:50]--[2024-03-18 Mon 11:31:07] =>  02:24:17\n* State \"DONE\" from \"NOW\" [2024-03-18 Mon 11:31]\nCLOCK: [2024-03-18 Mon 13:15:24]--[2024-03-19 Tue 09:03:00] =>  19:47:36\nCLOCK: [2024-03-20 Wed 17:04:46]--[2024-03-20 Wed 18:05:02] =>  01:00:16\nCLOCK: [2024-03-21 Thu 09:06:12]--[2024-03-22 Fri 13:18:06] =>  28:11:54\n* State \"DONE\" from \"LATER\" [2024-03-27 Wed 17:58]\nCLOCK: [2024-03-27 Wed 17:58:56]--[2024-03-27 Wed 17:58:58] =>  00:00:02\n* State \"DONE\" from \"NOW\" [2024-03-27 Wed 17:58]\n* State \"DONE\" from \"LATER\" [2024-03-27 Wed 18:00]\nCLOCK: [2024-03-27 Wed 18:00:17]--[2024-03-27 Wed 18:00:19] =>  00:00:02\n* State \"DONE\" from \"NOW\" [2024-03-27 Wed 18:00]\nCLOCK: [2024-03-27 Wed 18:00:47]--[2024-03-27 Wed 18:00:48] =>  00:00:01\n* State \"DONE\" from \"LATER\" [2024-03-27 Wed 18:01]\n:END:"})}
  {:block/id #uuid "660a4f29-a76c-434e-a6f1-bd76eb27d80c",
   :block/page-name "Automation",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14810-5b55-415f-99b7-f5f0775e97ec",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[Control]]"}
    {:block/id #uuid "65f14810-cfeb-407f-936d-496bd8c3f376",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[PLC]]"}
    {:block/id #uuid "65f14810-8c8f-4689-afea-a50a84f5bcfd",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[Communication]]"})}
  {:block/id #uuid "660a4f29-22ca-4b17-ac16-8e18bbee96a6",
   :block/page-name "Control",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14810-fc73-424f-86f1-534646bf1cfb",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[Driver]]"}
    {:block/id #uuid "65f14810-c770-4886-92f0-018e31a64716",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "65f40dec-1f1a-49f8-a0e3-f39b6ea641da",
   :block/page-name "伺服驱动器",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "65faacc7-f458-4b78-ab2a-515a47528d8f",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65faacfd-98ad-43ac-82df-4d2a7ffd3537",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "脉冲型伺服驱动器和总线型伺服驱动器的接线和使用方法存在较大区别，应注意。"}
      {:block/id #uuid "65faad3a-14b8-4898-921f-9b6308de7cd0",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65fab259-8cfd-4c91-9669-350ebab32676",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "使用指令端子CN1，为DB44芯插头。包含脉冲和方向输入引脚、开关量输入引脚、开关量输出引脚以及编码器反馈输出引脚。\n![image.png](../assets/image_1710927329902_0.png)\n|功能|端子标号|名称|说明|\n|脉冲输入|35|PS_24V|连接PLC 24V电源|\n||43|PULS-|单端脉冲输入信号/差分脉冲输入负|\n||41|PULS+|差分脉冲输入正|\n||39|SIGN-|单端方向输入信号/差分脉冲输入负|\n||37|SIGN+|差分脉冲输入正|\n|输入输出|9|DIN1|输入1（默认：伺服使能）|\n||10|DIN2|输入2（默认：报警清除）|\n||34|DIN3|输入3（默认：正向驱动禁止）|\n||8|DIN4|输入4（默认：负向驱动禁止）|\n||11|COM|输入公共端|\n||1|DO1+|输出1（默认：伺服准备好）|\n||16|DO1-||\n||3|DO2+|输出2（默认：定位完成）|\n||2|DO2-||\n||5|DO3+|输出3（默认：抱闸输出）|\n||4|DO3-||\n||7|DO4+|输出4（默认：故障输出）|\n||6|DO4-||\n|模拟量|32|AIN1+|模拟量输入通道1，-10V~10V|\n||17|AIN1-||\n||18|AIN2+|模拟量输入通道2，-10V~10V|\n||19|AIN2-||\n|分频输出|25|PAO+|分频差分输出（5V电平）|\n||24|PAO-|信号源可选择为编码器或指令脉冲|\n||22|PBO+||\n||23|PBO-||\n||20|PCO+||\n||21|PCO-||\n||44|OZ|单端Z脉冲输出|\n||29|GND|驱动器数字地|\n|RS485|12|485/A|支持MODBUS通信|\n||13|485/B||"}
        {:block/id #uuid "65fab26a-17d6-4ffa-aaf2-770fea50b984",
         :block/properties {},
         :block/format :markdown,
         :block/children [],
         :block/content
         "单端脉冲输入接线\n![image.png](../assets/image_1710928506929_0.png)\n#+BEGIN_CENTER\nNPN接法\n#+END_CENTER\n![image.png](../assets/image_1710928567315_0.png)\n#+BEGIN_CENTER\nPNP接法\n#+END_CENTER"}
        {:block/id #uuid "65fab3ef-9390-4d10-a5e7-2e7ce8793f34",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "差分脉冲输入接线\n![image.png](../assets/image_1710928913587_0.png)"}
        {:block/id #uuid "65fab412-bd1e-41dc-acc2-323a90225925",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "数字量输入接线\n![image.png](../assets/image_1710928941446_0.png)"}
        {:block/id #uuid "65fab42f-6861-4b59-9c25-9c85c7bd357c",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "模拟量输入接线\n![image.png](../assets/image_1710928980043_0.png)"}
        {:block/id #uuid "65fab455-6764-4897-8823-22eaab95fa25",
         :block/properties {},
         :block/format :markdown,
         :block/children [],
         :block/content
         "编码器分频输出接线\n![image.png](../assets/image_1710929034278_0.png)"}],
       :block/content "脉冲型"}
      {:block/id #uuid "6603ddba-4be8-4d91-adb1-398bfcc14f7b",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "6603ddbd-b901-4661-bc16-85a85281b7cf",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "接网线即可。"}],
       :block/content "总线型"}],
     :block/content "## 配线及端子定义"}
    {:block/id #uuid "6603de43-dbb7-4f10-8015-5dc04cb8291a",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "6604c792-f4fa-45cc-a0aa-2bb756f3b291",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "6603de4c-59e4-49ed-b018-2401e87b1b6e",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "电子齿轮比：伺服电机旋转一周，伺服驱动器接收到的电机编码器脉冲数（经倍频后）与驱动器接收到的控制驱动脉冲数（由上位控制器发送给驱动器的）的比值。"}
        {:block/id #uuid "6603dfba-5f58-49f8-aa91-9cb57d8ad4ae",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "编码器分辨率：伺服电机轴旋转编码器反馈脉冲数。"}
        {:block/id #uuid "6603e2f5-6bd7-42cb-a31d-642eeb2f93e2",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "脉冲当量：上位机发送一个脉冲，旋转轴转动的度数，也是控制系统所能控制的最小度数；脉冲当量越小，控制精度越高。"}
        {:block/id #uuid "6603e353-c5e9-4320-b3d3-f200ca2b583c",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "单圈脉冲数：电机转动一圈所需的脉冲数。"}],
       :block/content "**主要概念**"}
      {:block/id #uuid "6604c7b7-a93f-488c-aadd-a3920b8054ef",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "6604c7cb-ec27-4e72-9734-f374e57a6cf5",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "为验证PLC极限频率（200kHz）脉冲发射的准确性，需要将电机的转速设置为200000 units/s，位移设置为2000000 units，共运行10s。\n***——此处引用一个电机转速和脉冲关系的块——***\n为了避免电机转速过快引起危险，设置电子齿轮比为1/1000000，单圈脉冲数为100000，负载轴一圈移动量为1。"}
        {:block/id #uuid "6604d365-5547-46cc-94da-2fb23dbcb901",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "经测试，电机轴会在10s内旋转1.5r，转速约为0.15 r/s。"}
        {:block/id #uuid "6604d44d-2b23-4a3e-b62f-7e35792ce013",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "~~若PLC如预期每秒发射200000个脉冲，单圈脉冲数为100000，转速应为2 r/s？~~"}
        {:block/id #uuid "6604d513-66da-4a57-bd56-66dbe96fa6d4",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "~~电机轴与负载轴之间的齿轮比（非电子齿轮比？）为1/1000000，因此电机的位移应该为2 r？~~"}
        {:block/id #uuid "6604db07-2888-4176-a2dd-e6063e388ed1",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "#+BEGIN_IMPORTANT\n通过读取寄存器OP451（轴号7）的值，可知实际齿轮比为16960。\n电机使用17位绝对值编码器，单圈脉冲数为$2^{17}$，即131072。\n#+END_IMPORTANT"}
        {:block/id #uuid "6604db72-2b51-4063-9c52-98bfbc87dec4",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "当实际齿轮比为1/16960时，负载轴位移2000000，电机轴位移应为？？？"}
        {:block/id #uuid "6604e07a-6986-4fd6-a643-d119155d6d2c",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "切换了伺服中齿轮比后，电机转速未有明显区别，寄存器OP451也无变化，仍为16960。"}
        {:block/id #uuid "6604e730-0539-43e0-b58f-e34d4bae5dea",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "#+BEGIN_NOTE\n当单圈脉冲数修改为131072后，电机10s内旋转2r。符合预期。\n说明齿轮比为1000000而非16960？\n将齿轮比设置为500000后，电机10s内旋转4r，说明寄存器OP451值不对。（500000超过了$2^{16}$导致？）\n#+END_NOTE"}
        {:block/id #uuid "6604cc31-aa01-40f7-b98a-e19f30a0b5f5",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "#+BEGIN_NOTE\n在SamProIDE中设置的齿轮比，是指电机轴和负载轴之间的变速关系，而非伺服中的电子齿轮比？\n上位程序里设置的齿轮比，只是在影响脉冲当量？\n目前伺服中参数P05-00为0，P05-02和P05-04均为1，电子齿轮比应为1。但是P05-00即为单圈脉冲数，编码器分辨率是硬件的属性值，单圈脉冲数是可以随意设置的参数值？\n#+END_NOTE"}],
       :block/content "**测试方案及结果**"}],
     :block/content "## 电子齿轮比"}
    {:block/id #uuid "66179899-1ab4-4f22-983c-9d0f2d840cb2",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "661798e0-953d-4da0-bf3f-2fa30bc0e74c",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "[EtherCAT通讯DS402协议----Controlword和Statusword-CSDN博客](https://blog.csdn.net/weixin_43956732/article/details/106597701)"}
      {:block/id #uuid "661799f5-3ae8-471a-b899-82d5d04ec71a",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "[EtherCAT协议与使用说明V1.0.pdf](file:///C:/Users/yangy/Downloads/EtherCAT%E5%8D%8F%E8%AE%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8EV1.0.pdf)"}
      {:block/id #uuid "66179f2e-5546-4be1-88c1-0e91e0225825",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "[20240313135138_18663.pdf (yankong.com)](https://www.yankong.com/Uploads/file/20240313/20240313135138_18663.pdf)"}
      {:block/id #uuid "66179f6c-01d1-452a-b546-aed2aac07879",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "6617a9c2-0e14-4646-99a5-3bbb21587b68",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "![image.png](../assets/image_1712824173890_0.png)"}
        {:block/id #uuid "6617a9c5-81d0-43fe-a975-3328388c92b4",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "状态机个状态对应说明\n|状态名|说明|\n|Not Ready to Switch on|设备电源已接通，驱动器已经初始化，并执行内部自检，制动器也被激活。|\n|Switch on Disabled CANopen|通信已开始，可以利用 SDO 通信服务对驱动器进行 参数设置。|\n|Ready to Switch on|驱动器继续进行参数设置，电机没有被励磁。|\n|Switched on|驱动器电机准备好状态，输出级电压将在该状态中最后接通， 但不能执行驱动功能。|\n|Operation Enable|驱动器电机使能，驱动器正常运行状态，按照控制模式控制电机。|\n|Quick Stop Active|快速停止功能被激活，驱动功能已启动，同时启动了电机。|\n|Fault Reaction Active|驱动器检测到报警发生，按照设定方式停机，电机仍使能。|\n|Fault|Fault 错误出现，允许更改驱动器参数。|"}],
       :block/content "CiA402状态机"}
      {:block/id #uuid "66179c73-67be-4f11-9aec-89b4c9775238",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "6617abc7-4edc-4f53-b9f1-507d6ea2c9f7",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "其中Bit 0~3和Bit 7 用于控制驱动器状态机切换\n|命令|Bit 7|Bit 3|Bit 2|Bit 1|Bit 0|状态切换|\n|Shutdown|0|X|1|1|0|2，6，8|\n|Switchon|0|0|1|1|1|3|\n|Switch on + Enable Operation|0|1|1|1|1|3 + 4|\n|Disable Voltage|0|X|X|0|X|7，9，10，12|\n|Quick Stop|0|X|0|1|X|7，10，11|\n|Disable Operation|0|0|1|1|1|5|\n|Enable Operation|0|1|1|1|1|4，16|\n|Fault Reset|0 $\\rightarrow$ 1|X|X|X|X|15|"}],
       :block/content
       "控制字6040H可以控制驱动器的状态切换，运行模式切换，每个Bit的功能具体如下\n||||||\n|Bit 6~4|Bit 3|Bit 2|Bit 1|Bit 0|\n|Operation Mode Specific|Enable  Operation|Quick Stop|Enable Voltage|Switch On|\n|Bit 15|Bit 11~14|Bit 9~10|Bit 8|Bit 7|\n| ~~Reset Home~~ |Manufacturer Specific|Reserved|Halt|Fault Reset|"}
      {:block/id #uuid "6617ad4b-d2b4-4a75-97f8-ff1d016debe1",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "状态字6041H可以只是驱动器的当前状态，其Bit定义如下\n|Bit 6|Bit 5|Bit 4|Bit 3|Bit 2|Bit 1|Bit 0|\n|Swtich On Disabled|Quick Stop|Voltage Enabled|Fault|Operation Enabled|Switched             On|Ready To Switch On|\n|Bit 14~15|Bit 12~13|Bit 11|Bit 10|Bit 9|Bit 8|Bit 7|\n|Manufacturer Specific|Operation Mode Specific|Internal Limit Active|Target Reached|Remote |Manufacturer Specific|Warning|"}
      {:block/id #uuid "6617b262-2920-46d9-9d5c-b60077859828",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "不同厂家的伺服控制字和状态字的位定义是否会不同 #？"}],
     :block/content "## EtherCAT 控制字（Controlword）和状态字（Statusword）"}
    {:block/id #uuid "66397db9-71fa-4bf5-bfa2-00b7fcd87b11",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66397dcc-b4e6-40c6-b64f-2d60c3d8f0ef",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66397e15-a2d9-40fe-a406-5b53aec60f7d",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content "索引为0x(2000 + XY)"}
        {:block/id #uuid "66397e59-3ffa-465a-8f10-cfba4f2c5359",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content "子索引为AB+1"}],
       :block/content "Samkoon R8 伺服驱动器访问用户参数需要两个索引，如果要访问PXY-AB参数，则"}
      {:block/id #uuid "66397e6d-8a5d-4566-a408-c7f3e28197e0",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "使用$\\mathsf{ECAT\\_SDO\\_READ}$和$\\mathsf{ECAT\\_SDO\\_WRITE}$对关键字进行读写"}],
     :block/content "## 参数读写"}
    {:block/id #uuid "65f40e79-5dd4-493b-8a22-8261a4164904",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f80443-200c-4718-914e-e606e94f4697",
       :block/properties {},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f8072a-d143-439f-9fde-0e06c83cfa4e",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "~~速度模式后，电子凸轮输出。~~ 速度模式使能后，电机就会转动，与电子凸轮无关；"}
        {:block/id #uuid "65f8071e-65aa-443f-ac8c-77781646bfed",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "~~速度模式，电子凸轮选择追剪，应能观察到电机反转。但实际电机无反转甚至转速无变化；~~"}
        {:block/id #uuid "65f80722-9625-462b-85ed-007ceb87ba1f",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "~~参数P0515为0或1未观察到明显差别。~~ 速度模式分为内部速度模式和模拟量输入模式，没有模拟量输入，使用了内部速度模式，通过更改速度参数P0603，可以调节转速。手册中“确认运行模式”有误，应为“C00-00”而非“P00-00”。"}],
       :block/content
       "~~为什么电子凸轮（ECAM）不输出？~~ ~~为什么位置模式电子凸轮不输出？~~为什么电子凸轮（ECAM）不输出？#电子凸轮"}
      {:block/id #uuid "65f80a09-9cd5-4263-966e-31ddcb7a14a3",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f909da-f65b-4531-bf27-6a58faf15d89",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "65f909e5-54f6-402d-bdcd-e13394c0f3de",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "65fa84f4-1a87-4dba-a1f4-5e27fe6ce441",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "P05-00单圈脉冲数为轴转一圈输出的脉冲数，和电机转速无关。"}],
           :block/content
           "~~原因在于**P05-00单圈脉冲数**为10000，即10000个脉冲转一圈。~~ 纯纯搞错了"}
          {:block/id #uuid "65f90ae2-ee78-4f69-a384-be053479f6d5",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "**使用JOG指令，脉冲频率设定为1Hz，P05-00设定为100，电机成功转动。**"}],
         :block/content "将脉冲频率设定为1Hz后，能够看到伺服驱动器接收脉冲。但电机不转。"}
        {:block/id #uuid "65f909de-1e94-41b2-8090-58ced97ae1a9",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "65f90a0e-2c6c-4e91-81dc-244aa4aa81e5",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "原因在于脉冲使用的为**DEVA双字绝对位置单段脉冲输出**？"}],
         :block/content "给脉冲后，监控P13-36可以看到当前电机位置变化，但电机不转"}],
       :block/content "**监控O-012接受脉冲应该产生什么变化？**"}
      {:block/id #uuid "6603ddf9-3c72-4d7c-b855-4725922203f6",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "6603de14-f1f1-4ee5-bcd0-48e17e179e45",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "((66037999-86cc-4e7e-af9a-85b335b5481f))"}],
       :block/content "脉冲型伺服也可以使用MC指令"}],
     :block/content "## 问题记录"})}
  {:block/id #uuid "65f14811-5358-4b84-8c43-a07b5f544a99",
   :block/page-name "电机控制",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f40e3c-d593-4810-8903-605fd7c2463c",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[伺服驱动器]]"}
    {:block/id #uuid "65fd1edd-de11-404b-bdb2-97a301dc9dda",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65fd1f11-2d3b-4604-adee-7c87d854c05f",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "编码器是一种用来测量机械旋转或位移的传感器。它能够测量机械部件在旋转或直线运动时的位移位置或速度等信息，并将其转换成一系列电信号。按照输出信号分类可分为**增量式编码器**和**绝对式编码器**。"}
      {:block/id #uuid "65fd1f6b-fe8b-42e7-9a50-09f4f8949f8f",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65fd1f89-ce21-4853-a161-4be1458a040d",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "将设备运动时的位移信息变成连续的脉冲信号，通过脉冲个数表示位移量大小。"}
        {:block/id #uuid "65fd22dc-d81d-4b47-9498-8153363ddae3",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "#+BEGIN_NOTE\n增量式编码器的工作原理：通过Index找到零位，通过脉冲数目计算旋转角度，通过AB通道的相对滞后性判断旋转方向，通过波形所占据的时间，或者波的脉冲频率来判断速度。\n#+END_NOTE"}
        {:block/id #uuid "65fd2029-5075-46a8-b230-80a53527bcd6",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "通常输出通道A和B两组信号，两组信号有90°（1/4周期）的相位差。\n光透过码盘上的透明窗口形成高电平，被黑色标线挡住形成低电平。\n通常增量式编码器还会设置一个通道Z，每圈输出一次，作为特定的参考位置。"}
        {:block/id #uuid "65fd214d-2355-4b99-8f0c-9d140890bae6",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "如下图，通道A和通道B的信号的周期相同，且相位相差1/4个周期，结合两相的信号值\n当B相和A相先是都读到高电平（1 1），再B读到高电平，A读到低电平（1 0），则为**顺时针**转\n当B相和A相先是都读到低电平（0 0），再B读到高电平，A读到低电平（1 0），则为**逆时针**转\n![image.png](../assets/image_1711087652447_0.png)"}
        {:block/id #uuid "65fd2025-5733-4101-a445-40968ce7c314",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "65fd2212-31d9-41f5-877b-0a8df81ddd14",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "只计算通道A上升沿，1倍频；"}
          {:block/id #uuid "65fd2229-88a1-4f98-b66a-7f3e3b259f08",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "计算通道A的上升沿和下降沿，2倍频；"}
          {:block/id #uuid "65fd2236-7dc0-47df-8b6a-e4fa3cd7db00",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "计算通道A和通道B的上升沿和下降沿，4倍频；"}
          {:block/id #uuid "65fd2283-2429-4a4b-b849-d4b7015d71f0",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "另外，可以通过插值得到更高的倍频，但存在一定限制。"}],
         :block/content "另外，增量式编码器可以实现4倍频"}],
       :block/content "### 增量式编码器"}
      {:block/id #uuid "65fd22f3-eac6-47f6-a1b5-529e5e93951c",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65fd22fa-7206-41e1-a3a7-3cb612cb8a51",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "将设备运动时的位移信息通过二进制编码的方式（特殊的码盘）变成数字量直接输出。"}
        {:block/id #uuid "65fd2316-89f5-48b9-818a-62487c66a8bc",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "#+BEGIN_NOTE\n绝对式编码器的原理：对每一个位置，给定一个唯一的编码，再用传感器去识别每个位置的编码，输出与之相对应的唯一信号，用来表示特定的位置。\n#+END_NOTE"}
        {:block/id #uuid "65fd2335-45a5-46b6-8851-43d6d494a6b8",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "绝对式编码器的码盘上有很多圈线槽，被称为码道，每一条（圈）码道内部线槽数量和长度都不同。它们共同组成一套二进制编码，一条（圈）码道对应二进制数的其中一个位（通常是码盘最外侧的码道表示最低位，最内侧的码道表示最高位）。\n![image.png](../assets/image_1711088747532_0.png)"}],
       :block/content "### 绝对式编码器"}
      {:block/id #uuid "65fd2523-1bd2-41e1-9bd5-9737311f1b5e",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65fd2529-4ee7-4e02-b8c4-85a45603e5d6",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "65fd2543-7148-45a9-91eb-4e3778ecc316",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "对于增量式编码器，其分辨率表示为编码器转轴旋转一圈所产生的脉冲数，即**脉冲数/转(Pulse Per Revolution 或PPR)**。码盘上透光线槽的数目其实就等于分辨率，也叫多少线，较为常见的有5-6000 线；"}
          {:block/id #uuid "65fd2561-9bd1-4113-a400-e2aa4e0cb7a3",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "对于绝对式编码器，内部码盘所用的位数就是它的分辨率，单位是**位(bit)**，具体还分单圈分辨率和多圈分辨率。"}],
         :block/content "分辨率\n指编码器能够分辨的最小单位。"}
        {:block/id #uuid "65fd256f-26b0-47a2-a28f-948838fa39bd",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "精度\n指编码器每个读数与转轴实际位置间的最大误差，通常用角度、角分或角秒来表示，由码盘刻**线加工精度、转轴同心度、材料的温度特性、电路的响应时间**等各方面因素共同决定。"}
        {:block/id #uuid "65fd257b-41d6-4019-ae8e-9a897e8db510",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "最大响应频率\n编码器**每秒输出的脉冲数**，单位是Hz。"}],
       :block/content "### 编码器参数"}
      {:block/id #uuid "65fd258d-06bb-4696-aafc-9f11677d95ba",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65fd2aaa-fadf-48ac-8f05-be6215c7f031",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "M法测速：在固定时间内统计输出的脉冲个数来计算转速，适用于高速测速；\n$$n = \\frac{M_0}{CT_0}$$\n其中，$n$为转速，$T_0$为统计时间（固定值），$M_0$为统计时间$T_0$内统计到的编码器脉冲数（测量值），$C$为编码器单圈脉冲数（常数）。"}
        {:block/id #uuid "65fd2add-461b-4204-83a8-c1ca45435a15",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "T法测速：通过输出的两个脉冲间的高频时钟脉冲个数来计算转速，适用于低速测速；\n$$n = \\frac{1}{T_EC}=\\frac{F_0}{M_1C}$$\n其中，$T_E$为两个编码器脉冲之间的时间，其间的计数值为$M_1$（测量值，$F_0$为高频脉冲的频率（固定值）。"}
        {:block/id #uuid "65fd2b14-10fd-4df0-9d09-077aaf630aca",
         :block/properties {},
         :block/format :markdown,
         :block/children [],
         :block/content
         "M//T测速：既测量一定时间内的编码器脉冲数又测量两个编码器脉冲之间的高频脉冲数。\n$$n=\\frac{M_0F_0}{M_1C}$$\n高速时，$M_0$增大，$M_1$减小，相当于M法；\n低速时，$M_1$增大，$M_0$减小，相当于T法。"}],
       :block/content "### 码盘测速"}],
     :block/content "## 编码器"}
    {:block/id #uuid "66061278-9765-4c78-a8ce-805154bfe550",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[电子凸轮]]"}
    {:block/id #uuid "65f14810-15c3-47bd-9180-9ae2d413bab2",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14810-b33a-4edc-9a71-a0f8c4f19af4",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "((65ee5ea3-f508-4485-816c-e5b49b724ca3))"}],
     :block/content "## *References*"})}
  {:block/id #uuid "660a4f29-7f6a-4f47-8371-1831a754f245",
   :block/page-name "Mar 20th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "65fa3b6f-050f-4b2a-8862-8213b5ebe2ef",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "完成了电子凸轮的测试，阅读文档不够细致，没有深入细节，搞懂每一个参数的具体含义，一知半解就开始尝试。"}
    {:block/id #uuid "65fab548-bf4f-430c-b962-681610ea4751",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "尝试的方案也未做好记录，导致很多重复劳动。"})}
  {:block/id #uuid "65fb852b-2223-4237-8e11-f143d2aa9b64",
   :block/page-name "Mar 21st, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "65fb852b-8c07-4967-bc8d-cb58e546b183",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "完成了汇川Easy521总线型PLC与R8伺服驱动器之间的连接。"}
    {:block/id #uuid "65fce15d-8c11-42bc-96e4-0daaff9ec199",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "回零指令的速度采用了默认设置，导致电机转速极快，有一定风险。"}
    {:block/id #uuid "65fce18b-e89b-4df1-b9d4-741e7ba493f4",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "6620702e-bf70-4953-8095-f8ce50ee25c9",
   :block/page-name "Apr 18th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "6620702f-d4b7-4113-8914-b9aa91cceb02",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "上班路上的车祸是最划算的，可以带很多人一起赔钱 #balderdash"})}
  {:block/id #uuid "6621befd-e391-47f0-b39e-26b8461875bf",
   :block/page-name "Apr 19th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "6621befe-9225-4abd-8186-387b419a0600",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "88.6 kg #Weight"}
    {:block/id #uuid "6621c116-c806-43a6-9825-46e7f21e0b76",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "接手别人的旧电脑就像租到了没打扫的房间一样恶心！ #balderdash"})}
  {:block/id #uuid "6616bdc3-d1b1-4d79-89de-587fd578eefa",
   :block/page-name "Apr 11th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "6616bdc4-de46-4b2a-8232-0d9c9cf47bf6",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "真诚建议吃屎时别嚼 #balderdash"}
    {:block/id #uuid "66173635-6668-4bc3-99cb-4ed8c18c9e81",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "87.7 kg #Weight"})}
  {:block/id #uuid "6625fcd2-ea4a-4917-968c-f7889f12779f",
   :block/page-name "☣️Warning",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66026663-c161-45f8-92c7-83483c509be7",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "安！全！生！产！"}
    {:block/id #uuid "660b5ed9-7ef2-448b-b92e-54e52f90992b",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "#+BEGIN_CAUTION\n必须相信自己最坏的判断\n负数存于单字寄存器中会变为一个巨大的正值（第一位的负号会被识别为1）\n测试时记得限制轴的最大转速\n#+END_CAUTION"}
    {:block/id #uuid "660b5f0d-c9c7-4d63-86b2-1dac0e3869a3",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "#+BEGIN_CAUTION\n长时间离开PLC和伺服驱动器要记得断电\n#+END_CAUTION"}
    {:block/id #uuid "660b5f0f-01b9-4458-9be6-5a679bbc8496",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "#+BEGIN_CAUTION\n 轴使能前务必确认转速\n所有测试应尽量以低转速进行\n提高转速应逐步提升，确保安全\n#+END_CAUTION"}
    {:block/id #uuid "660b5f2c-cbbe-462c-a10b-50fc9449b652",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "#+BEGIN_CAUTION\n接线要注意安全\n上电前应反复确认接线正确\n所有接线应在断电状态下进行\n#+END_CAUTION"})}
  {:block/id #uuid "6626236c-6771-496f-bc13-f44114daf519",
   :block/page-name "多任务编程",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "662623c7-3f86-428d-b23c-bfaf37682a52",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "662792b6-54ad-4a75-93c8-c11aea228402",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 进程概念和基础"}
      {:block/id #uuid "662792c7-b0dd-4984-9253-12184062719e",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 进程控制"}
      {:block/id #uuid "662792ca-39b4-49bf-9db3-91da8e267350",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 守护进程"}
      {:block/id #uuid "662792ce-9769-4a25-ab90-7468753370ec",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### ((66279524-e9ed-4918-9114-48a55216f181))"}],
     :block/content "## 进程"}
    {:block/id #uuid "662792d3-e9d6-4a0e-ac99-c72d477bbe3b",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "662792d7-f233-4823-9e2a-ca8fa67b87d6",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 线程的概念和基础"}
      {:block/id #uuid "662792e4-00bd-4fa1-a328-7d3d93744422",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "662792ef-a8aa-4e7b-aa7b-cf7f370599e3",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "属性"}
        {:block/id #uuid "662792f1-5ad3-46ab-8bcc-1a4fa9f48745",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "创建"}
        {:block/id #uuid "662792f2-d469-4f4e-8684-68a1805113d7",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "等待"}
        {:block/id #uuid "662792f4-5d33-4155-bc24-7e7112340d03",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "退出"}
        {:block/id #uuid "662792f7-7cc8-4485-8d07-9adad7fa67f9",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "清除"}
        {:block/id #uuid "662792f8-12de-4707-9898-dff6950ed953",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "同步"}
        {:block/id #uuid "662792fa-d24f-41c4-81fd-442eceba5346",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "优先级"}],
       :block/content "### 线程控制和编程"}],
     :block/content "## 线程"})}
  {:block/id #uuid "66262544-bb3d-42e3-9f4d-39feeca1908d",
   :block/page-name "Linux 驱动开发",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66279868-4f77-4165-9bb2-12dd34ec7d7c",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66279870-0f9d-4621-a307-1e11bb5c2b35",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 字符设备驱动结构和框架"}
      {:block/id #uuid "66279878-0bfa-4c8a-b698-ab0077b704ed",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 关键数据结构"}
      {:block/id #uuid "6627987d-cdd2-4168-8eda-c607425a3d12",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 相关调用流程"}
      {:block/id #uuid "66279882-1399-4c3f-a454-8ee851192065",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 扩展操作"}],
     :block/content "## 字符设备驱动"}
    {:block/id #uuid "66279885-4261-41a0-bdc0-233a0beaf126",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "6627988a-e8c0-46fe-b65b-985139b88118",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 块设备驱动基本框架"}
      {:block/id #uuid "66279891-b0be-4ca3-a998-a4f75ffa4358",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 主要数据结构"}
      {:block/id #uuid "66279895-9432-44ca-a34b-9fe13de80690",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 块设备的处理和操作"}
      {:block/id #uuid "6627989d-c7ae-42cc-8683-b25a2de64092",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 通用块层"}
      {:block/id #uuid "662798a6-6621-45d2-a00b-4c6280befe00",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### I/O调度程序"}],
     :block/content "## 块设备驱动"}
    {:block/id #uuid "662798ac-fb7e-440a-abb8-e3d50c47af9f",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "662798b2-d075-4b28-9130-849c745b0b42",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 网络设备工作原理"}
      {:block/id #uuid "662798b7-b44f-4bbe-bb10-bedc16dfaea3",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 网络设备驱动框架"}
      {:block/id #uuid "662798bb-b620-4ec4-b0f5-fe3169dbd198",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 核心数据结构和函数"}
      {:block/id #uuid "662798c0-73cd-463a-9e78-91a15e338cf1",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 收/发/处理数据"}
      {:block/id #uuid "662798c9-4f22-4cc7-9bec-b113646d1d3a",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 中断处理"}],
     :block/content "## 网络设备驱动"}
    {:block/id #uuid "662798cd-ecc8-4efc-9859-558c9db4d40b",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "662798d3-b3f5-4d3c-8b25-b5a66e5c9b63",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### 串口设备"}
      {:block/id #uuid "662798ee-783b-4ce5-9666-86ded0b16ad7",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### ((662791a2-9223-4ef6-84ed-764f733b2dee))"}
      {:block/id #uuid "662798fd-9eb5-48cc-8972-e97e11ad3fb0",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### ((662791a7-fa46-4ab1-99e5-b8d2f314fe83))"}
      {:block/id #uuid "6627991b-f584-4f6d-a1fe-cc7c288728ce",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### ((662791aa-4bca-4243-a183-c1b33b9bb308))"}
      {:block/id #uuid "6627992c-f65a-4109-8ce3-c73c0042f887",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### PCI"}
      {:block/id #uuid "66279939-bb89-4d67-976a-90eed0546163",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### ((662791ac-b37e-4f89-8352-8ac10e9d8559))"}],
     :block/content "## 总线设备驱动"})}
  {:block/id #uuid "661c7ba4-a4a1-404d-9ab1-2ac409c1ddd9",
   :block/page-name "Apr 15th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "661c7ba5-744a-4649-9f3b-82c8ef488393",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "89.0 kg #Weight"}
    {:block/id #uuid "661c7bc8-e239-40e9-acac-496048a714b9",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "荣耀版又不是战神版，肯定有性能阉割啦！能通过NNGAP(National New Gandam Assessment Program)就不要苛求更多了！ #balderdash"})}
  {:block/id #uuid "662afca3-6b98-40fe-b303-0f22073e982a",
   :block/page-name "Apr 26th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "662afcac-1fe2-4f1a-b08d-de77bac87fdd",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "原来保时捷也漏雨啊！ #balderdash"}
    {:block/id #uuid "662afceb-e5fd-4ff5-b670-71986dc7c37f",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "疯狂星期四过后，不谈体重的事情。 #Weight"})}
  {:block/id #uuid "66261c04-e4d6-4f23-922c-a6ff025e2d15",
   :block/page-name "嵌入式编程基础",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66261c12-f3eb-4fe6-bf92-5844795d4301",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[C++程序设计]]"}
    {:block/id #uuid "66261c22-2627-42e0-8886-79a8493eded6",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[C语言]]"}
    {:block/id #uuid "66261c2a-f511-446d-8cb8-32d36854b481",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[数据结构与算法]]"}
    {:block/id #uuid "66261ca0-dfa4-41a8-bdb4-ece10c6e2fb9",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[操作系统原理]]"}
    {:block/id #uuid "66261cef-73fb-448d-b9eb-09d26fd92494",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[计算机网络原理]]"}
    {:block/id #uuid "66261d4a-8f1c-45f7-b53d-5bbaf6c67b36",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[单片机原理/微机原理/计组原理]]"}
    {:block/id #uuid "66261d72-f4fe-4846-9f43-be5a93c2cebf",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[Linux 操作系统]]"})}
  {:block/id #uuid "661a2a83-d8ba-405c-9d29-8e77f40472e2",
   :block/page-name "Apr 13th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "661a2a84-b39f-4579-b59f-6f9efc8a2d81",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "住口！气味攻击也是黑暗决斗的重要手段！ #balderdash #quote"})}
  {:block/id #uuid "66285740-efdc-4dd2-89da-2f59a95db54c",
   :block/page-name "Apr 24th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66285742-159c-4b80-8424-da1dbafaed00",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "88.6 kg #Weight"}
    {:block/id #uuid "6628574f-8d88-4841-8f71-1095cd0fcb13",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "没用的东西，准备战斗！ #balderdash"})}
  {:block/id #uuid "662da175-a81e-4c6e-a84e-8f6272e4b2b9",
   :block/page-name "Apr 28th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "662da177-44ff-49a4-8685-896d30d5931f",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "don't care until May #Weight"}
    {:block/id #uuid "662da58a-67d4-44a1-87f5-3146486e39a7",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "只为了我，心情愉悦。 #balderdash"})}
  {:block/id #uuid "66262060-1999-4481-891a-bd6bc7612904",
   :block/page-name "嵌入式应用层开发",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "662623ce-b226-4500-a2fd-a3fe012359d9",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[系统控制]]"}
    {:block/id #uuid "662623d6-f15f-4be7-8a60-0f4ae9f1ceda",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[内存使用和管理]]"}
    {:block/id #uuid "66262343-4de3-46ff-951f-72cb59763b2b",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[多任务编程]]"}
    {:block/id #uuid "6626236c-8372-4603-9141-5451c38b1e3e",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[文件I/O 编程]]"}
    {:block/id #uuid "66262379-4d2c-4618-a170-cbd57543b1c5",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[网络编程]]"}
    {:block/id #uuid "6626238e-252b-4182-bb0f-5c10036cc1d9",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[图形化界面编程]]"})}
  {:block/id #uuid "65f14810-14ae-40e5-a978-2a6622e73ad2",
   :block/page-name "Mar 8th, 2024",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14810-446f-40fb-ac4b-b5d33f966c2d",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "DONE 整理参考书目 [[Mar 8th, 2024]]\n:LOGBOOK:\nCLOCK: [2024-03-08 Fri 10:43:41]\nCLOCK: [2024-03-08 Fri 10:43:45]--[2024-03-08 Fri 10:48:22] =>  00:04:37\n:END:"}
    {:block/id #uuid "65f14810-2712-45db-bd96-57432a66b736",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "DONE 整理控制系统笔记 [[控制理论]] #📓Note [[Mar 8th, 2024]]\n:LOGBOOK:\nCLOCK: [2024-03-08 Fri 11:20:58]\nCLOCK: [2024-03-08 Fri 11:21:04]--[2024-03-08 Fri 16:01:09] =>  04:40:05\n:END:"}
    {:block/id #uuid "65f14810-b6e3-4e1f-abae-d5c84fd3076d",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "LATER [[控制理论]]学习 #📓Note\nDEADLINE: <2024-04-30 Tue 18:00>\n:LOGBOOK:\nCLOCK: [2024-03-08 Fri 10:44:06]\nCLOCK: [2024-03-08 Fri 10:44:18]--[2024-03-11 Mon 17:12:24] =>  78:28:06\n* State \"DONE\" from \"NOW\" [2024-03-11 Mon 17:12]\nCLOCK: [2024-03-12 Tue 08:55:43]--[2024-03-12 Tue 17:51:15] =>  08:55:32\n* State \"DONE\" from \"NOW\" [2024-03-12 Tue 17:51]\nCLOCK: [2024-03-13 Wed 09:39:33]--[2024-03-13 Wed 09:41:29] =>  00:01:56\nCLOCK: [2024-03-14 Thu 11:49:46]--[2024-03-14 Thu 13:54:28] =>  02:04:42\n* State \"DONE\" from \"LATER\" [2024-03-27 Wed 17:58]\nCLOCK: [2024-04-23 Tue 09:19:46]--[2024-04-23 Tue 09:19:48] =>  00:00:02\n:END:"}
    {:block/id #uuid "65f14810-fad6-4136-a2ca-5d07be6c9727",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "DONE 伺服电机参考资料及书目筛选 [[Mar 11th, 2024]]\n:LOGBOOK:\nCLOCK: [2024-03-11 Mon 09:19:40]--[2024-03-11 Mon 09:49:28] =>  00:29:48\n:END:"}
    {:block/id #uuid "65f14810-2930-4736-a69d-7c8113b27ee3",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "LATER [[电机控制]]学习 #📓Note [[Mar 18th, 2024]]\n:LOGBOOK:\nCLOCK: [2024-03-13 Wed 15:26:34]--[2024-03-13 Wed 15:44:18] =>  00:17:44\nCLOCK: [2024-03-18 Mon 13:15:09]--[2024-03-18 Mon 13:15:32] =>  00:00:23\nCLOCK: [2024-03-22 Fri 14:34:40]--[2024-03-22 Fri 17:23:17] =>  02:48:37\n:END:"})}
  {:block/id #uuid "65f14810-54f4-4136-bdff-ce69bea465fd",
   :block/page-name "Mar 11th, 2024",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14810-abae-44fd-99eb-0f7369bb0594",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "What a boring day！\n:LOGBOOK:\nCLOCK: [2024-03-11 Mon 09:13:53]\nCLOCK: [2024-03-11 Mon 09:13:58]\n:END:"})}
  {:block/id #uuid "661f1e75-ffce-47d4-a23e-2a744e7e522e",
   :block/page-name "Apr 17th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "661f1e76-8bd9-4465-a850-ad028b88050d",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "该不会有机会全修了吧 #balderdash"})}
  {:block/id #uuid "66262398-c726-4efa-a599-f6653c6f6d29",
   :block/page-name "图形化界面编程",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "6627937b-a6d9-4b6a-8931-f399fe221a6d",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## QT开发基础"}
    {:block/id #uuid "66279388-1c79-4353-b663-b18c908add44",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 对话框/窗口"}
    {:block/id #uuid "6627938c-c38f-4b4e-9de3-e5006641e8d7",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 信号与槽"}
    {:block/id #uuid "66279390-43ec-4115-bb59-be2b3a6a2cd0",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 组件/控件/布局/事件"}
    {:block/id #uuid "66279397-d36e-4a4c-856a-e484e52c24c6",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 绘图"}
    {:block/id #uuid "66279399-b871-4fbd-9c2e-e3e9e6922473",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 文件操作"}
    {:block/id #uuid "6627939c-c2b7-4f1c-81f7-03bde293f3aa",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 定时器"}
    {:block/id #uuid "6627939f-e4a6-4148-a620-c11f4ed10594",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 多线程"}
    {:block/id #uuid "662793a1-4f2e-4dbc-aa5d-c7cd9f0b8085",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## 网络通信"})}
  {:block/id #uuid "65f14811-d922-404f-aa53-64d60bbcea6c",
   :block/page-name "控制理论",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14810-9548-489c-9900-a9451f2a80f6",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14810-b2c6-4357-b851-cd62ee261c44",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f14810-e210-48ce-b084-5e2a7561d960",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "状态随时间变化的系统，即状态变量是时间的函数。"}
        {:block/id #uuid "65f14810-6c01-4f35-8fd8-10241408a369",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "65f14810-839f-4a50-aa70-1e228a46b511",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "**线性** 指系统的输入与输出是线性映射的，符合叠加原理（Superposition Principle）。\n一个系统的—个变量最初的变化所造成的此变量或其它变量的相应变化是成比例的。 \n#+BEGIN_NOTE\n*即输入产生一定的变化，则输出产生的变化是确定的？*\n#+END_NOTE"}
          {:block/id #uuid "65f14810-7e66-4889-8eaa-9cfcd41d8e33",
           :block/properties {:query-table false},
           :block/format :markdown,
           :block/children [],
           :block/content
           "**时不变性** 指如果系统的输入信号延迟了时间T，那么系统的输出也会延迟时间T。 \n#+BEGIN_NOTE\n*即系统本身不随时间而改变，比如一个弹簧系统，不考虑弹簧老化导致的弹性模量变化。*\n*能否将随时间变化的参数当作输入，从而将单输入的时变系统当作多输入的时不变系统处理？*\n#+END_NOTE"}],
         :block/content "**线性时不变系统（Linear Time Invariant System）**"}],
       :block/content "### 动态系统"}],
     :block/content "## 绪论"}
    {:block/id #uuid "65f14810-2f8d-4dd3-b613-65b5030c1113",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14810-61c8-49a7-99b1-b54134b6e8ff",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f14810-1419-49a5-a9e4-144cf4c59251",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "对于线性时不变系统而言，其输入与输出之间是卷积（Convolution）关系，即系统的输入会对未来一段时间之内的系统输出产生影响。\n*即输出并不是瞬间反应输入的，而是以一段时间的变化来反映输入。以符合虎克定律的弹簧为例，当以对弹簧施加的外力为输入时，弹簧产生的最大伸长量为*$x_{max} = \\frac{F}{k}$，但是其伸长量并非是瞬间阶跃至最大的，也并非是瞬间降至0的。而是如下图曲线变化。*\n![image.png](../assets/image_1709877475939_0.png)\n*以最大伸长量作为输出的话，其与输入是线性关系；而以伸长量作为输出的话，其与输入则为卷积关系？*"}
        {:block/id #uuid "65f14810-5275-4184-958c-3f7364da6170",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "#+BEGIN_NOTE\n当其输入并非一个瞬时的冲激量，而是一条随时间变化的曲线的话，每个时刻均可视为一个瞬时的冲激输入，产生一个输出（在一段时间内变化的曲线）。将所有时刻的输入产生的输出累加起来，得到总的输出变化，即为卷积的过程。\n#+END_NOTE"}
        {:block/id #uuid "65f14810-242a-4e12-8f36-60475b82ba06",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "引入单位冲激函数（Unit Impulse）$\\delta(t)$，又称狄拉克函数（Dirac Delta），其定义为\n$$ \\begin{cases}\\delta(t)=0, t \\neq 0 \\\\ \\int^{\\infty}_{-\\infty}\\delta(t) \\mathrm{d}t =1\\end{cases} $$\n*可以理解为宽度为0，高度为*$\\infty$*的方块函数。*"}
        {:block/id #uuid "65f14810-9b41-4bc6-a2f4-ce1c570d6446",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "令$h(t)$为系统对单位冲激函数$\\delta(t)$的冲激响应（Impulse Response）。"}
        {:block/id #uuid "65f14810-8303-4632-9934-b93b59192eeb",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "对系统输入$u(t)$进行微分，可以得到某一时刻的响应$x_n(t) = u(i\\mathrm{d}t)\\mathrm{d}t\\cdot h(t-i\\mathrm{d}t)$"}
        {:block/id #uuid "65f14810-d82a-483b-86ea-c65088d62162",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "将上式对时间积分可得"}
        {:block/id #uuid "65f14810-6025-4953-bafd-655c1ffd7294",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "$$\\begin{align} x(t) &= \\lim_{\\mathrm{d}t\\rightarrow 0}\\sum_{i=0}^n u(i\\mathrm{d}t)\\mathrm{d}t\\cdot h(t-i\\mathrm{d}t)\\\\ &=\\int_0^tu(\\tau)h(t-\\tau)\\mathrm{d}\\tau = u(t)*h(t) \\end{align}$$"}
        {:block/id #uuid "65f14810-0015-4743-b2f8-167dd5d3b44b",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "上式即为卷积的连续表达形式。可用框图表示如下：\n![image.png](../assets/image_1709880812777_0.png)"}
        {:block/id #uuid "65f14810-10ba-4b5b-a47d-9365364f3824",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "冲激响应$h(t)$包含了线性时不变系统的全部特性。"}],
       :block/content "### 卷积"}
      {:block/id #uuid "65f14810-42f9-4c95-b2ed-71ffdf6909aa",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f14810-6884-4764-81d9-be656bec12bb",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "对一个函数$f(t)$做拉普拉斯变换，可以将其从时域$(t)$转换到复数域$(s)$，通过拉普拉斯变换，系统的微分方程将转化为代数方程，卷积运算则会变为乘法运算。\n$$\\mathcal{L}[f(t)]=F(s)=\\int_0^\\infty f(t)e^{-st}\\mathrm{d}t$$\n其中，$s=\\sigma+j\\omega$是一个复数。"}
        {:block/id #uuid "65f14810-5f84-4f8c-bf15-d1221115fd7b",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "***待补充***"}],
       :block/content "### 拉普拉斯变换"}
      {:block/id #uuid "65f14810-fcb5-4491-8414-46905cc5f4bf",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f14810-f7cf-418e-a155-106e375b2168",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "传递函数是经典控制理论的基础，系统的传递函数$G(s)$的定义为：在**零初始条件**下，系统输出的拉普拉斯变换与系统输入的拉普拉斯变换之间的比值，即\n$$G(s) = \\frac{X(s)}{U(s)}$$"}
        {:block/id #uuid "65f14810-1915-4052-99ca-c335702ccef7",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "单位冲激函数$\\delta(t)$的拉普拉斯变换$\\mathcal{L}[\\delta(t)]=1$，系统对其响应为\n$$X(s) = \\mathcal{L}[\\delta(t)]G(s)=G(s)$$\n即当单位冲激函数作用在线性时不变系统上时，其输出（即系统的单位冲激响应）等于传递函数本身。亦即**单位冲激响应可以完全地定义线性时不变系统。**"}
        {:block/id #uuid "65f14810-e9be-4462-b707-abf698dd8991",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "开环控制系统的传递函数\n![image.png](../assets/image_1709883177528_0.png)\n$X(s) = U(s)G(s) = R(s)C(s)G(s)$"}
        {:block/id #uuid "65f14810-e15d-4cb4-b5f6-c17f9026d85f",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "闭环控制系统的传递函数\n![image.png](../assets/image_1709883249069_0.png)\n其中参考值和输出之间的差称为**误差(Error)**，$E(s)=R(s)-X(s)$。\n$$\\begin{align} X(s)&=(R(s)-X(s))C(s)G(s)\\\\\n\\Rightarrow X(s)&=\\frac{C(s)G(s)R(s)}{1+C(s)G(s)}\\end{align}$$"}
        {:block/id #uuid "65f14810-7085-49ce-995c-df8a6c59236a",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "65f14810-48d1-4484-9ec2-0a9ed4625984",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "考虑一个一阶微分方程\n$$\\frac{\\mathrm{d}x(t)}{\\mathrm{d}t}+ax(t) = u(t)$$\n对上式两边进行拉普拉斯变换\n$$\\mathcal{L}[\\frac{\\mathrm{d}x(t)}{\\mathrm{d}t}+ax(t) ]=\\mathcal{L}[u(t)]\\\\\nsX(s)-x(0)+aX(s)=U(s)$$"}
          {:block/id #uuid "65f14810-9888-422e-88e3-b4fafcd3d12a",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "在零初始条件下（$x(0)=0$），系统的传递函数为\n$$G(s) = \\frac{X(s)}{U(s)}=\\frac{1}{s+a}$$\n而当$x(0)\\neq 0$时，可写为\n$$sX(s)+aX(s)=U(s)+x(0)$$\n定义新的系统输入：$U_1(s)=U(s)+x(0)$，代入上式，得到\n$$G(s)=\\frac{X(s)}{U_1(s)}=\\frac{1}{s+a}$$\n相当于一个相同系统，非零初始条件多出一个输入，这个输入的拉普拉斯变换等于其初始条件$x(0)$。\n![image.png](../assets/image_1709884228455_0.png)"}
          {:block/id #uuid "65f14810-1494-45af-9fd4-05ec550e4f08",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "因此非零初始条件系统相当于在一瞬间对零初始条件系统施加了$x(0)$个单位的能量。因为这个能量是瞬间的，并不持续，所以它不会影响到系统的稳定性分析与特征分析。\n#+BEGIN_NOTE\n*系统的初始状态可以理解为瞬时间赋予系统的“能量”。*\n#+END_NOTE"}],
         :block/content "非零初始状态下的传递函数"}],
       :block/content "### 传递函数"}],
     :block/content "## 动态系统建模——传递函数"}
    {:block/id #uuid "65f14810-f152-4ebe-93c2-962cde6eb13c",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14810-9ec7-4cda-be8b-ed3fafa9d50a",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f14810-b39a-4fc2-8a75-e2586e96ee63",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "对于下图所示的弹簧质量阻尼系统\n![image.png](../assets/image_1710141364654_0.png)\n其动态微分方程为\n$$\\begin{equation}m\\frac{\\mathrm{d}^2x(t)}{\\mathrm{d}t^2}+b\\frac{\\mathrm{d}x(t)}{\\mathrm{d}t}+kx(t)=f(t)\\end{equation}$$\n其传递函数为\n$$\\begin{equation}G(s)=\\frac{Y(s)}{U(s)}=\\frac{1}{ms^2+bs+k}\\end{equation}$$"}
        {:block/id #uuid "65f14810-f35b-49cb-a9f2-968468244208",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "上述系统在现代控制理论中则会使用状态空间方程的表达方式。状态空间方程是一个集合，它包含了系统的输入、输出及状态变量，并把它们用一系列的一阶微分方程表达出来。"}
        {:block/id #uuid "65f14810-8361-49dd-ac14-052079ef569e",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "为了将上述系统写成状态空间方程，需要选取合适的**状态变量（State Variables）**，才能使*二阶系统转化为一阶系统*。\n选取两个状态变量$z_1(t)$和$z_2(t)$，其中\n$$\\begin{align}z_1(t) &= x(t)\\\\\nz_2(t)&=\\frac{\\mathrm{d}z_1(t)}{\\mathrm{d}t} = \\frac{\\mathrm{d}x(t)}{\\mathrm{d}t}\n\\end{align}$$\n取$z_2(t)$对时间的导数：\n$$\\begin{equation}\\begin{align*} \\frac{\\mathrm{d}z_2(t)}{\\mathrm{d}t}&=\\frac{\\mathrm{d}^2x(t)}{\\mathrm{d}t^2}=\\frac{1}{m}(f(t)-b\\frac{\\mathrm{d}x(t)}{\\mathrm{d}t}-kx(t))\\\\&=\\frac{1}{m}u(t)-\\frac{b}{m}z_2(t)-\\frac{k}{m}z_1(t)\\end{align*}\\end{equation}$$\n将上式（3）和（5）写成紧凑的矩阵表达形式：\n$$\\begin{equation}\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\begin{bmatrix}z_1(t)\\\\z_2(t)\\end{bmatrix}\n=\\begin{bmatrix}\n0 & 1\\\\\n-\\frac{k}{m} & -\\frac{b}{m}\n\\end{bmatrix}\\begin{bmatrix}z_1(t)\\\\z_2(t)\\end{bmatrix}+\n\\begin{bmatrix}0\\\\\\frac{1}{m}\\end{bmatrix}u(t)\n\\end{equation}$$\n而系统的输出$y(t)=x(t)$也可以写成矩阵形式，即\n$$\\begin{equation}y(t)=\\begin{bmatrix}1&0\\end{bmatrix}\\begin{bmatrix}z_1(t)\\\\z_2(t)\\end{bmatrix}+\\begin{bmatrix}0\\end{bmatrix}\\begin{bmatrix}u(t)\\end{bmatrix}\\end{equation}$$\n上式（6）和（7）即为弹簧质量阻尼系统的状态空间方程。"}
        {:block/id #uuid "65f14810-1ae2-401a-8160-d347dfad8e9c",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "上述形式可推广并得到状态空间方程的一般形式，即\n$$\\begin{align}\n&\\frac{\\mathrm{d}\\mathbf{z}(t)}{\\mathrm{d}t} = \\mathbf{A}\\mathbf{z}(t)+\\mathbf{B}\\mathbf{u}(t)\\\\\n&\\mathbf{y}(t)=\\mathbf{C}\\mathbf{z}(t)+\\mathbf{D}\\mathbf{u}(t)\n\\end{align}$$\n其中\n        $\\mathbf{z}(t)$是状态变量，是一个$n$维向量；\n        $\\mathbf{y}(t)$是系统输出，是一个$m$维向量；\n        $\\mathbf{u}(t)$是系统输入，是一个$p$维向量。\n这说明当使用状态空间方程来描述系统时，有$n$个状态变量、$m$个输出和$p$个输入。它可以表达多状态、多输出、多输入的系统。其中，矩阵$\\mathbf{A}$是$n\\times n$矩阵，表示系统状态变量之间的关系，称为**状态矩阵**或者系统矩阵。矩阵$\\mathbf{B}$是$n\\times p$矩阵，表示输入对状态变量的影响，称为**输入矩阵**或者控制矩阵。矩阵$\\mathbf{C}$是$m\\times n$矩阵，表示系统的输出与系统状态变量之间的关系，称为**输出矩阵**。矩阵$\\mathbf{D}$是$m\\times p$矩阵，表示系统的输入直接作用在系统输出的部分，称为**直接传递矩阵**。\n|符号|名称|维度|\n|$\\mathbf{z}(t)$|状态变量|$n\\times 1$|\n|$\\mathbf{y}(t)$|系统输出|$m\\times 1$|\n|$\\mathbf{u}(t)$|系统输入|$p\\times 1$|\n|$\\mathbf{A}$|状态矩阵|$n\\times n$|\n|$\\mathbf{B}$|输入矩阵|$n\\times p$|\n|$\\mathbf{C}$|输出矩阵|$m\\times n$|\n|$\\mathbf{D}$|直接传递矩阵|$m\\times p$|"}],
       :block/content "### 状态空间方程"}
      {:block/id #uuid "65f14810-b424-43b8-8d2e-138dba457c0a",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f14810-fffc-42e8-bc84-f4bb77bc676f",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "对上式和两边进行拉普拉斯变换，得到\n$$\\begin{align}\n&\\mathcal{L}[\\frac{\\mathrm{d}\\mathbf{z}(t)}{\\mathrm{d}t}]=\\mathcal{L}[\\mathbf{Az}(t)+\\mathbf{Bu}(t)]\\\\\n&\\mathcal{L}[\\mathbf{y}(t)]=\\mathcal{L}[\\mathbf{Cz}(t)+\\mathbf{Du}(t)]\n\\end{align}$$\n考虑到零初始状态，$z_1(0)=z_2(0)=0$，上式可整理为\n$$\\begin{align}\n&s\\mathbf{Z}(s)=\\mathbf{AZ}(s)+\\mathbf{BU}(s)\\\\\n&\\mathbf{Y}(s)=\\mathbf{CZ}(s)+\\mathbf{DU}(s)\n\\end{align}$$\n调整后可得\n$$\\begin{equation}\n\\mathbf{Z}(s)=(s\\mathbf{I}-\\mathbf{A})^{-1}\\mathbf{BU}(s)\n\\end{equation}$$\n其中，$(s\\mathbf{I}-\\mathbf{A})^{-1}$是$(s\\mathbf{I}-\\mathbf{A})$的逆矩阵；$\\mathbf{I}$是$n\\times n$单位矩阵，$\\mathbf{I}_{n\\times n}=\\begin{bmatrix}1&0&\\cdots &0\\\\0&1&\\cdots&0\\\\\\vdots&\\vdots&\\ddots&\\vdots\\\\0&0&0&1\\end{bmatrix}$\n将上式（5）代入（4）中可得\n$$\\begin{equation}\n\\mathbf{Y}(s)=(\\mathbf{C}(s\\mathbf{I}-\\mathbf{A})^{-1}\\mathbf{B}+\\mathbf{D})\\mathbf{U}(s)\n\\end{equation}$$\n因此系统的传递函数可以表达为\n$$\\begin{equation}\nG(s) = \\frac{\\mathbf{Y}(s)}{\\mathbf{U}(s)}=\\mathbf{C}(s\\mathbf{I}-\\mathbf{A})^{-1}\\mathbf{B}+\\mathbf{D}\n\\end{equation}$$\n考虑上例中弹簧质量阻尼系统，其中$\\mathbf{D}=0$，根据矩阵求逆公式$(s\\mathbf{I}-\\mathbf{A})^{-1}=\\frac{(s\\mathbf{I}-\\mathbf{A})^{*}}{|s\\mathbf{I}-\\mathbf{A}|}$，代入上式可得\n$$\\begin{equation}\nG(s)=\\frac{\\mathbf{Y}(s)}{\\mathbf{U}(s)}=\\frac{\\mathbf{C}(s\\mathbf{I}-\\mathbf{A})^*\\mathbf{B}}{|s\\mathbf{I}-\\mathbf{A}|}\n\\end{equation}$$\n其中，$(s\\mathbf{I}-\\mathbf{A})^*$是$(s\\mathbf{I}-\\mathbf{A})$的伴随矩阵，$|s\\mathbf{I}-\\mathbf{A}|$是$(s\\mathbf{I}-\\mathbf{A})$的行列式。"}],
       :block/content "### 状态空间方程与传递函数的关系"}
      {:block/id #uuid "65f266bd-fac9-43e6-adef-b7f637e51183",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f266cf-9e41-4c1c-a584-149e6bc02814",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "考虑一个包含两个状态变量的系统，其微分方程组为\n$$\\begin{cases}\\frac{\\mathrm{d}z_1(t)}{\\mathrm{d}t}=z_1(t)+z_2(t)\\\\\\frac{\\mathrm{d}z_2(t)}{\\mathrm{d}t}=4z_1(t)-2z_2(t)\\end{cases}$$\n上式说明系统状态变量$z_1(t)$的变化率$\\frac{\\mathrm{d}z_1(t)}{\\mathrm{d}t}$除了与自身相关外，还与$z_2(t)$相关。而$z_2(t)$的变化率$\\frac{\\mathrm{d}z_2(t)}{\\mathrm{d}t}$同时是$z_2(t)$和$z_1(t)$的函数，这样两个状态变量就是耦合的，分析单个状态变量的变化需要同时考虑两个变量，这是不容易做到的。"}
        {:block/id #uuid "65f268ab-302a-4013-8d7e-99241734c792",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "将上述系统写成紧凑的状态空间方程，得到\n$$\\frac{\\mathrm{d}\\mathbf{z}(t)}{\\mathrm{d}t}=\\mathbf{Az}(t)$$\n其中$\\mathbf{A}=\\begin{bmatrix}1&1\\\\4&-2\\end{bmatrix}$"}
        {:block/id #uuid "65f2694a-3e9e-46fd-b07a-057a8f807383",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "定义一个**过渡矩阵（Transition Matrix）**\n$$\\mathbf{P} = [\\mathbf{v}_1,\\mathbf{v}_2]=\\begin{bmatrix}v_{11}&v_{21}\\\\v_{12}&v_{22}\\end{bmatrix}$$\n其中$\\mathbf{v}_1$、$\\mathbf{v}_2$是矩阵$\\mathbf{A}$的两个特征向量。"}
        {:block/id #uuid "65f26a74-4c7b-442a-bf6f-402248133af5",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "用矩阵$\\mathbf{A}$左乘过渡矩阵$\\mathbf{P}$，可得\n$$\\begin{align*}\\mathbf{AP}=\\mathbf{A}\\begin{bmatrix}v_{11}&v_{21}\\\\v_{12}&v_{22}\\end{bmatrix}&=\\begin{bmatrix}\\mathbf{A}\\begin{bmatrix}v_{11}\\\\v_{12}\\end{bmatrix}&\\mathbf{A}\\begin{bmatrix}v_{21}\\\\v_{22}\\end{bmatrix}\\end{bmatrix}\\\\&=\\begin{bmatrix}\\lambda_1\\begin{bmatrix}v_{11}\\\\v_{12}\\end{bmatrix}&\\lambda_2\\begin{bmatrix}v_{21}\\\\v_{22}\\end{bmatrix}\\end{bmatrix}\\\\&=\\begin{bmatrix}v_{11}&v_{21}\\\\v_{12}&v_{22}\\end{bmatrix}\\begin{bmatrix}\\lambda_1&0\\\\0&\\lambda_2\\end{bmatrix}\\\\&=\\mathbf{PD}\\end{align*}$$\n其中，$\\mathbf{D}=\\begin{bmatrix}\\lambda_1&0\\\\0&\\lambda_2\\end{bmatrix}$是一个特征值位于对角线上的对角矩阵。"}
        {:block/id #uuid "65f270be-a756-4509-b876-377d1bfd8d29",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "同时左乘以$\\mathbf{P}^{-1}$，可得\n$$\\mathbf{P}^{-1}\\mathbf{AP}=\\mathbf{D}$$"}
        {:block/id #uuid "65f27129-772e-4a8e-aee5-57e7b8faaea9",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "定义一组新的状态变量\n$$\\mathbf{z}(t)=\\mathbf{P}\\bar{\\mathbf{z}}(t)$$\n则\n$$\\mathbf{P}\\frac{\\mathrm{d}\\bar{\\mathbf{z}}(t)}{\\mathrm{d}t}=\\mathbf{AP}\\bar{\\mathbf{z}}(t)$$"}
        {:block/id #uuid "65f273b3-1a0b-4859-8454-d604a00990d7",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "两边同时左乘$\\mathbf{P}^{-1}$，得到\n$$\\begin{align*}&\\mathbf{P}^{-1}\\mathbf{P}\\frac{\\mathrm{d}\\bar{\\mathbf{z}}(t)}{\\mathrm{d}t}=\\mathbf{P}^{-1}\\mathbf{AP}\\bar{\\mathbf{z}}(t)\\\\\\Rightarrow &\\frac{\\mathrm{d}\\bar{\\mathbf{z}}(t)}{\\mathrm{d}t}=\\mathbf{D}\\bar{\\mathbf{z}}(t)=\\begin{bmatrix}\\lambda_1&0\\\\0&\\lambda_2\\end{bmatrix}\\bar{\\mathbf{z}}(t)\\end{align*}$$\n即\n$$\\begin{cases}\n\\frac{\\mathrm{d}\\bar{z}_1(t)}{\\mathrm{d}t}=\\lambda_1\\bar{z}_1(t)\\\\\n\\frac{\\mathrm{d}\\bar{z}_2(t)}{\\mathrm{d}t}=\\lambda_1\\bar{z}_2(t)\n\\end{cases}$$"}
        {:block/id #uuid "65f272e2-e9ca-4486-a781-68e283f93d37",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "上式说明新的状态变量$\\bar{z}_1(t)$和$\\bar{z}_2(t)$的变化率只和自身相关，因此通过这样的一个变换之后，原来系统中的耦合关系就不再存在。求解上式易得\n$$\\begin{cases}\n\\bar{z}_1(t)=C_1\\mathrm{e}^{\\lambda_1t}\\\\\n\\bar{z}_2(t)=C_2\\mathrm{e}^{\\lambda_2t}\n\\end{cases}$$"}
        {:block/id #uuid "65f28ca2-5a3b-4f0e-9439-02557b4eec6e",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "由此可得系统的原状态变量$\\mathbf{z}(t)$的表达式，即\n$$\\mathbf{z}(t)=\\mathbf{P}\\bar{\\mathbf{z}}(t)=\n\\begin{bmatrix}v_{11}&v_{21}\\\\v_{12}&v_{22}\\end{bmatrix}\\begin{bmatrix}C_1\\mathrm{e}^{\\lambda_1t}\\\\C_2\\mathrm{e}^{\\lambda_2t}\\end{bmatrix}=\n\\begin{bmatrix}1&0.5\\\\1&-2\\end{bmatrix}\\begin{bmatrix}C_1\\mathrm{e}^{2}\\\\C_2\\mathrm{e}^{-3t}\\end{bmatrix}=\\begin{bmatrix}C_1\\mathrm{e}^{2t}+0.5C_2\\mathrm{e}^{-3t}\\\\C_1\\mathrm{e}^{2t}-2C_2\\mathrm{e}^{-3t}\\end{bmatrix}\n$$"}],
       :block/content "### 线性方程组解耦"}
      {:block/id #uuid "65f29063-9d94-4a54-b9ae-38c20b7c72ea",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f29070-9186-4d92-81d3-950d5d6ccbba",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content ""}],
       :block/content "### 相平面与相轨迹分析"}],
     :block/content "## 动态系统建模——状态空间方程"}
    {:block/id #uuid "65f14810-ed4c-4350-aec3-eb25fb1f3b80",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14810-0188-401d-92f7-b453f9efbea5",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "((65ea7a20-fcd1-40cf-985e-4bdd029e7761))"}
      {:block/id #uuid "65f14810-1339-49e2-bce4-1c37cb4a73a1",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "((65ea7762-d00c-4abd-b778-22e0c48456a1))"}],
     :block/content "## *References*"})}
  {:block/id #uuid "66270b0a-8f58-445b-aafe-7fa8bca6fbed",
   :block/page-name "Apr 23rd, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66270b0c-3cf9-450c-a8f4-58da14114441",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "unknown #Weight"}
    {:block/id #uuid "66270b15-be3f-4962-9c51-43f30737f72c",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "敞篷车在暴雨天尽显魅力。 #balderdash"})}
  {:block/id #uuid "66397d0c-1fb6-40a3-aa9c-5cbafe56ac33",
   :block/page-name "May 7th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66397d0d-71c2-4367-a6bd-38bca0e468a9",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "89 kg #Weight"}
    {:block/id #uuid "66397d1b-8760-41c0-a037-716a0db30945",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "我和你一起爱左蓝！ #balderdash"})}
  {:block/id #uuid "6626193b-c950-4a85-b278-a9195ba14c74",
   :block/page-name "🕹️嵌入式开发",
   :block/properties
   {:ls-type :whiteboard-page,
    :logseq.tldraw.page
    {:id "6626193b-c950-4a85-b278-a9195ba14c74",
     :name "🕹️嵌入式开发",
     :bindings {},
     :nonce 1,
     :assets [],
     :shapes-index
     ("2db7c9f0-0083-11ef-9af4-c36a7160c1c7"
      "365d3a90-0083-11ef-9af4-c36a7160c1c7"
      "3d683510-0083-11ef-9af4-c36a7160c1c7"
      "50537fe0-0083-11ef-9af4-c36a7160c1c7"
      "72efd210-0083-11ef-9af4-c36a7160c1c7")}},
   :block/children
   ({:block/id #uuid "66261957-b16d-4f72-a1c5-1c507d7de75a",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "嵌入式开发\ntitle:: 🕹️嵌入式开发"}
    {:block/id #uuid "662619e9-3dc5-4478-afcf-8f0899cb7b5d",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "662619ff-dd5a-45a4-9395-63a1ffa214ca",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66261a92-26c8-4ab0-9914-b3ecedf4708f",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "66261aa4-d0d7-4918-8f33-7be3d3677dfc",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "关键字/常量/变量"}
          {:block/id #uuid "66261abb-f16a-409f-801f-2c0eae4017e7",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "数据类型"}
          {:block/id #uuid "66261ac0-1061-4786-976c-b594e8c2c68e",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "输入/输出/格式化"}
          {:block/id #uuid "66261ac9-91bc-438b-9c22-244b0c14ee71",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "运算符"}
          {:block/id #uuid "66261ad7-0b6d-4815-a906-23c7bc656f68",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "表达式"}
          {:block/id #uuid "66261ad8-532f-42c5-8f7c-331069d46942",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "语句"}
          {:block/id #uuid "66261ada-5ac6-4c1c-b625-257dcc68fc92",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "判断"}
          {:block/id #uuid "66261adb-52ca-4b59-a925-26257f465eb6",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "循环"}
          {:block/id #uuid "66261add-1255-466b-a160-4ad2f9258be5",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "数组"}],
         :block/content "基础"}
        {:block/id #uuid "66261ade-cefb-452e-9067-9369b183c2f8",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "结构体/共同体/枚举/位操作"}
        {:block/id #uuid "66261ae9-2005-4581-93b5-ef5f0b7c6743",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "函数"}
        {:block/id #uuid "66261aea-8cee-42e2-b1d7-7919caed69e8",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "指针"}
        {:block/id #uuid "66261aeb-f2ab-4f42-9ebd-c05dbe18e443",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "内存管理"}],
       :block/content "C语言"}],
     :block/content "编程语言"}
    {:block/id #uuid "66261b09-148b-489d-ae3c-f7ec7e6d7915",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66261b2e-989a-4862-acf6-052673eb19e2",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66261b33-2b7e-4b56-b1e2-0417e6061c42",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "抽象"}
        {:block/id #uuid "66261b35-2275-4040-ab08-fa5839fb9159",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "类"}
        {:block/id #uuid "66261b36-bacd-41c5-98a5-c334d300c472",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "封装"}
        {:block/id #uuid "66261b38-19a2-4cce-89fc-de04dea7fcad",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "继承"}
        {:block/id #uuid "66261b39-08dc-47bd-b506-08e5b5b43012",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "多态"}],
       :block/content "面向对象"}
      {:block/id #uuid "66261b3c-8d31-4508-9c97-b49f29e6bd25",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "容器"}
      {:block/id #uuid "66261b3f-7ccb-4064-978f-7214dae8aa74",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "模板"}
      {:block/id #uuid "66261b40-40f5-4097-8aef-96acdf2a1f24",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "泛型"}
      {:block/id #uuid "66261b42-81cf-4445-b954-7f4dd1244a7a",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "STL"}
      {:block/id #uuid "66261b44-7cc5-4cbc-b403-9c225a54c921",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "RTTL"}
      {:block/id #uuid "66261b46-7a86-4601-a3c1-fa5c92d67de1",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "元编程"}],
     :block/content "C++"})}
  {:block/id #uuid "65f14810-fea2-40fb-baf2-0ca8e982c247",
   :block/page-name "hls__PLC工业控制_1709865655594_0",
   :block/properties
   {:file
    "[PLC工业控制_1709865655594_0.pdf](../assets/PLC工业控制_1709865655594_0.pdf)",
    :file-path "../assets/PLC工业控制_1709865655594_0.pdf"},
   :block/children
   ({:block/id #uuid "65f14810-d852-4b6f-85c1-10345731ae5a",
     :block/properties
     {:file
      "[PLC工业控制_1709865655594_0.pdf](../assets/PLC工业控制_1709865655594_0.pdf)",
      :file-path "../assets/PLC工业控制_1709865655594_0.pdf"},
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "663aec8a-02ed-4e79-a8fa-ac4f020d4000",
   :block/page-name "hls__GNU_Make_Manual_1715137311326_0",
   :block/properties
   {:file
    "[GNU_Make_Manual_1715137311326_0.pdf](../assets/GNU_Make_Manual_1715137311326_0.pdf)",
    :file-path "../assets/GNU_Make_Manual_1715137311326_0.pdf"},
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "663aec8a-5ce6-45a7-870b-a9324c75ed16",
     :block/properties
     {:file
      "[GNU_Make_Manual_1715137311326_0.pdf](../assets/GNU_Make_Manual_1715137311326_0.pdf)",
      :file-path "../assets/GNU_Make_Manual_1715137311326_0.pdf"},
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "660a4f29-dd3a-4be3-a772-997d975ad4a0",
   :block/page-name "Robotics",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14810-12b8-4867-ba1b-c33125b566be",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[Control]]"}
    {:block/id #uuid "65f14810-a71c-43b6-a718-dc5c64bb69bd",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[Communication]]"})}
  {:block/id #uuid "660a4f29-c8a2-403d-bfaf-bcfa154d1130",
   :block/page-name "Communication",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14810-4b07-4a2c-a210-62cb5a6194c4",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "[[Bus]]"})}
  {:block/id #uuid "6626201e-53ee-4bf0-9256-e05af0c83f4d",
   :block/page-name "嵌入式硬件基础",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66262020-5330-4bb7-bbaf-5285fd6c227f",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[模电/数电基础]]"}
    {:block/id #uuid "662621cc-c94e-4f43-9e92-9d9856ac9444",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[元器件和芯片]]"}
    {:block/id #uuid "662621e0-83ac-440d-b5ed-1bfd749262b7",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[器件通信方式/协议/接口/总线等原理]]"}
    {:block/id #uuid "66262200-8449-47d0-8073-4de77352fe9a",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[电路原理图，电路图和PCB板]]"}
    {:block/id #uuid "6626220d-701c-45e6-8776-29f71a15fc02",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[DataSheet]]"}
    {:block/id #uuid "66262215-6c77-45d7-9f75-d968b1a17b15",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[硬件时序图]]"}
    {:block/id #uuid "6626221a-3b4d-4ebc-af78-68fc42ea6270",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children [],
     :block/content "## [[电路仿真]]"})}
  {:block/id #uuid "6613b384-1dcc-4f0a-a25f-4cb486a66c49",
   :block/page-name "Apr 16th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "661dca64-e4a4-4ada-babb-e0d10e484d64",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "88.6 kg #Weight"}
    {:block/id #uuid "661dca74-7e48-42cc-b04c-ea32acf28341",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "不要因为贤者时间而放弃对拔作的执念！ #balderdash"})}
  {:block/id #uuid "6625fcd2-24e0-4dbc-859f-421d019cf36f",
   :block/page-name "？",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "661a32ed-9b3b-4056-a3ac-8093b48cb7b5",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "#。"})}
  {:block/id #uuid "6625fcd2-e3f6-4bf2-8125-9277c7e6b03c",
   :block/page-name "Project. Arceus",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "660a4f28-8d9b-4762-9412-786a3f103644",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "**项目背景** 开始接触源码，根据源码了解各功能具体如何实现，同时学习 [[C++程序设计]]。"}
    {:block/id #uuid "660a4f28-60a9-4d48-91ec-f117ba2ba1e9",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "**项目目标** 了解Pro总线型PLC底层的功能实现，熟练掌握[[C++程序设计]]。"}
    {:block/id #uuid "660a4f28-9e87-4c32-b1f4-1d1dd2349737",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "660a4f28-46e3-417a-b568-1809340ee30e",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "项目库：http://192.168.1.50/Motion_Robotics/cr100-platform.git （Pro_dev分支）"}],
     :block/content "**项目资料**\ncollapsed:: true"}
    {:block/id #uuid "660a4f28-19dc-488e-9741-148d976cb0aa",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "660a4f28-67f1-4245-87da-29b9f37d4a8a",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "((660610f9-34ba-4a7d-88a2-9abd0f53389e))"}
      {:block/id #uuid "660a4f28-2cb0-42d7-9f74-31183db2e17a",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "LATER PLC源码学习\nDEADLINE: <2024-04-30 Tue 18:00>\n:LOGBOOK:\nCLOCK: [2024-04-01 Mon 09:29:18]\nCLOCK: [2024-04-01 Mon 09:29:23]--[2024-04-01 Mon 17:45:59] =>  08:16:36\nCLOCK: [2024-04-07 Sun 09:39:15]--[2024-04-07 Sun 22:26:36] =>  12:47:21\nCLOCK: [2024-04-08 Mon 10:37:47]--[2024-04-08 Mon 11:35:21] =>  00:57:34\nCLOCK: [2024-04-08 Mon 13:38:42]--[2024-04-08 Mon 19:01:41] =>  05:22:59\nCLOCK: [2024-04-10 Wed 09:06:01]--[2024-04-10 Wed 18:03:44] =>  08:57:43\nCLOCK: [2024-04-11 Thu 10:35:13]--[2024-04-11 Thu 18:00:02] =>  07:24:49\nCLOCK: [2024-04-12 Fri 09:01:29]--[2024-04-12 Fri 18:02:05] =>  09:00:36\nCLOCK: [2024-04-15 Mon 09:11:22]--[2024-04-15 Mon 19:05:30] =>  09:54:08\nCLOCK: [2024-04-16 Tue 08:49:50]--[2024-04-16 Tue 20:07:37] =>  11:17:47\nCLOCK: [2024-04-17 Wed 08:55:37]--[2024-04-19 Fri 08:46:45] =>  47:51:08\nCLOCK: [2024-04-22 Mon 09:19:31]--[2024-04-23 Tue 08:59:04] =>  23:39:33\nCLOCK: [2024-04-23 Tue 09:19:54]--[2024-04-23 Tue 16:02:06] =>  06:42:12\n:END:"}
      {:block/id #uuid "6625fcd2-8425-4f1b-ab3c-acc5c9ef7995",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "LATER [[C++程序设计]] 进阶学习 #📓Note\nDEADLINE: <2024-04-30 Tue 18:00>\n:LOGBOOK:\nCLOCK: [2024-04-12 Fri 09:01:27]--[2024-04-12 Fri 18:02:06] =>  09:00:39\nCLOCK: [2024-04-15 Mon 09:11:23]--[2024-04-15 Mon 19:05:31] =>  09:54:08\nCLOCK: [2024-04-16 Tue 08:49:52]--[2024-04-16 Tue 20:07:38] =>  11:17:46\nCLOCK: [2024-04-17 Wed 08:55:39]--[2024-04-19 Fri 08:46:47] =>  47:51:08\nCLOCK: [2024-04-22 Mon 09:19:35]--[2024-04-23 Tue 08:59:05] =>  23:39:30\nCLOCK: [2024-04-23 Tue 09:19:56]--[2024-04-23 Tue 16:02:07] =>  06:42:11\n:END:"}],
     :block/content "**项目计划与进度**"}
    {:block/id #uuid "660a4f28-2a67-48c4-b500-f0acd11664da",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "**项目记录**"}
    {:block/id #uuid "660a4f28-df0b-4bfa-8da8-b4bfb6802592",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "**项目总结**"})}
  {:block/id #uuid "661420a8-b6fd-4434-8bac-1a26420a34a5",
   :block/page-name "Apr 9th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "661420aa-8b91-4431-8b91-5cea9fcedc25",
     :block/properties {},
     :block/format :markdown,
     :block/children [],
     :block/content "每天又要情绪管理，又要表情管理，还要身材管理，我难道是……管理岗？ #balderdash"})}
  {:block/id #uuid "660a4f28-3824-4d5c-81a3-da7822905236",
   :block/page-name "hls__C++_Primer_Plus_6th_Edition_1711676090207_0",
   :block/properties
   {:file
    "[C++_Primer_Plus_6th_Edition_1711676090207_0.pdf](../assets/C++_Primer_Plus_6th_Edition_1711676090207_0.pdf)",
    :file-path
    "../assets/C++_Primer_Plus_6th_Edition_1711676090207_0.pdf"},
   :block/children
   ({:block/id #uuid "660a4f28-7df8-4d3e-8751-1a9d831e9bc9",
     :block/properties
     {:file
      "[C++_Primer_Plus_6th_Edition_1711676090207_0.pdf](../assets/C++_Primer_Plus_6th_Edition_1711676090207_0.pdf)",
      :file-path
      "../assets/C++_Primer_Plus_6th_Edition_1711676090207_0.pdf"},
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "6612bf30-e546-4824-8044-309da7647b52",
   :block/page-name "Cosmetique",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "6612bf30-2ca0-4465-b580-a95433faffee",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "660a4f27-55cf-494d-a924-9825d8de80f2",
   :block/page-name "Apr 1st, 2024",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "660a4f27-fd2e-4e16-ae1c-3c2003365096",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "66140b88-cb2d-4f90-b597-cf2f3489ba82",
   :block/page-name "Apr 8th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66140b8a-f387-468e-84b6-abbb55426c7f",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "对热水尿尿者，必将被热水灼伤！#balderdash\n:LOGBOOK:\nCLOCK: [2024-04-08 Mon 23:38:01]\n:END:"})}
  {:block/id #uuid "660a4f29-8d6a-4fd9-bfa4-68928307528a",
   :block/page-name "Project. Carterpie",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14810-c8c4-4580-a0c1-46a012b7e9f5",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content
     "**项目背景** 入职后开始承担部分工作，此类工作较为琐碎，无法以项目为单位开展。因此将此类琐碎的工作作为此项目的子任务统一记录。"}
    {:block/id #uuid "65f14810-b3bf-406d-8ee7-f39b0a6032a9",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "**项目目标** 完成全部子任务。"}
    {:block/id #uuid "65f14810-8fb0-4051-bfcb-adc697a98cf3",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "**项目资料** 暂无"}
    {:block/id #uuid "65f14810-a2fa-4642-a9f2-15aede2a6178",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14810-a37a-4554-a132-0b155da1a99a",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children [],
       :block/content
       "DONE 测试程序PLC网口通信Modbus TCP 主站连接问题 [[Mar 12th, 2024]]\n:LOGBOOK:\nCLOCK: [2024-03-12 Tue 14:38:26]\nCLOCK: [2024-03-12 Tue 14:38:27]\nCLOCK: [2024-03-12 Tue 14:38:35]\nCLOCK: [2024-03-12 Tue 14:38:45]\nCLOCK: [2024-03-12 Tue 14:38:51]--[2024-03-12 Tue 15:37:26] =>  00:58:35\n:END:"}
      {:block/id #uuid "65fa3b87-c071-4795-be00-55f771989ff0",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children [],
       :block/content
       "DONE Pro总线PLC硬件配置问题。使用X0和X1可读数据，但使用X16和X17无数据。[[Mar 19th, 2024]]\n:LOGBOOK:\nCLOCK: [2024-03-20 Wed 09:27:42]\n:END:"}
      {:block/id #uuid "65fa3c48-d91c-4a92-87c5-d88329d4a153",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65fa4933-b4f5-4998-885f-351a6e92b0c5",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "[[Mar 20th, 2024]]更新：需差分单端信号转接板（用于 ((65fab455-6764-4897-8823-22eaab95fa25))），等待采购。预计本周五 [[Mar 22nd, 2024]]完成采购。"}
        {:block/id #uuid "6602457b-2886-485d-8e16-802c403b5d2f",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "66029db6-2a01-4307-9f01-3406e82d0707",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "经验证差分单端信号转接板可用。已完成接线；"}
          {:block/id #uuid "66029dc8-3148-416c-a5ed-3c4af20e3a21",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "66037999-86cc-4e7e-af9a-85b335b5481f",
             :block/properties {},
             :block/format :markdown,
             :block/children [],
             :block/content
             "经确认可以使用，但是需要手动使能，同时也需要MC_POWER指令。但可以用MC_POWER的状态位或者有效位使能，但实际上并非是MC_POWER有效果，MC_POWER仅改变了PLC内部轴的状态。"}],
           :block/content "~~脉冲型伺服无法使用MC指令，需再次确认；~~\ncollapsed:: true"}
          {:block/id #uuid "66029dcb-7e7e-45ec-8469-a7085187f9c0",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "Pro总线型PLC直接使用*“PWM双字脉宽调制”**输出脉冲时无需进行硬件映射，进行映射后会导致方向信号的输出口无法修改；"}
          {:block/id #uuid "66029dd5-5af7-4b29-ba67-9305aa9892ca",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "66038c49-2b66-45e0-bc88-fe50944c9ce1",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "使用MC指令计数，不再使用PWM双字脉宽调制"}],
           :block/content
           "待确认Pro总线型PLC中如何对脉冲输出进行计数。（FGs系列PLC中为寄存器D8140）\ncollapsed:: true"}],
         :block/content "[[Mar 26th, 2024]]更新："}
        {:block/id #uuid "6603bf61-4239-40b5-998e-6f13067d8d89",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "[[Mar 27th, 2024]]更新：使用PLC极限脉冲频率（200kHz）进行持续测试。一周后 [[Apr 3rd, 2024]]观察是否准确。"}],
       :block/content
       "DONE Pro总线PLC输入输出测试 [[Mar 19th, 2024]]\n:LOGBOOK:\nCLOCK: [2024-03-20 Wed 09:31:02]--[2024-03-20 Wed 10:25:30] =>  00:54:28\nCLOCK: [2024-03-20 Wed 10:25:33]\nCLOCK: [2024-03-26 Tue 08:50:46]--[2024-03-26 Tue 11:49:59] =>  02:59:13\nCLOCK: [2024-03-26 Tue 13:55:00]--[2024-03-26 Tue 18:05:53] =>  04:10:53\nCLOCK: [2024-03-27 Wed 09:23:37]--[2024-03-27 Wed 13:35:36] =>  04:11:59\nCLOCK: [2024-03-27 Wed 16:47:23]\n:END:"}
      {:block/id #uuid "6603bf73-7fd2-447a-b33e-a7f4698abe4a",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children [],
       :block/content ""}],
     :block/content "**项目计划与进度**"}
    {:block/id #uuid "65f14810-b59c-4bf2-93fc-557a76429e29",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14810-5c25-4d93-84ab-4c0929863238",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f14810-9c25-4161-b83e-8da39431512a",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content
         "首先应调用通信指令DESTIP，如下图所示\n![image.png](../assets/image_1710225764704_0.png)\n|参数名称|参数类型|IO类别|备注|\n|COM(客户端编号)|WORD|I||\n|RES(命令编号)|WORD|I|储存IP地址的首个寄存器|\n需要使用五个连续的D寄存器，将从站IP地址和端口号存入。前四个储存IP地址，第五个储存端口号。**在接通指令前需要提前为寄存器赋值。**\n#+BEGIN_WARNING\n**用户手册中描述为双字D寄存器，导致客户使用D1000，D1002，D1004，D1006和D1008储存导致错误。**\n#+END_WARNING"}
        {:block/id #uuid "65f14810-ab59-404a-a470-771e0653ca82",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content
         "之后调用MODBUS_TCP_MASTER指令，如下图所示\n![image.png](../assets/image_1710226172850_0.png){:height 482, :width 718}\n|参数名称|参数类型|IO类别|备注|\n|COM(客户端编号)$\\qquad\\quad\\qquad$|WORD$\\qquad\\quad$|I||\n|TBL(Modbus表格)|STRING|I|Modbus主站表格ID，可在工程管理窗口中添加所需要的Modbus表格|\n|WR(信息代码)|WORD|O|存储通信信息代码|\n|WR_ID(命令编号)|WORD|O|存储当前主站表格的Modbus 命令序列编号， 表示当前所运行至该表格的哪一条命令序列，编号为 0~n-1，其中 n 为表格内的命令序列总数|"}
        {:block/id #uuid "65f14810-6b55-4596-a282-76a2d908c6e3",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content
         "在通信设置中，主站的IP地址应注意不能与从站一致，但要处于同一个局域网段中，否则会导致连接失败；"}
        {:block/id #uuid "65f14810-e6e0-4bf2-8a40-90d9b122d9d2",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content
         "PLC做主站时协议应选择Modbus_TCP_Client，做从站时协议选择Modbus_TCP_Server。"}
        {:block/id #uuid "65f14810-edfd-494a-813f-ec95886ffb88",
         :block/properties {:logseq.order-list-type "number"},
         :block/format :markdown,
         :block/children [],
         :block/content "((65f00c9b-99aa-4c1b-a1fd-951e4280a235))"}],
       :block/content "使用Modbus TCP协议以PLC为主站通信失败"}
      {:block/id #uuid "65fa3be1-d872-4243-916e-b31be0b251f7",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children [],
       :block/content
       "Pro总线PLC硬件配置问题：控制轴与输入一一对应，轴号0对应X0和X1；因此使用X16和X17应添加轴，使用轴号7。"}
      {:block/id #uuid "65fa3c72-08ed-4679-815e-cf6194f176bc",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66038c60-c24d-4fd4-a7eb-26b58020a249",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "#+BEGIN_CENTER\n测试记录\n#+END_CENTER\n|输入端口|输出端口|PLC输出|伺服接收|PLC接收|\n|X0，X1|Y0，Y10|200000|200000|200000|\n|X2，X3|Y1，Y11|-20000|-20000|-20000|\n|X4，X5|Y2，Y12|200000|200000|200000|\n|X6，X7|Y3，Y13|200000|200000|200000|\n|X10，X11|Y4，Y14|-20000|-20000|-20000|\n|X12，X13|Y5，Y15|20000|20000|20000|\n|X14，X15|Y6，Y16|20000|20000|20000|\n|X16，X17|Y7，Y17|20000|20000|20000|"}],
       :block/content "Pro总线PLC输入输出测试"}],
     :block/content "**项目记录**"}
    {:block/id #uuid "65f14810-08cb-4f7d-8fc8-163cc738d4f4",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "**项目总结**"})}
  {:block/id #uuid "65fcdb15-c224-415d-ae7e-72b7ff4592e3",
   :block/page-name "电子凸轮",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "65faa73b-fb1d-46e1-8b14-506320511945",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65fb9787-a0bf-447b-90f9-459a57e7d04e",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65faa745-eb20-4cf3-9838-5b9604f384b9",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "65faa78a-6c56-4a22-8d57-7549d7cbbb24",
           :block/properties nil,
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "65faa96c-3c96-485b-84bc-7e50c304df76",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "将**目标值跟随地址**设置为D8140（Y000的32位脉冲累积计数），同时设置一个Y000的双字脉冲输出，ECAM就会随D8140变化而在Y0001产生响应输出。具体梯形图和ECAM设置如下：\n![image.png](../assets/image_1710926497532_0.png)\n![image.png](../assets/image_1710926523100_0.png)"}],
           :block/content
           "((65f80443-200c-4718-914e-e606e94f4697))\ncollapsed:: true\n主从轴要搞清楚。之前未搞清楚电子凸轮中主轴如何定义，认为主轴就是一个“固定的转速“；实际上ECAN设置中**目标值跟随地址**即是储存主轴当前位置的寄存器（参数命名过于抽象，文档也说得不明白），而脉冲输出口则是控制从轴的脉冲输出。因此，在之前错误的梯形图中，目标值跟随地址恒为0，因此ECAM无输出。"}
          {:block/id #uuid "65faaabb-35e6-4c34-9663-b7cbd0b69e3a",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "FGs系列输出口只有前面几个为高速脉冲输出，应注意具体型号。"}
          {:block/id #uuid "65fcdf21-d9ad-42a7-a7a4-707d0a434ac1",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "#+BEGIN_NOTE\n***主轴每圈前进距离*** 实际上是硬件参数，需要根据实际使用的硬件填写，之后程序会根据自动适配此参数，以保证位移和期望一致。并非是可以随意设置的程序变量。\n#+END_NOTE"}
          {:block/id #uuid "65fb97b5-fc3d-4b19-b769-bd6ae7d6843e",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "65fcdb15-304f-4599-b1e5-415b6462d80a",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "~~降低主轴每圈前进距离后，从轴转速明显下降。~~"}
            {:block/id #uuid "65fcdb15-2d2d-4dd5-9038-35855af38889",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "~~并非前进相同距离后，主轴旋转圈数更多，主轴转速更快，发送脉冲更多，从而使从轴转速上升；~~"}
            {:block/id #uuid "65fcdb15-a094-456c-b0d3-917402eb52e2",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content
             "~~而是主轴转速不变，主轴每圈前进距离下降，导致主轴前进速度变慢，是的从轴转速下降；~~"}
            {:block/id #uuid "65fcdb15-8ba5-4fb6-88f7-3edf6f3ce7e3",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "~~因此，从轴并非由参数**主轴每圈脉冲数**控制。~~"}],
           :block/content "~~【追剪&飞剪】主轴每圈前进距离~~"}
          {:block/id #uuid "65fcdb15-07bb-44af-ae98-f0f97f4e8aee",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "65fcdb15-92d9-43ee-8574-138b31067ffd",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "~~提高主轴每圈脉冲数，从轴转速下降。~~"}],
           :block/content "~~【追剪&飞剪】主轴每圈脉冲数~~"}
          {:block/id #uuid "65fcdb15-16d3-4130-8374-b6fa9b8ac509",
           :block/properties {:logseq.order-list-type "number"},
           :block/format :markdown,
           :block/children
           [{:block/id #uuid "65fcdb15-97aa-467a-b021-f00a6865bb3c",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "~~提高从轴每圈脉冲数后，从轴行程明显上升，转速明显上升；~~"}
            {:block/id #uuid "65fcdb15-1a7f-4e10-8d44-6b0ee6752a85",
             :block/properties nil,
             :block/format :markdown,
             :block/children [],
             :block/content "~~提高从轴每圈脉冲后，电子凸轮ECAM发送的脉冲数明显增多；~~"}],
           :block/content "~~【追剪】从轴每圈脉冲数~~"}],
         :block/content
         "PLC：FGs系列；伺服驱动器：R8-2208P-N（脉冲型）；电机：80HK-A02430-CS2A2（绝对式编码器）"}
        {:block/id #uuid "65fce110-ca9c-4bec-aec9-b4bc71fd5305",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "65fce28b-b158-4ad3-9e1a-d7390d433209",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "MC_CamIn指令中，参数StartPosition决定何时凸轮运动。假设StartPosition设置为100，当主轴位置达到100时，凸轮才会开始动作，InCam参数变为ON。"}
          {:block/id #uuid "65fce602-ee38-449b-a6a1-ae0f7de2f989",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "初步理解是以StartPosition为原点计算位移，电子凸轮开始随位移工作。"}],
         :block/content
         "PLC：INOVANCE Easy521；伺服驱动器：：R8-2226Z-N（总线型）；电机：80HK-A02430-CS2A2（绝对式编码器）"}],
       :block/content "### 基本功能测试"}],
     :block/content "## 电子凸轮功能测试记录"}
    {:block/id #uuid "65fb8854-0c4a-4dda-b25e-88d7ada00932",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65fb885b-2ca4-4ead-b0c7-80011118858a",
       :block/properties {:heading 3},
       :block/format :markdown,
       :block/children [],
       :block/content "### “主轴位置”具体指什么，又是如何记录的？"}],
     :block/content "## 电子凸轮相关知识"}
    {:block/id #uuid "65faa6d1-194c-4320-8257-ac1c780f3c8e",
     :block/properties {:heading 2},
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f3a971-1000-4794-9a8c-7ba9e7c585b3",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f3a976-36dd-40b5-bdad-27c6ab28fce3",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "![image.png](../assets/image_1710467462092_0.png)"}
        {:block/id #uuid "65f3adbb-e89d-49fb-a8d0-b34216e060e8",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "![image.png](../assets/image_1710469243644_0.png)"}],
       :block/content "通用凸轮\ncollapsed:: true"}
      {:block/id #uuid "65f2acb4-aac7-4517-ab81-a92349612a3f",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f3a6ef-d89a-4c4e-984a-a2822abee4a1",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "![52752200a3bc41d787f7514e6b6adf0f.gif](../assets/52752200a3bc41d787f7514e6b6adf0f_1710464886570_0.gif)"}
        {:block/id #uuid "65f3a953-fd80-489f-89a1-82aee0be928f",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "![image.png](../assets/image_1710467413763_0.png)"}
        {:block/id #uuid "65f3b14c-6325-4fca-b6b9-5fda7988dcf7",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "![image.png](../assets/image_1710469452991_0.png)"}],
       :block/content "追剪\ncollapsed:: true"}
      {:block/id #uuid "65f3a02f-5b74-49e0-8f88-5788297992d3",
       :block/properties nil,
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "65f3a6e3-f990-4e04-8378-42eb4c1fb29a",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "![80fdf0ce478c4ea9b60212d4f14e1d5c.gif](../assets/80fdf0ce478c4ea9b60212d4f14e1d5c_1710465073281_0.gif)"}
        {:block/id #uuid "65f3a95d-509e-4e3c-9e44-ac137b901658",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "![image.png](../assets/image_1710467431087_0.png)"}
        {:block/id #uuid "65f3b151-c008-4b94-ba77-1423ccc0eeed",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "![image.png](../assets/image_1710469591222_0.png){:height 203, :width 778}"}],
       :block/content "飞剪\ncollapsed:: true"}],
     :block/content "## SamSoarII帮助文档"})}
  {:block/id #uuid "6625fcd2-626e-4188-8dc7-55aa433f949b",
   :block/page-name "💡Idea",
   :block/properties nil,
   :block/children
   ({:block/id #uuid "65f14810-a453-4bdf-8330-98622ef4fb91",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "65f14810-cd6b-4e1b-9b0f-489389a3c26f",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "用Pokémon的英文名缩写作为项目代号是我作为 ~~**宝批**~~ **宝可梦厨**厨力满满的最佳表现口牙！"}
      {:block/id #uuid "65f14810-9a8e-4d9b-a5f6-27f76ffef9a3",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "**Pokémon Get Da☆ze！！！"}],
     :block/content "来到新公司第一件事当然是想一套新的项目代号命名方式！"}
    {:block/id #uuid "65f14810-7966-4466-9630-7b63390a4d8f",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "先给每个页面标题，加上元气满满的图标💡吧！"}
    {:block/id #uuid "65f14810-b5de-4390-b31d-84d54dae0122",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "**结果我第一，又强又厉害！**"}
    {:block/id #uuid "660a4f29-91dd-426d-9f77-705dfe05f586",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "百战勇者·苍响翻译成Hero of many battles·Zacian真是土中土中土！"}
    {:block/id #uuid "660ae963-c262-4988-9d49-059e7395ed08",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "VIA改键真的简单方便，真不知道是为了生产力还是为了好玩。"}
    {:block/id #uuid "660ae99c-3a74-452e-822d-607d37004276",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "这什么油润红酒轴声音也太响了吧，在公司用不会被人打吗？"}
    {:block/id #uuid "660ae9bf-388a-4433-89a5-452d84aade13",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "一杯茶，一包烟，一个环境配一天。"}
    {:block/id #uuid "660ae9d3-4e3f-4e45-8598-e316666a6047",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "没有IDE的开发环境难道真的要我学习VIM吗？就连VIM都只有Tiny版啊。"}
    {:block/id #uuid "660ae9f4-f2c0-4078-a8c7-0c5911fc7d4a",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "安全生产，安全第一。"})}
  {:block/id #uuid "66061d86-0699-45c2-8f0a-4ece06603cee",
   :block/page-name "hls__Pro_GIT_2nd_Edition_1711676168026_0",
   :block/properties
   {:file
    "[Pro_GIT_2nd_Edition_1711676168026_0.pdf](../assets/Pro_GIT_2nd_Edition_1711676168026_0.pdf)",
    :file-path "../assets/Pro_GIT_2nd_Edition_1711676168026_0.pdf"},
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "66061d86-3cec-4eec-9374-fc87a66777e2",
     :block/properties
     {:file
      "[Pro_GIT_2nd_Edition_1711676168026_0.pdf](../assets/Pro_GIT_2nd_Edition_1711676168026_0.pdf)",
      :file-path "../assets/Pro_GIT_2nd_Edition_1711676168026_0.pdf"},
     :block/format :markdown,
     :block/children [],
     :block/content ""})}
  {:block/id #uuid "660a5cd0-cc8d-4c2d-a644-1c98ece94626",
   :block/page-name "hls__C++_Primer_5th_Edition_1711955120450_0",
   :block/properties
   {:file
    "[C++_Primer_5th_Edition_1711955120450_0.pdf](../assets/C++_Primer_5th_Edition_1711955120450_0.pdf)",
    :file-path "../assets/C++_Primer_5th_Edition_1711955120450_0.pdf"},
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "660a5cd0-0118-42ea-a6a5-145603923bf9",
     :block/properties
     {:file
      "[C++_Primer_5th_Edition_1711955120450_0.pdf](../assets/C++_Primer_5th_Edition_1711955120450_0.pdf)",
      :file-path
      "../assets/C++_Primer_5th_Edition_1711955120450_0.pdf"},
     :block/format :markdown,
     :block/children [],
     :block/content ""}
    {:block/id #uuid "660a65ee-6f35-424c-ba67-d3b925d6a619",
     :block/properties
     {:ls-type "annotation", :hl-page 33, :hl-color "yellow"},
     :block/format :markdown,
     :block/children [],
     :block/content
     "Writing endl has the effect of ending the current line and flushing the buffer associated with that device."}
    {:block/id #uuid "660a6910-ddf4-467e-870a-847f028982ac",
     :block/properties
     {:ls-type "annotation", :hl-page 35, :hl-color "yellow"},
     :block/format :markdown,
     :block/children [],
     :block/content
     "Although the compiler ignores comments, readers of our code do not. Programmers tend to believe comments even when other parts of the system documentation are out of date. An incorrect comment is worse than no comment at all because it may mislead the reader. When you change your code, be sure to update the comments, too!"})}
  {:block/id #uuid "6629b412-a5b9-45e1-931f-d99724aeacfa",
   :block/page-name "Apr 25th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "6629b415-398f-4956-b026-6a0641b61dfc",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "87.75 kg #Weight"}
    {:block/id #uuid "6629b422-74bb-4556-8126-870c83559fbe",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "即使是在草台班子里，我也是最草的那一个。 #balderdash"})}
  {:block/id #uuid "660a4f28-1d60-4efe-91e2-eb7ef5df4d27",
   :block/page-name "Mar 29th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "660610f9-34ba-4a7d-88a2-9abd0f53389e",
     :block/properties {},
     :block/format :markdown,
     :block/children [],
     :block/content
     "DONE [[C++程序设计]] 基础学习 #📓Note\nDEADLINE: <2024-04-30 Tue 18:00>\nid:: 660610f9-34ba-4a7d-88a2-9abd0f53389e\n:LOGBOOK:\nCLOCK: [2024-04-01 Mon 09:29:05]--[2024-04-01 Mon 17:45:58] =>  08:16:53\nCLOCK: [2024-04-02 Tue 09:32:38]--[2024-04-02 Tue 10:57:57] =>  01:25:19\nCLOCK: [2024-04-02 Tue 11:07:35]--[2024-04-02 Tue 11:50:59] =>  00:43:24\nCLOCK: [2024-04-02 Tue 15:03:33]--[2024-04-03 Wed 09:08:16] =>  18:04:43\nCLOCK: [2024-04-03 Wed 16:52:51]--[2024-04-07 Sun 09:04:59] =>  88:12:08\nCLOCK: [2024-04-07 Sun 09:39:12]--[2024-04-07 Sun 22:26:23] =>  12:47:11\nCLOCK: [2024-04-08 Mon 10:37:34]--[2024-04-08 Mon 11:35:20] =>  00:57:46\nCLOCK: [2024-04-08 Mon 13:38:40]--[2024-04-08 Mon 19:01:40] =>  05:23:00\nCLOCK: [2024-04-09 Tue 01:11:04]--[2024-04-09 Tue 01:11:17] =>  00:00:13\nCLOCK: [2024-04-09 Tue 09:15:44]--[2024-04-09 Tue 18:17:49] =>  09:02:05\nCLOCK: [2024-04-10 Wed 09:05:59]--[2024-04-10 Wed 18:03:42] =>  08:57:43\n:END:"})}
  {:block/id #uuid "660a4f29-0b6a-43aa-89e3-c062fd0dda83",
   :block/page-name "Mar 19th, 2024",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "65f8e42f-dbe0-474f-9b70-973c79ffe041",
     :block/properties nil,
     :block/format :markdown,
     :block/children [],
     :block/content "今日接线失误出现危险，万幸无人受伤。"})}
  {:block/id #uuid "6616bb6f-752c-4f4b-b95c-c7aa24a40573",
   :block/page-name "Project. Spearow",
   :block/properties nil,
   :block/format :markdown,
   :block/children
   ({:block/id #uuid "6616bb87-2505-45ad-bfe5-ca9d2928633c",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66270843-2510-4e40-a115-71af4896cbb4",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "Pro型总线PLC仿照汇川的总线PLC（EASY系列）进行了电子凸轮功能移植。"}],
     :block/content "**项目背景**"}
    {:block/id #uuid "a11b8929-73a5-4fb6-aec6-6eb4c9cb25a6",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "662708c7-2d23-4489-9af5-ddae70e08355",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children [],
       :block/content "学会嵌入式开发的交叉编译和代码调试；"}
      {:block/id #uuid "66270879-54c8-4fde-9787-7d7270624b64",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children [],
       :block/content "完成电子凸轮功能测试，确认是否存在BUG；"}
      {:block/id #uuid "662708bf-9324-4d7d-8353-12b9e64c5222",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children [],
       :block/content "尝试修复BUG。"}],
     :block/content "**项目目标**"}
    {:block/id #uuid "7676e1fe-4dd0-4bcd-bd17-f79493e26c0a",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "662708ed-48fe-46a8-96ef-0805755cc008",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "((662708fe-4986-498b-8ed4-ec995027ba89))"}
      {:block/id #uuid "662709a1-e515-4db1-a92b-66820f4b4a23",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content "((65f00c9b-99aa-4c1b-a1fd-951e4280a235))"}],
     :block/content "**项目资料**"}
    {:block/id #uuid "d167ed6e-e5c1-4f92-9575-690a064ce61d",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "662709bc-8818-4409-8f52-b6fb825fa3bb",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "DONE 搭建测试设备，对电子凸轮功能进行基本测试\nDEADLINE: <2024-04-23 Tue>\n:LOGBOOK:\nCLOCK: [2024-04-23 Tue 09:07:11]\nCLOCK: [2024-04-23 Tue 09:07:22]--[2024-04-24 Wed 19:37:54] =>  34:30:32\n:END:"}
      {:block/id #uuid "66271586-f84d-480b-ab78-509272c274d8",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "DONE 确定基本测试方案\nDEADLINE: <2024-04-24 Wed>\n:LOGBOOK:\nCLOCK: [2024-04-23 Tue 09:57:28]\nCLOCK: [2024-04-23 Tue 09:57:31]--[2024-04-24 Wed 19:37:56] =>  33:40:25\n:END:"}
      {:block/id #uuid "6629b66c-6756-4cb5-a95e-27e2793c74ca",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "CANCELED 对比汇川EASY521进行测试，使用之前经过测试的汇川程序\nDEADLINE: <2024-04-26 Fri>\n:LOGBOOK:\nCLOCK: [2024-04-25 Thu 09:48:49]--[2024-04-28 Sun 10:01:58] =>  72:13:09\n:END:"}
      {:block/id #uuid "662dae32-e4bc-4a6d-9ee3-64dbab9681ca",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "DONE 电机突然反向问题排查和DEBUG\nDEADLINE: <2024-05-11 Sat>\n:LOGBOOK:\nCLOCK: [2024-04-28 Sun 10:02:28]\nCLOCK: [2024-04-28 Sun 10:02:37]--[2024-05-08 Wed 09:06:00] =>  239:03:23\n:END:"}
      {:block/id #uuid "663ad003-e504-4b63-bba1-7c353b549035",
       :block/properties nil,
       :block/format :markdown,
       :block/children [],
       :block/content
       "NOW 从轴累积误差消除问题确认和解决\nDEADLINE: <2024-05-11 Sat>\n:LOGBOOK:\nCLOCK: [2024-05-08 Wed 09:06:13]\nCLOCK: [2024-05-08 Wed 09:06:15]\n:END:"}],
     :block/content "**项目计划与进度**"}
    {:block/id #uuid "746b6771-01c1-4090-a740-1ced41fa1523",
     :block/properties nil,
     :block/format :markdown,
     :block/children
     [{:block/id #uuid "66272b6e-9b1f-4eb0-8995-20abfc047283",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66272ca0-a28b-4aac-8d45-413d4276d4f1",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "怀疑是上位程序版本的问题；"}
        {:block/id #uuid "66272d13-7b3a-4166-b730-c8adfe64d3ca",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "MC_CAMIN错误码显示4111=0x100F：CAM_ERR_CAMTABLE_NOTEXIST；"}
        {:block/id #uuid "66285b43-4e26-40c4-a6df-c247bd5d181e",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "在CI_MC_CamIn函数被正确调用，问题出在无凸轮表；"}
        {:block/id #uuid "662873e0-dedf-4320-b03b-383f4ba1bf89",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "**使用32(26)版本上位软件，并将PLC底层固件更新后问题解决。**"}],
       :block/content "下载程序时，勾选电子凸轮显示下载失败；"}
      {:block/id #uuid "66274c53-aab0-4724-bcbc-5fed6c0380e2",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66274c66-57f4-443b-98ab-7ebf02c7787c",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "```linux\nrm -r app\nrm -r /usr/lib\nsync\nsync\ntar -xvf app.tar\nsync\nsync \ntar -xvf lib.tar\n```"}
        {:block/id #uuid "66274ca4-51c1-4c0c-9384-d1da084ab0cf",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "删除根目录下的app文件夹以及usr/lib文件夹，重新解压即可。"}
        {:block/id #uuid "66382db5-38f5-4d31-84e6-50fc644d6d05",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content
         "在每1ms调用一次的函数中增加打印输出，可能会导致无法连接USB，此时需重新刷固件，使用$\\mathsf{run\\ bum}$命令。"}],
       :block/content "回退固件版本"}
      {:block/id #uuid "66276b13-324d-4b8a-b9a3-465bca8fb8e2",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "66276b1b-db71-45f3-8a0d-6e91f9eaf186",
         :block/properties nil,
         :block/format :markdown,
         :block/children [],
         :block/content "波特率选择不对，应选择Pro总线型PLC应选择115200。"}],
       :block/content "secureCRT乱码问题"}
      {:block/id #uuid "66287432-02ee-486d-b111-f06bf02563ca",
       :block/properties {:logseq.order-list-type "number"},
       :block/format :markdown,
       :block/children
       [{:block/id #uuid "6628744c-6851-46a1-b07f-0435ea24548a",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "6628745c-5ffa-4814-9e6b-d5ef38da0542",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "上位软件下载的凸轮表保存于“/update”文件夹，命名为“camtable.xml\"；"}
          {:block/id #uuid "6628747f-a6e9-48b7-af12-1493be1ccdf4",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "底层代码中于“/app/camtable”读取凸轮表“camtable0.xml”（0号凸轮表）；"}
          {:block/id #uuid "662874c2-a7d7-4c10-b80b-f5e11056437f",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "将凸轮表复制到对应路径并重命名，问题解决。"}
          {:block/id #uuid "662a0f02-f774-480f-8fa1-ae6b4000abe4",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "**修改了底层代码，从一个文件中读取凸轮表，问题解决。**"}],
         :block/content "找不到凸轮表"}
        {:block/id #uuid "6628ef29-6c20-427d-9d57-2b763ad3ce7a",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "6628ef30-a65f-4496-9efa-973c6b6ac9f4",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "上位软件下载的凸轮表“/update/camtable.xml”中，包含所有凸轮表；"}
          {:block/id #uuid "6628ef57-dff6-4774-99c7-e03eb18155a9",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "将其拆分成“camtable0.xml”和“camtable1.xml”；"}
          {:block/id #uuid "6628ef89-97e3-43d4-81f6-facda2205294",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "需要修改底层代码，在每个凸轮表的循环开始初始化$\\mathsf{IndexNum}$；"}
          {:block/id #uuid "66382cd5-79eb-4b02-ba32-95526fd554db",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "**修改了底层代码，从一个文件中读取凸轮表，问题解决。**"}],
         :block/content "多个凸轮表问题"}
        {:block/id #uuid "6628efdd-434e-4af5-bc38-8a784f868c92",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "6628efff-3325-46be-9dcb-f450f3ca5640",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "目前采用虚轴模式，未连接伺服；"}
          {:block/id #uuid "6629b641-53c4-4da7-a6e6-18b67db79133",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "连接伺服后，电机实际转动与虚轴模式一致；"}
          {:block/id #uuid "66382ce2-79fc-4b86-9a1f-9227a42c587a",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "**将五次样条曲线的系数储存于曲线结束点，问题解决。**"}],
         :block/content "从轴初始位置突变为300+问题"}
        {:block/id #uuid "662dace7-1a71-4b23-9420-ab46dfc1079c",
         :block/properties nil,
         :block/format :markdown,
         :block/children
         [{:block/id #uuid "662dc32f-a3f7-46ed-abc5-123f3c395c71",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "~~经测试，电机在第一条曲线结束后，第二条曲线开始时，指令中的位移会突然变为0，因此其反向位移为**180+电机初始位置**~~；"}
          {:block/id #uuid "66384b51-c20b-4c1e-8414-7ddce00c58a0",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "**在曲线切换时，函数**$\\mathsf{SPos\\_cal}$**中曲线类型的索引 + 1 导致使用了错误的线型，修改后问题解决；**"}
          {:block/id #uuid "66384bad-b5b0-4765-9913-4c3df701ee03",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content "实际位移低于指令位移，导致曲线切换时以极限转速对实际位移进行补偿；"}
          {:block/id #uuid "663875c4-54dd-41d5-978f-4969c4fbfec6",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "~~运算中，轴实际位置~~（$\\mathsf{dfActPos}$）~~和原点~~（$\\mathsf{dfOrigin}$）~~以及凸轮初始位置~~（$\\mathsf{dfsCamActInitPos}$）~~不一致；~~"}
          {:block/id #uuid "663984df-01eb-4213-a2ea-039ceaa10d03",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "在指令计算中，疑似重复考虑了原点的影响（凸轮初始位置疑似为考虑原点影响）；**在指令位置计算中去掉了凸轮初始位置，问题解决；**"}
          {:block/id #uuid "66398526-7ba3-4c86-8fc2-f0d40eca6fff",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "当轴实际位置（$\\mathsf{dfActPos}$）为负时，轴会以极限转速向指令位置运动；"}
          {:block/id #uuid "663acf72-da20-44b8-9e77-12f7e3f4bd7b",
           :block/properties nil,
           :block/format :markdown,
           :block/children [],
           :block/content
           "从轴运动过程中，曲线多次切换，每次切换会产生一定的误差（体现为$\\mathsf{Pos}$和$\\mathsf{Sseg}$之间的差值），而在最后一段对所有误差进行补偿；"}],
         :block/content "电机突然高速问题"}],
       :block/content "**BUG记录**"}],
     :block/content "**项目记录**"}
    {:block/id #uuid "15954b35-efaa-47e1-9fef-d17d52d8f8a6",
     :block/properties nil,
     :block/format :markdown,
     :block/children [], 
     :block/content "**项目总结**"})})}
